###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       24/Mar/2017  12:54:55
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\interrupts.c
#    Command line =  
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\interrupts.c" -D USE_STDPERIPH_DRIVER -D STM32F2XX -D
#        USE_USB_OTG_FS -D KEYBOARD_VER_1 -D SYSTEM_VIEWER_ENABLE -lc
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List" --remarks -o
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --enable_multibytes --fpu=None
#        --dlib_config G:\PRG\IAR7_50_2\arm\INC\c\DLib_Config_Full.h -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\usb\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_OTG_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Core\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\"
#        -I "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\Config\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\OS\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\SEGGER\" -On --use_c++_inline
#        --require_prototypes -I G:\PRG\IAR7_50_2\arm\CMSIS\Include\ -D
#        ARM_MATH_CM3
#    List file    =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List\interrupts.lst
#    Object file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj\interrupts.o
#
###############################################################################

G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working files\src\interrupts.c
      1          #include "header.h"
      2          
      3          /*****************************************************/
      4          //Перевірка на помилки у процесі транзакції черз I2C
      5          /*****************************************************/
      6          inline ErrorStatus check_errors_i2c(void)
      7          {
      8             if (I2C_GetFlagStatus(I2C, I2C_FLAG_TIMEOUT | I2C_FLAG_OVR | I2C_FLAG_AF | I2C_FLAG_ARLO | I2C_FLAG_BERR))
      9             {
     10               I2C_ClearFlag(I2C, I2C_FLAG_TIMEOUT | I2C_FLAG_OVR | I2C_FLAG_AF | I2C_FLAG_ARLO | I2C_FLAG_BERR);
     11               return ERROR;
     12             }
     13             else return SUCCESS;
     14          }
     15          /*****************************************************/
     16          
     17          /*****************************************************/
     18          //Перевірка стану кнопки
     19          /*****************************************************/
     20          inline void check_state_key(GPIO_TypeDef* GPIOx, uint16_t mask_bit, unsigned int number_bit)
     21          {
     22            if((time_set_keyboard[number_bit] == 0) && ((new_state_keyboard & (1<< number_bit)) == 0))
     23            {
     24              //Кнопка до цього моменту не була зафіксована, що вона натиснута
     25              if (GPIO_ReadInputDataBit(GPIOx, mask_bit) == RESET) time_set_keyboard[number_bit]++;
     26            }
     27            else if((time_set_keyboard[number_bit] > 0) && (time_set_keyboard[number_bit] < DEREVIACIA))
     28            {
     29              //Перевіряємо чи пройшов час очікування, і якщо стан кнопки підтверджується, то виставляємо повідомлення. що кнопка натиснута, алеще не оброблена
     30              if(++time_set_keyboard[number_bit] == DEREVIACIA)
     31              {
     32                if (GPIO_ReadInputDataBit(GPIOx, mask_bit) == RESET) new_state_keyboard |= 1<< number_bit;
     33                else time_set_keyboard[number_bit] = 0;
     34              }
     35            }
     36            else
     37            {
     38              if (time_set_keyboard[number_bit] != 0)
     39              {
     40                //Перевіряємо чи кнопка вже відтиснута
     41               if (GPIO_ReadInputDataBit(GPIOx, mask_bit) != RESET) time_set_keyboard[number_bit] = 0;
     42              }
     43            }
     44          }
     45          /*****************************************************/
     46          
     47          /*****************************************************/
     48          //Переривання від I2C
     49          /*****************************************************/
     50          void I2C_EV_IRQHandler(void)
     51          {
     52          #ifdef SYSTEM_VIEWER_ENABLE
     53            SEGGER_SYSVIEW_RecordEnterISR();
     54          #endif
     55            
     56            switch (I2C_GetLastEvent(I2C))
     57            {
     58            case I2C_EVENT_MASTER_MODE_SELECT:                 /* EV5 */
     59              {
     60                if((driver_i2c.action == 0) || (driver_i2c.action == 2))
     61                {
     62                  /* Посилаємо EEPROM адресу для запису */
     63                  I2C->DR = (uint8_t)(driver_i2c.device_id & ((uint8_t)(~I2C_OAR1_ADD0)));
     64                }
     65                else
     66                {
     67                  /* Посилаємо EEPROM адресу для читання */
     68                  I2C->DR = (uint8_t)(driver_i2c.device_id | I2C_OAR1_ADD0);
     69                }
     70                break;
     71              }
     72            case I2C_EVENT_MASTER_TRANSMITTER_MODE_SELECTED:  /* EV6 */
     73              {
     74                //Зупиняємо генерацію переривань від подій
     75                I2C->CR2 &= (uint16_t)((~(uint32_t)I2C_IT_EVT) & 0xffff);
     76                
     77                //Помилки не зафіксовані
     78                unsigned int number_transmit_with_i2c;
     79                if(driver_i2c.action == 0)
     80                {
     81                  //Підготовлюємо буфер для передачі в мікросхему для запису (адреса)
     82                  if (driver_i2c.device_id == EEPROM_ADDRESS)
     83                  {
     84                    //Внутрішня адреса для EEPROM сттановить 2 байти
     85                    Temporaty_I2C_Buffer[0] = ((driver_i2c.internal_address & 0xFF00) >> 8);
     86                    Temporaty_I2C_Buffer[1] = (driver_i2c.internal_address & 0x00FF);
     87                    number_transmit_with_i2c = 2;
     88                  }
     89                  else
     90                  {
     91                    //Внутрішня адреса для RTC сттановить 1 байт
     92                    Temporaty_I2C_Buffer[0] = (driver_i2c.internal_address & 0x00FF);
     93                    number_transmit_with_i2c = 1;
     94                  }
     95                }
     96                else if(driver_i2c.action == 2)
     97                {
     98                  //Підготовлюємо буфер для передачі в мікросхему для запису (адреса + корисні дані)
     99                  if (driver_i2c.device_id == EEPROM_ADDRESS)
    100                  {
    101                    //Запис корисних байт іде разом із двома байтами внутрішньої адреси для EEPROM
    102                    Temporaty_I2C_Buffer[0] = ((driver_i2c.internal_address & 0xFF00) >> 8);
    103                    Temporaty_I2C_Buffer[1] = (driver_i2c.internal_address & 0x00FF);
    104                    for (unsigned int i= 0; i < driver_i2c.number_bytes; i++)
    105                    {
    106                      Temporaty_I2C_Buffer[2 + i] = *(driver_i2c.point_buffer + i);
    107                    }
    108                    number_transmit_with_i2c = 2 + driver_i2c.number_bytes;
    109                  }
    110                  else
    111                  {
    112                    //Запис корисних байт іде разом із одним байтами внутрішньої адреси для RTC
    113                    Temporaty_I2C_Buffer[0] = (driver_i2c.internal_address & 0x00FF);
    114                    for (unsigned int i= 0; i < driver_i2c.number_bytes; i++)
    115                    {
    116                      Temporaty_I2C_Buffer[1 + i] = *(driver_i2c.point_buffer + i);
    117                    }
    118                    number_transmit_with_i2c = 1 + driver_i2c.number_bytes;
    119                  }
    120                }
    121                  
    122                //Зупиняємо потік DMA якщо він запущений
    123                if ((DMA_StreamI2C_Tx->CR & (uint32_t)DMA_SxCR_EN) !=0) DMA_StreamI2C_Tx->CR &= ~(uint32_t)DMA_SxCR_EN;
    124                DMA_StreamI2C_Tx->M0AR = (uint32_t)Temporaty_I2C_Buffer;
    125                DMA_StreamI2C_Tx->NDTR = number_transmit_with_i2c;
    126                  
    127                /* Set Last bit to have a NACK on the last received byte */
    128                I2C->CR2 |= I2C_CR2_LAST;
    129                    
    130                //Очищаємо всі події по DMA_FLAG_GLI2C_Tx
    131                DMA_ClearFlag(DMA_StreamI2C_Tx, DMA_FLAG_TCI2C_Tx | DMA_FLAG_HTI2C_Tx | DMA_FLAG_TEII2C_Tx | DMA_FLAG_DMEII2C_Tx | DMA_FLAG_FEII2C_Tx);
    132                  
    133                //Дозволяємо генерацію переривань від потоку DMA1_ChannelI2C_TX
    134                DMA_StreamI2C_Tx->CR |= DMA_IT_TC;
    135          
    136                /* Дозволяємо для I2C передачу по DMA */
    137                I2C->CR2 |= I2C_CR2_DMAEN;
    138          
    139                /* Дозволяємо DMA_StreamI2C_Tx */
    140                DMA_StreamI2C_Tx->CR |= (uint32_t)DMA_SxCR_EN;
    141                
    142                break;
    143              }
    144            case I2C_EVENT_MASTER_RECEIVER_MODE_SELECTED:
    145              {
    146                //Зупиняємо генерацію переривань від подій
    147                I2C->CR2 &= (uint16_t)((~(uint32_t)I2C_IT_EVT) & 0xffff);
    148                
    149                if (driver_i2c.number_bytes != 1)
    150                {
    151                  //Якщо читання буде проводитися більше ніж один байт, то читання здійснюємо через DMA_FLAG_GLI2C_Rx
    152                    
    153                  //Зупиняємо потік DMA якщо він запущений
    154                  if ((DMA_StreamI2C_Rx->CR & (uint32_t)DMA_SxCR_EN) !=0) DMA_StreamI2C_Rx->CR &= ~(uint32_t)DMA_SxCR_EN;
    155                  DMA_StreamI2C_Rx->M0AR = (uint32_t)driver_i2c.point_buffer;
    156                  DMA_StreamI2C_Rx->NDTR = driver_i2c.number_bytes;
    157                  
    158                  //Очищаємо всі події по DMA_FLAG_GLI2C_Rx
    159                  DMA_ClearFlag(DMA_StreamI2C_Rx, DMA_FLAG_TCI2C_Rx | DMA_FLAG_HTI2C_Rx | DMA_FLAG_TEII2C_Rx | DMA_FLAG_DMEII2C_Rx | DMA_FLAG_FEII2C_Rx);
    160                  
    161                  //Дозволяэмо генерацыю переривань від потоку DMA1_ChannelI2C_RX
    162                  DMA_StreamI2C_Rx->CR |= DMA_IT_TC;
    163          
    164                  /* Дозволяємо для I2C передачу по DMA */
    165                  I2C->CR2 |= I2C_CR2_DMAEN;
    166          
    167                  /* Дозволяємо DMA1_ChannelI2C_RX */
    168                  DMA_StreamI2C_Rx->CR |= (uint32_t)DMA_SxCR_EN;
    169                }
    170                else
    171                {
    172                  //Читання буде проходити тільки одного байту без DMA_FLAG_GLI2C_Rx
    173                   
    174                  I2C->CR1 &= (uint16_t)(~I2C_CR1_ACK);
    175                  I2C->CR1 |= I2C_CR1_STOP;
    176          
    177                  /* Дозволяємо для I2C генерацію переривань по подіях і прийятому новому байту*/
    178                  I2C->CR2 |= I2C_IT_EVT | I2C_IT_BUF;
    179                }
    180          
    181                break;
    182              }
    183            case I2C_EVENT_MASTER_BYTE_RECEIVED_NO_BUSY:
    184              {
    185                /* Забороняємо для I2C генерацію переривань по подіях і прийятому новому байту*/
    186                I2C->CR2 &= (uint16_t)~(I2C_IT_EVT | I2C_IT_BUF);
    187                *driver_i2c.point_buffer = (uint8_t)I2C->DR;
    188          
    189                //Повідомляємо, що читання завершився
    190                driver_i2c.state_execution = 1;
    191                break;
    192              }
    193            default: 
    194              {
    195                break;
    196              }
    197            }
    198            
    199          #ifdef SYSTEM_VIEWER_ENABLE
    200            SEGGER_SYSVIEW_RecordExitISR();
    201          #endif
    202          }
    203          /*****************************************************/
    204          
    205          /*****************************************************/
    206          //Генерація переривань від помилки під час обміну по I2C
    207          /*****************************************************/
    208          void I2C_ER_IRQHandler(void)
    209          {
    210          #ifdef SYSTEM_VIEWER_ENABLE
    211            SEGGER_SYSVIEW_RecordEnterISR();
    212          #endif
    213            
    214            I2C->CR1 |= I2C_CR1_STOP;
    215            
    216            //Зупиняємо потоки DMA якщо вони запущені
    217            if ((DMA_StreamI2C_Tx->CR & (uint32_t)DMA_SxCR_EN) !=0) DMA_StreamI2C_Tx->CR &= ~(uint32_t)DMA_SxCR_EN;
    218            if ((DMA_StreamI2C_Rx->CR & (uint32_t)DMA_SxCR_EN) !=0) DMA_StreamI2C_Rx->CR &= ~(uint32_t)DMA_SxCR_EN;
    219            
    220            check_errors_i2c();
    221            
    222            type_error_of_exchanging_via_i2c |= (1<<ERROR_FIX_ERRORS_BIT);
    223            driver_i2c.state_execution = 2;
    224            
    225          #ifdef SYSTEM_VIEWER_ENABLE
    226            SEGGER_SYSVIEW_RecordExitISR();
    227          #endif
    228          }
    229          /*****************************************************/
    230          
    231          
    232          /*****************************************************/
    233          //Перереривання від завершення передачі DMA_StreamI2C_Tx
    234          /*****************************************************/
    235          void DMA_StreamI2C_Tx_IRQHandler(void)
    236          {
    237          #ifdef SYSTEM_VIEWER_ENABLE
    238            SEGGER_SYSVIEW_RecordEnterISR();
    239          #endif
    240          
    241            //Забороняємо генерацію переривань від потоку DMA_StreamI2C_Tx
    242            DMA_StreamI2C_Tx->CR &= ~DMA_IT_TC;
    243            
    244            //Зупиняємо потік DMA
    245            DMA_StreamI2C_Tx->CR &= ~(uint32_t)DMA_SxCR_EN;
    246            DMA_StreamI2C_Tx->NDTR = 0;
    247            
    248            /* Забороняємо для I2C передачу по DMA */
    249            I2C->CR2 &= (uint16_t)(~I2C_CR2_DMAEN);
    250          
    251            /* Очищаємо прапореці, що сигналізує про завершення передачі даних для DMA1 по потоку I2C_TX */
    252            DMA_ClearFlag(DMA_StreamI2C_Tx, DMA_FLAG_TCI2C_Tx | DMA_FLAG_HTI2C_Tx | DMA_FLAG_TEII2C_Tx | DMA_FLAG_DMEII2C_Tx | DMA_FLAG_FEII2C_Tx);
    253            
    254            //Чекаємо, поки останній байт успішно переасться
    255            while (I2C_GetFlagStatus(I2C, I2C_FLAG_BTF) == RESET);
    256          
    257            if (driver_i2c.action == 0)
    258            {
    259              //Переходимо в режим зчитування
    260              driver_i2c.action = 1;
    261              /* Посилаємо RESTART умову */
    262              I2C->CR1 |= I2C_CR1_START;
    263              /* Дозволяємо для I2C генерацію переривань по подіях */
    264              I2C->CR2 |= I2C_IT_EVT;
    265            }
    266            else if (driver_i2c.action == 2)
    267            {
    268              /* Посилаємо STOP умову */
    269              I2C->CR1 |= I2C_CR1_STOP;
    270              //Повідомляємо, що запис завершився
    271              driver_i2c.state_execution = 1;
    272            }
    273            
    274          #ifdef SYSTEM_VIEWER_ENABLE
    275            SEGGER_SYSVIEW_RecordExitISR();
    276          #endif
    277          }
    278          /*****************************************************/
    279          
    280          /*****************************************************/
    281          //Перереривання від завершення передачі DMA_StreamI2C_Rx
    282          /*****************************************************/
    283          void DMA_StreamI2C_Rx_IRQHandler(void)
    284          {
    285          #ifdef SYSTEM_VIEWER_ENABLE
    286            SEGGER_SYSVIEW_RecordEnterISR();
    287          #endif
    288          
    289            //Забороняємо генерацію переривань від потоку DMA_StreamI2C_Rx
    290            DMA_StreamI2C_Rx->CR &= ~DMA_IT_TC;
    291            
    292            //Зупиняємо потік DMA
    293            DMA_StreamI2C_Rx->CR &= ~(uint32_t)DMA_SxCR_EN;
    294            DMA_StreamI2C_Rx->NDTR = 0;
    295            
    296            /* Забороняємо для I2C передачу по DMA */
    297            I2C->CR2 &= (uint16_t)(~I2C_CR2_DMAEN);
    298          
    299            /* Очищаємо прапореці, що сигналізує про завершення передачі даних для DMA1 по каналу I2C_TX */
    300            DMA_ClearFlag(DMA_StreamI2C_Rx, DMA_FLAG_TCI2C_Rx | DMA_FLAG_HTI2C_Rx | DMA_FLAG_TEII2C_Rx | DMA_FLAG_DMEII2C_Rx | DMA_FLAG_FEII2C_Rx);
    301            
    302            /* Посилаємо STOP умову */
    303            I2C->CR1 |= I2C_CR1_STOP;
    304            //Повідомляємо, що читання завершився
    305            driver_i2c.state_execution = 1;
    306            
    307          #ifdef SYSTEM_VIEWER_ENABLE
    308            SEGGER_SYSVIEW_RecordExitISR();
    309          #endif
    310          }
    311          /*****************************************************/
    312          
    313          /*****************************************************/
    314          //Переривання від таймеру TIM5, який обслуговує вимірювальну систему
    315          /*****************************************************/
    316          void TIM5_IRQHandler(void)
    317          {
    318          #ifdef SYSTEM_VIEWER_ENABLE
    319            SEGGER_SYSVIEW_RecordEnterISR();
    320          #endif
    321            
    322            if (TIM_GetITStatus(TIM5, TIM_IT_CC1) != RESET)
    323            {
    324              /***********************************************************************************************/
    325              //Переривання відбулося вік каналу 1, який генерує переривання для початку зчитування даних з АЦП
    326              /***********************************************************************************************/
    327              TIM5->SR = (uint16_t)((~(uint32_t)TIM_IT_CC1) & 0xffff); //TIM5->SR скидується для виходу з переривання
    328              uint32_t current_tick = previous_tick_VAL = TIM5->CCR1;
    329              
    330              /*
    331              Виставляємо повідослення пор необхідність оцифрувати канали групи 1 
    332              для розрахунку ортогональних складових
    333              */
    334              adc_DATA_VAL_read = true;
    335              /*
    336              Виставляємо повідослення про необхідність оцифрувати каналів тестових значень
    337              */
    338              adc_TEST_VAL_read = true;
    339              
    340              /***********************************************************/
    341              //Встановлюємо "значення лічильника для наступного переривання"
    342              /***********************************************************/
    343              uint32_t capture_new;
    344              unsigned int delta;
    345              TIM5->CCR1 = (capture_new = (current_tick + (delta = TIM5_CCR1_VAL)));
    346              
    347              unsigned int repeat;
    348              unsigned int previous_tick;
    349              do
    350              {
    351                repeat = 0;
    352                current_tick = TIM5->CNT;
    353          
    354                uint32_t delta_time = 0;
    355                if (capture_new < current_tick)
    356                { 
    357                  uint64_t delta_time_64 = capture_new + 0x100000000 - current_tick;
    358                  delta_time = delta_time_64;
    359                }
    360                else delta_time = capture_new - current_tick;
    361          
    362                if ((delta_time > delta) || (delta_time == 0))
    363                {
    364                  if (TIM_GetITStatus(TIM5, TIM_IT_CC1) == RESET)
    365                  {
    366                    if (delta < TIM5_CCR1_VAL)
    367                    {
    368                      uint32_t delta_tick;
    369                      if (current_tick < previous_tick)
    370                      {
    371                        uint64_t delta_tick_64 = current_tick + 0x100000000 - previous_tick;
    372                        delta_tick = delta_tick_64;
    373                      }
    374                      else delta_tick = current_tick - previous_tick;
    375                        
    376                      delta = delta_tick + 1;
    377                    }
    378                    else if (delta == TIM5_CCR1_VAL)
    379                      delta = 1; /*Намагаємося, щоб нове переивання запустилося як омога скоріше*/
    380                    else
    381                    {
    382                      //Теоретично цього ніколи не мало б бути
    383                      total_error_sw_fixed(75);
    384                    }
    385                    TIM5->CCR1 = (capture_new = (TIM5->CNT +  delta));
    386                    previous_tick = current_tick;
    387                    repeat = 0xff;
    388                  }
    389                }
    390              }
    391              while (repeat != 0);
    392              /***********************************************************/
    393          
    394              /***********************************************************/
    395              //Виставляємо повідомлення про те, що почато оцифровку групи віимірювань 1 для перетворення Фур'є
    396              /***********************************************************/
    397              control_word_of_watchdog |= WATCHDOG_MEASURE_START_ALL_VAL;
    398              /***********************************************************/
    399              /***********************************************************************************************/
    400            }
    401            
    402            //Подальші дії виконуємо тільки тоді, коли зараз не іде обмін
    403            if (
    404                ((GPIO_SPI_ADC->ODR & GPIO_NSSPin_ADC) != 0) &&
    405                (semaphore_adc_irq == false)  
    406               )   
    407            {
    408              /*
    409              Це є умовою на цьому місці (переривання від таймеру має вищий пріоритет
    410              ніж перериванні від SPI) не ведеться зчитування значень з АЦП або їх обробка
    411              */
    412              control_reading_ADCs();
    413            }
    414            
    415          #ifdef SYSTEM_VIEWER_ENABLE
    416            SEGGER_SYSVIEW_RecordExitISR();
    417          #endif
    418          }
    419          /*****************************************************/
    420          
    421          /*****************************************************/
    422          //Переривання від таймеру TIM4, який обслуговує інтерфейси, клавіатуру і DataFlash
    423          /*****************************************************/
    424          void TIM4_IRQHandler(void)
    425          {
    426          #ifdef SYSTEM_VIEWER_ENABLE
    427            SEGGER_SYSVIEW_RecordEnterISR();
    428          #endif
    429            
    430            if (TIM_GetITStatus(TIM4, TIM_IT_CC3) != RESET)
    431            {
    432              /***********************************************************************************************/
    433              //Переривання відбулося вік каналу 3, який генерує переривання з періодом, який визначений настройками, для очікування наступного символа по RS-485
    434              /***********************************************************************************************/
    435              TIM4->SR = (uint16_t)((~(uint32_t)TIM_IT_CC3) & 0xffff);
    436              uint16_t current_tick = TIM4->CNT;
    437          
    438              //Знімаємо мітку, що на останньому перериванні відбулася фіксація прийняття цілого фрейму
    439              mark_current_tick_RS_485 = 0;
    440          
    441              /******/
    442              //Перевіряємо інтерфейс RS-485 тільки коли запущений DMA для прийому, бо інакше стоїть умова аналізу прийнятого пакету
    443              /******/
    444              if ((DMA_StreamRS485_Rx->CR & (uint32_t)DMA_SxCR_EN) !=0)
    445              {
    446                RxBuffer_RS485_count = BUFFER_RS485 - (uint16_t)(DMA_StreamRS485_Rx->NDTR);
    447                current_tick = TIM4->CNT; /*фіксуємо час, коли ми зафіксували кількість прийнятих байт відносно якого будемо визначати новий час генерації переривання*/
    448              
    449                if( RxBuffer_RS485_count != 0 )
    450                {
    451                  if (RxBuffer_RS485_count_previous == RxBuffer_RS485_count)
    452                  {
    453                    //Прийнятий цілий фрейм
    454          
    455                    //Зупиняємо потік DMA
    456                    if ((DMA_StreamRS485_Rx->CR & (uint32_t)DMA_SxCR_EN) !=0) DMA_StreamRS485_Rx->CR &= ~(uint32_t)DMA_SxCR_EN;
    457          
    458                    //Зчитуємо можливі помилки і перевіряємо, чи вони присутні
    459                    unsigned int error_status = USART_RS485->SR &  (USART_FLAG_ORE | USART_FLAG_NE | USART_FLAG_FE | USART_FLAG_PE);
    460                    if (error_status == 0)
    461                    {
    462                      //Помилок немає
    463                      
    464                      //Перевіряємо адресу
    465                      unsigned int global_requect;
    466                      if(
    467                         ((global_requect = (RxBuffer_RS485[0] == BROADCAST_ADDRESS_MODBUS_RTU)) != 0) ||
    468                         (RxBuffer_RS485[0] == settings_fix.address)
    469                        )   
    470                      {
    471                        //Інакше прийнятий пакет буде стояти в очікуванні на подальшу обробку - якщо не виконувати більше тут ніяких дій (не перезапускати моніторинг)
    472          
    473                        if (global_requect == 0) time_last_receive_byte = TIM4->CNT;
    474          
    475                        //Встановлюємо мітку, що на останньому перериванні відбулася фіксація прийняття цілого фрейму
    476                        mark_current_tick_RS_485 = 0xff;
    477                      }
    478                      else
    479                      {
    480                        //Адреса не співпадає - відновити моніторинг лінії
    481                        restart_monitoring_RS485();
    482                      }
    483                    }
    484                    else
    485                    {
    486                      //Зафіксовані помилки  - відновити моніторинг лінії
    487                      restart_monitoring_RS485();
    488                    }
    489                  }
    490                  else
    491                  {
    492                    //Фрейм на стадії прийому
    493                    RxBuffer_RS485_count_previous = RxBuffer_RS485_count;
    494                  }
    495                }
    496              }
    497              /******/
    498          
    499              /***********************************************************/
    500              //Встановлюємо "значення лічильника для наступного переривання"
    501              /***********************************************************/
    502              if (number_bits_rs_485_waiting < 10) calculate_namber_bit_waiting_for_rs_485();
    503              uint16_t /*current_tick = TIM4->CNT,*/ capture_new;
    504              unsigned int delta, step_tmp;
    505              TIM4->CCR3 = (capture_new = (current_tick + (delta = step_tmp =(TIM4_CCR3_VAL*number_bits_rs_485_waiting))));
    506              
    507              unsigned int repeat;
    508              unsigned int previous_tick;
    509              do
    510              {
    511                repeat = 0;
    512                current_tick = TIM4->CNT;
    513          
    514                uint32_t delta_time = 0;
    515                if (capture_new < current_tick)
    516                  delta_time = capture_new + 0x10000 - current_tick;
    517                else delta_time = capture_new - current_tick;
    518          
    519                if ((delta_time > delta) || (delta_time == 0))
    520                {
    521                  if (TIM_GetITStatus(TIM4, TIM_IT_CC3) == RESET)
    522                  {
    523                    if (delta < step_tmp)
    524                    {
    525                      uint32_t delta_tick;
    526                      if (current_tick < previous_tick)
    527                        delta_tick = current_tick + 0x10000 - previous_tick;
    528                      else delta_tick = current_tick - previous_tick;
    529                        
    530                      delta = delta_tick + 1;
    531                    }
    532                    else if (delta == step_tmp)
    533                      delta = 1; /*Намагаємося, щоб нове переривання запустилося як омога скоріше*/
    534                    else
    535                    {
    536                      //Теоретично цього ніколи не мало б бути
    537                      total_error_sw_fixed(78);
    538                    }
    539                    TIM4->CCR3 = (capture_new = (TIM4->CNT +  delta));
    540                    previous_tick = current_tick;
    541                    repeat = 0xff;
    542                  }
    543                }
    544              }
    545              while (repeat != 0);
    546              /***********************************************************/
    547          
    548              /***********************************************************/
    549              //Виставляємо повідомлення про те, що канал 3 TIM4 працює, що відповідає за періодичні функції фнтерфейсу RS-485
    550              /***********************************************************/
    551              control_word_of_watchdog |= WATCHDOG_RS485;
    552              /***********************************************************/
    553          
    554              /***********************************************************************************************/
    555            }
    556            else if (TIM_GetITStatus(TIM4, TIM_IT_CC1) != RESET)
    557            {
    558              /***********************************************************************************************/
    559              //Переривання відбулося вік каналу 1, який генерує переривання кожні 10 мс, для опрацьовування клавіатури
    560              /***********************************************************************************************/
    561              TIM4->SR = (uint16_t)((~(uint32_t)TIM_IT_CC1) & 0xffff);
    562              uint16_t current_tick = TIM4->CCR1;
    563            
    564              /***********************************************************/
    565              //Опрцювання пінів клавіатури
    566              /***********************************************************/
    567              /***************************/
    568              //Перебираємо всі рядки
    569              /***************************/
    570              //Рядок - 1
    571              GPIO_ResetBits(KEYBOARD, KEYBOARD_SW_1_PIN);
    572              check_state_key(KEYBOARD_SW_A, KEYBOARD_SW_A_PIN, BIT_KEY_ENTER);
    573              check_state_key(KEYBOARD_SW_B, KEYBOARD_SW_B_PIN, BIT_KEY_DOWN);
    574              check_state_key(KEYBOARD_SW_C, KEYBOARD_SW_C_PIN, BIT_KEY_RIGHT);
    575              GPIO_SetBits(KEYBOARD, KEYBOARD_SW_1_PIN);
    576              
    577              //Робимо невелику затримку
    578              for(unsigned int delay_local = 0; delay_local < 100; delay_local++) __no_operation();
    579              
    580              //Рядок - 2
    581              GPIO_ResetBits(KEYBOARD, KEYBOARD_SW_2_PIN);
    582              check_state_key(KEYBOARD_SW_A, KEYBOARD_SW_A_PIN, BIT_KEY_ESC);
    583              check_state_key(KEYBOARD_SW_B, KEYBOARD_SW_B_PIN, BIT_KEY_LEFT);
    584              check_state_key(KEYBOARD_SW_C, KEYBOARD_SW_C_PIN, BIT_KEY_UP);
    585              GPIO_SetBits(KEYBOARD, KEYBOARD_SW_2_PIN);
    586          
    587              //Робимо невелику затримку
    588              for(unsigned int delay_local = 0; delay_local < 100; delay_local++) __no_operation();
    589          
    590              //Рядок - 3
    591              GPIO_ResetBits(KEYBOARD, KEYBOARD_SW_3_PIN);
    592              check_state_key(KEYBOARD_SW_A, KEYBOARD_SW_A_PIN, BIT_KEY_1);
    593              check_state_key(KEYBOARD_SW_B, KEYBOARD_SW_B_PIN, BIT_KEY_2);
    594              check_state_key(KEYBOARD_SW_C, KEYBOARD_SW_C_PIN, BIT_KEY_3);
    595              GPIO_SetBits(KEYBOARD, KEYBOARD_SW_3_PIN);
    596          
    597              //Робимо невелику затримку
    598              for(unsigned int delay_local = 0; delay_local < 100; delay_local++) __no_operation();
    599          
    600              //Рядок - 4
    601              GPIO_ResetBits(KEYBOARD, KEYBOARD_SW_4_PIN);
    602              check_state_key(KEYBOARD_SW_A, KEYBOARD_SW_A_PIN, BIT_KEY_4);
    603              check_state_key(KEYBOARD_SW_B, KEYBOARD_SW_B_PIN, BIT_KEY_5);
    604              check_state_key(KEYBOARD_SW_C, KEYBOARD_SW_C_PIN, BIT_KEY_6);
    605              GPIO_SetBits(KEYBOARD, KEYBOARD_SW_4_PIN);
    606              /***************************/
    607            
    608              /***************************/
    609              //Обробка алгоритму функціональних кнопок
    610              /***************************/
    611              pressed_buttons    |= (new_state_keyboard & ((1<<BIT_KEY_1)|(1<<BIT_KEY_2)|(1<<BIT_KEY_3)|(1<<BIT_KEY_4)|(1<<BIT_KEY_5)|(1<<BIT_KEY_6))) >> BIT_KEY_1;
    612              new_state_keyboard &= (unsigned int)(~((1<<BIT_KEY_1)|(1<<BIT_KEY_2)|(1<<BIT_KEY_3)|(1<<BIT_KEY_4)|(1<<BIT_KEY_5)|(1<<BIT_KEY_6)));
    613              /***************************/
    614              /***********************************************************/
    615            
    616              /***********************************************************/
    617              //Перевіряємо чи треба обновляти з часом 1 с дані на екрані
    618              /***********************************************************/
    619              if (
    620                  ((current_state_menu2.current_level == TIME_MANU2_LEVEL) && (current_state_menu2.edition <= ED_CAN_BE_EDITED)) ||
    621                  (current_state_menu2.current_level == MEASUREMENT_MENU2_LEVEL      ) ||
    622                  (current_state_menu2.current_level == INPUTS_MENU2_LEVEL)   ||
    623                  (current_state_menu2.current_level == OUTPUTS_MENU2_LEVEL)   ||
    624                  (current_state_menu2.current_level == DIAGNOSTICS_MENU2_LEVEL) 
    625                 )
    626              {
    627                if(++time_rewrite > MAX_TIME_REWRITE_EKRAN)
    628                {
    629                  time_rewrite = 0;
    630                  new_state_keyboard |= (1<<BIT_REWRITE);
    631                }
    632              }
    633              /***********************************************************/
    634          
    635              /***********************************************************/
    636              //Аналіз запуску, або розблоукування запуску періодичних задач
    637              /***********************************************************/
    638              if (_CHECK_SET_BIT(control_i2c_taskes, TASK_BLK_WRITING_EEPROM_BIT) != 0)
    639              {
    640                //Розблоковуємо запуск заблокованих задач для драйверу I2C
    641                 _CLEAR_BIT(control_i2c_taskes, TASK_BLK_WRITING_EEPROM_BIT);
    642                //Остаточне розблокування відбудеться після засинхронізацією з зняття миттєвих виборок з АЦП
    643                _SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);
    644              }
    645              /***********************************************************/
    646          
    647              /***********************************************************/
    648              //Лічильник ресурсу + періодичні операції раз у секунду
    649              /***********************************************************/
    650              static unsigned int number_ticks_for_OF_bit_reset;
    651          
    652              if (etap_reset_of_bit == ETAP_CLEAR_OF_ST_START_WAITING_5S)
    653              {
    654                etap_reset_of_bit = ETAP_CLEAR_OF_ST_WAITING_5S;
    655                number_ticks_for_OF_bit_reset = 0;
    656              }
    657              else if (etap_reset_of_bit == ETAP_CLEAR_OF_ST_WAITING_5S)
    658              {
    659                number_ticks_for_OF_bit_reset++;
    660                if (number_ticks_for_OF_bit_reset > 500) etap_reset_of_bit = ETAP_CLEAR_OF_WRITE_OF_0;
    661              }
    662              
    663              if(++number_inputs_for_fix_one_second >= 100)
    664              {
    665                
    666                //Запуск читання часу з RTC тільки піся успішного зчитування настройок
    667                //При цьому виставляємо біт блокування негайного запуску операції, щоб засинхронізуватися з роботою вимірювальної системи
    668                if ((state_i2c_task & STATE_SETTINGS_EEPROM_GOOD) != 0) 
    669                {
    670                  _SET_BIT(control_i2c_taskes, TASK_START_READ_RTC_BIT);
    671                  _SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);
    672                }
    673                
    674                //Запусаємо раз у секунду самоконтроль важливих змінних
    675                periodical_tasks_TEST_CONFIG                  = 
    676                periodical_tasks_TEST_SETTINGS                = 
    677                periodical_tasks_TEST_USTUVANNJA              = 
    678                /*periodical_tasks_TEST_TRG_FUNC                = */
    679                periodical_tasks_TEST_INFO_REJESTRATOR_PR_ERR = 
    680                periodical_tasks_TEST_FLASH_MEMORY            = true;
    681                
    682                number_inputs_for_fix_one_second = 0;
    683                
    684                //Робота з таймером очікування нових змін налаштувань
    685                if (
    686                    (restart_timeout_idle_new_settings != 0) ||
    687                    (_CHECK_SET_BIT(fix_block_active_state, FIX_BLOCK_SETTINGS_CHANGED) == 0) ||
    688                    ((config_settings_modified & MASKA_MENU_LOCKS) != 0) 
    689                   )
    690                {
    691                  timeout_idle_new_settings  = 0;
    692                  if (restart_timeout_idle_new_settings != 0) restart_timeout_idle_new_settings = false;
    693                }
    694                else 
    695                { 
    696                  if (timeout_idle_new_settings < (settings_fix.timeout_idle_new_settings)) timeout_idle_new_settings++;
    697                }
    698          
    699                //Робота з таймерами простою USB
    700                if ((restart_timeout_interface & (1 << USB_RECUEST  )) != 0) 
    701                {
    702                  timeout_idle_USB  = 0;
    703                  restart_timeout_interface &= (unsigned int)(~(1 << USB_RECUEST));
    704                }
    705                else 
    706                {
    707                  if (timeout_idle_USB < (settings_fix.timeout_deactivation_password_interface_USB)) timeout_idle_USB++;
    708                }
    709          
    710                //Робота з таймерами простою RS-485
    711                if ((restart_timeout_interface & (1 << RS485_RECUEST)) != 0) 
    712                {
    713                  timeout_idle_RS485 = 0;
    714                  restart_timeout_interface &= (unsigned int)(~(1 << RS485_RECUEST));
    715                }
    716                else 
    717                {
    718                  if (timeout_idle_RS485 < (settings_fix.timeout_deactivation_password_interface_RS485)) timeout_idle_RS485++;
    719                }
    720          
    721                //Ресурс
    722                if (restart_resurs_count == 0)
    723                {
    724                  resurs_global = resurs_temp;
    725                  resurs_temp = 0;
    726                  if (resurs_global < resurs_global_min) resurs_global_min = resurs_global;
    727                  if (resurs_global > resurs_global_max) resurs_global_max = resurs_global;
    728                }
    729                else
    730                {
    731                  restart_resurs_count = 0;
    732                  
    733                  resurs_global = 0;
    734                  resurs_temp = 0;
    735                  resurs_global_min = 0xffffffff;
    736                  resurs_global_max = 0;
    737                }
    738              }
    739              /***********************************************************/
    740          
    741              /***********************************************************/
    742              //Встановлюємо "значення лічильника для наступного переривання"
    743              /***********************************************************/
    744              uint16_t capture_new;
    745              unsigned int delta;
    746              TIM4->CCR1 = (capture_new = (current_tick + (delta = TIM4_CCR1_VAL)));
    747              
    748              unsigned int repeat;
    749              unsigned int previous_tick;
    750              do
    751              {
    752                repeat = 0;
    753                current_tick = TIM4->CNT;
    754          
    755                uint32_t delta_time = 0;
    756                if (capture_new < current_tick)
    757                  delta_time = capture_new + 0x10000 - current_tick;
    758                else delta_time = capture_new - current_tick;
    759          
    760                if ((delta_time > delta) || (delta_time == 0))
    761                {
    762                  if (TIM_GetITStatus(TIM4, TIM_IT_CC1) == RESET)
    763                  {
    764                    if (delta < TIM4_CCR1_VAL)
    765                    {
    766                      uint32_t delta_tick;
    767                      if (current_tick < previous_tick)
    768                        delta_tick = current_tick + 0x10000 - previous_tick;
    769                      else delta_tick = current_tick - previous_tick;
    770                        
    771                      delta = delta_tick + 1;
    772                    }
    773                    else if (delta == TIM4_CCR1_VAL)
    774                      delta = 1; /*Намагаємося, щоб нове переивання запустилося як омога скоріше*/
    775                    else
    776                    {
    777                      //Теоретично цього ніколи не мало б бути
    778                      total_error_sw_fixed(79);
    779                    }
    780                    TIM4->CCR1 = (capture_new = (TIM4->CNT +  delta));
    781                    previous_tick = current_tick;
    782                    repeat = 0xff;
    783                  }
    784                }
    785              }
    786              while (repeat != 0);
    787              /***********************************************************/
    788          
    789              /***********************************************************/
    790              //Виставляємо повідомлення про те, що канал 1 TIM4, що відповідає за періодичні функції клавіатури працює
    791              /***********************************************************/
    792              control_word_of_watchdog |= WATCHDOG_KYYBOARD;
    793              /***********************************************************/
    794              /***********************************************************************************************/
    795            }
    796            else if (TIM_GetITStatus(TIM4, TIM_IT_CC2) != RESET)
    797            {
    798              /***********************************************************************************************/
    799              //Переривання відбулося вік каналу 2, який генерує переривання кожні 1 мс, для опраціьовування управління мікросхемами DataFlash і формування нових записів реєстратора програмних подій
    800              /***********************************************************************************************/
    801              TIM4->SR = (uint16_t)((~(uint32_t)TIM_IT_CC2) & 0xffff);
    802              uint16_t current_tick = TIM4->CCR2;
    803              
    804              /***********************************************************/
    805              //Перевіряємо необхідність очистки реєстратора програмних подій
    806              /***********************************************************/
    807              if (
    808                  ((clean_rejestrators & CLEAN_PR_ERR) != 0)
    809                  &&  
    810                  (
    811                   (control_tasks_dataflash & (
    812                                               TASK_WRITE_PR_ERR_RECORDS_INTO_DATAFLASH    |
    813                                               TASK_MAMORY_READ_DATAFLASH_FOR_PR_ERR_USB   |
    814                                               TASK_MAMORY_READ_DATAFLASH_FOR_PR_ERR_RS485 |
    815                                               TASK_MAMORY_READ_DATAFLASH_FOR_PR_ERR_MENU
    816                                              )
    817                   ) == 0
    818                  )
    819                 )   
    820              {
    821                //Виставлено каманда очистити реєстратор програмних подій
    822          
    823                //Виставляємо команду запису цієї структури у EEPROM
    824                _SET_BIT(control_i2c_taskes, TASK_START_WRITE_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT);
    825          
    826                //Очищаємо структуру інформації по реєстраторі програмних помилок
    827                info_rejestrator_pr_err.next_address = MIN_ADDRESS_PR_ERR_AREA;
    828                info_rejestrator_pr_err.saving_execution = 0;
    829                info_rejestrator_pr_err.number_records = 0;
    830          
    831                //Помічаємо, що номер запису не вибраний
    832                number_record_of_pr_err_into_menu  = 0xffff;
    833                number_record_of_pr_err_into_USB   = 0xffff;
    834                number_record_of_pr_err_into_RS485 = 0xffff;
    835          
    836                //Знімаємо команду очистки реєстратора програмних подій
    837                clean_rejestrators &= (unsigned int)(~CLEAN_PR_ERR);
    838              }
    839              /***********************************************************/
    840              
    841              /***********************************************************/
    842              //Періодично запускаємо звертання то мікросхем DataFlash
    843              /***********************************************************/
    844              if (((DMA_StreamSPI_DF_Tx->CR & (uint32_t)DMA_SxCR_EN) == 0) && ((DMA_StreamSPI_DF_Rx->CR & (uint32_t)DMA_SxCR_EN) == 0))
    845              {
    846                if ((number_chip_dataflsh_exchange >= INDEX_DATAFLASH_1) && (number_chip_dataflsh_exchange <= INDEX_DATAFLASH_2))
    847                {
    848                  if (error_into_spi_df == 0)
    849                  {
    850                    //Не було зафіксовано, що при поперпдній операції виникла помилка
    851                  
    852                    //Перевіряємо, чи є потреба і можливість записувати реєстратор програмних подій
    853                    if (
    854          
    855                        /***
    856                        Перший раз вже зчитаний час з моменту перезапуску
    857                        ***/
    858                        (_CHECK_SET_BIT(    diagnostyka, EVENT_START_SYSTEM_BIT  ) == 0) &&
    859                        (_CHECK_SET_BIT(set_diagnostyka, EVENT_START_SYSTEM_BIT  ) == 0) &&
    860                        (_CHECK_SET_BIT(    diagnostyka, EVENT_RESTART_SYSTEM_BIT) == 0) &&
    861                        (_CHECK_SET_BIT(set_diagnostyka, EVENT_RESTART_SYSTEM_BIT) == 0) &&
    862                        /***/
    863                        ((POWER_CTRL->IDR & POWER_CTRL_PIN) != (uint32_t)Bit_RESET) && /*На даний момент на вході блоку живлення подається живлення*/ 
    864                        /***/
    865                        (temporary_block_writing_records_pr_err_into_DataFlash     == 0) && /*Блокування запису підготовлених записів реєстратора програмних подій у мікросхему DataFlash1*/
    866                        ((control_tasks_dataflash  & 0xffff)                       == 0)    /*Починаємо запис у реєстратор програмних подій тільки тоді, коли інших задач у черзі немає для запису у DataFlash1*/
    867                       )
    868                    {
    869                      unsigned int head = head_fifo_buffer_pr_err_records, tail = tail_fifo_buffer_pr_err_records;
    870                      if (head != tail) control_tasks_dataflash |= TASK_WRITE_PR_ERR_RECORDS_INTO_DATAFLASH;  //Є нові записи у буфері подій  
    871                    }
    872                  
    873                    //Аналізуємо прийняті дані, якщо такі є і чекають на аналіз
    874                    main_function_for_dataflash_resp(number_chip_dataflsh_exchange);
    875          
    876                    //Змінюємо номер DataFlash з яким буде іти зараз робота
    877                    if (driver_spi_df[number_chip_dataflsh_exchange].state_execution == TRANSACTION_EXECUTING_NONE)
    878                    {
    879                      //Змінюємо номер мікросхеми, до якої ми будемо звертатися при натупних трансакціях, якщо зараз не запущена ніяка трансакція
    880                      number_chip_dataflsh_exchange = (number_chip_dataflsh_exchange + 1) & (NUMBER_DATAFLASH_CHIP - 1);
    881                    }
    882          
    883                    //Робимо запит на нову мікросхему DataFlash, якщо э такий
    884                    main_function_for_dataflash_req(number_chip_dataflsh_exchange);
    885                  }
    886                  else
    887                  {
    888                    //Було зафіксовано, що при поперпдній операції виникла помилка
    889                    if (driver_spi_df[number_chip_dataflsh_exchange].state_execution == TRANSACTION_EXECUTED_WAIT_ANALIZE)
    890                    {
    891                      //Очікується аналіз прийнятих даних з мікросхеми DataFlash у режимі виходу з "збою" обміну
    892                      if (driver_spi_df[number_chip_dataflsh_exchange].code_operation == CODE_OPERATION_STATUS_READ)
    893                      {
    894                        /*
    895                        У режимі відновлення обміну з мікросхемою DataFlash після "збою" в обміні
    896                        можлива ситуація, що ми аналізуємо відповідь на читання пегістру статусу - 
    897                        у всіх інших випадках - це є недопустимий випадок, який свідчить, що порграма
    898                        виконується незаплпнованим шляхом - тому перезапуск
    899                        */
    900                         
    901                        if ((RxBuffer_SPI_DF[1] & (1<< 7)) != 0) dataflash_not_busy |= (1 << number_chip_dataflsh_exchange);
    902                        else dataflash_not_busy &= (unsigned int)(~(1 << number_chip_dataflsh_exchange));
    903                  
    904                        driver_spi_df[number_chip_dataflsh_exchange].state_execution = TRANSACTION_EXECUTING_NONE;
    905                        driver_spi_df[number_chip_dataflsh_exchange].code_operation = CODE_OPERATION_NONE;
    906                      }
    907                      else
    908                      {
    909                        total_error_sw_fixed(39);
    910                      }
    911                    }
    912          
    913                    /*
    914                    Оскільки номер мікросхеми, з якою здійснюємо обмін, під час виходу з ситуації,
    915                    коли виник збій, не змінюємо, то можна спробувати запустити зразу після
    916                    аналізу принятого пакету новий запит
    917                    */
    918                    if (driver_spi_df[number_chip_dataflsh_exchange].state_execution == TRANSACTION_EXECUTING_NONE)
    919                    {
    920                      //Очікується початок нового обміну з мікросхемою DataFlash
    921                      if((dataflash_not_busy & (1 << number_chip_dataflsh_exchange)) == 0)
    922                      {
    923                        //Читаємо регітр статусу мікросхеми
    924                        dataflash_status_read(number_chip_dataflsh_exchange);
    925                      }
    926                      else
    927                      {
    928                        //Мікросхема готова до повторного виконання операції, під час якої виникла помилкова ситуація на SPI_DF
    929          
    930                        //Відновлюємо буфер передавання, який був під час помилки
    931                        if ((number_bytes_transfer_spi_df_copy != 0) && (number_bytes_transfer_spi_df_copy < sizeof(TxBuffer_SPI_DF)))
    932                        {
    933                          number_bytes_transfer_spi_df = number_bytes_transfer_spi_df_copy;
    934                          for(unsigned int i = 0; i < number_bytes_transfer_spi_df; i++)
    935                            TxBuffer_SPI_DF[i] = TxBuffer_SPI_DF_copy[i];
    936          
    937                          /*
    938                          Знімаємо помітку, що зафіксовано помилку при обміні, бо ми будемо 
    939                          виконувати ту операція, яка виконувалася до моменту фіксації помилки
    940                          */
    941                          error_into_spi_df = 0;
    942          
    943                          //Відновлюємо операцію, яка виконувался
    944                          driver_spi_df[number_chip_dataflsh_exchange].code_operation = code_operation_copy;
    945          
    946                          //Запускаємо повторно дану операцію
    947                          start_exchange_via_spi(number_chip_dataflsh_exchange, number_bytes_transfer_spi_df);
    948                        }
    949                        else
    950                        {
    951                          //Відбулася невизначена помилка, тому треба піти на перезавантаження
    952                          total_error_sw_fixed(40);
    953                        }
    954                      }
    955                          
    956                    }
    957                  }
    958                }
    959                else
    960                {
    961                  //Відбулася невизначена помилка, тому треба піти на перезавантаження
    962                  total_error_sw_fixed(38);
    963                }
    964              }
    965              /***********************************************************/
    966              
    967              /***********************************************************/
    968              //Підготовлюємо новий запис для реєстратора програмних подій
    969              /***********************************************************/
    970              changing_diagnostyka_state();
    971              /***********************************************************/
    972              
    973              /***********************************************************/
    974              //Перевірка на необхідність зроботи резервну копію даних для самоконтролю
    975              /***********************************************************/
    976              //Реєстратор програмних подій
    977              if (periodical_tasks_TEST_INFO_REJESTRATOR_PR_ERR != 0)
    978              {
    979                //Стоїть у черзі активна задача зроботи резервні копії даних
    980                if ((state_i2c_task & STATE_INFO_REJESTRATOR_PR_ERR_EEPROM_GOOD) != 0)
    981                {
    982                  //Робимо копію тільки тоді, коли структура інформації реєстратора успішно зчитана і сформована контрольна сума
    983                  if (
    984                      (_CHECK_SET_BIT(control_i2c_taskes, TASK_START_WRITE_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT) == 0) &&
    985                      (_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT    ) == 0) &&
    986                      (_CHECK_SET_BIT(control_i2c_taskes, TASK_START_READ_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT ) == 0) &&
    987                      (_CHECK_SET_BIT(control_i2c_taskes, TASK_READING_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT    ) == 0)
    988                     ) 
    989                  {
    990                    //На даний моммент не іде читання-запис структури інформації реєстратора, тому можна здійснити копіювання
    991                    info_rejestrator_pr_err_ctrl = info_rejestrator_pr_err;
    992                    crc_info_rejestrator_pr_err_ctrl = crc_info_rejestrator_pr_err;
    993          
    994                    //Скидаємо активну задачу формування резервної копії 
    995                    periodical_tasks_TEST_INFO_REJESTRATOR_PR_ERR = false;
    996                    //Виставляємо активну задачу контролю достовірності по резервній копії 
    997                    periodical_tasks_TEST_INFO_REJESTRATOR_PR_ERR_LOCK = true;
    998                  }
    999                }
   1000                else
   1001                {
   1002                  //Скидаємо активну задачу формування резервної копії 
   1003                  periodical_tasks_TEST_INFO_REJESTRATOR_PR_ERR = false;
   1004                }
   1005              }
   1006              /***********************************************************/
   1007          
   1008              /***********************************************************/
   1009              //Встановлюємо "значення лічильника для наступного переривання"
   1010              /***********************************************************/
   1011              uint16_t /*current_tick = TIM4->CNT,*/ capture_new;
   1012              unsigned int delta;
   1013              TIM4->CCR2 = (capture_new = (current_tick + (delta = TIM4_CCR2_VAL)));
   1014              
   1015              unsigned int repeat;
   1016              unsigned int previous_tick;
   1017              do
   1018              {
   1019                repeat = 0;
   1020                current_tick = TIM4->CNT;
   1021          
   1022                uint32_t delta_time = 0;
   1023                if (capture_new < current_tick)
   1024                  delta_time = capture_new + 0x10000 - current_tick;
   1025                else delta_time = capture_new - current_tick;
   1026          
   1027                if ((delta_time > delta) || (delta_time == 0))
   1028                {
   1029                  if (TIM_GetITStatus(TIM4, TIM_IT_CC2) == RESET)
   1030                  {
   1031                    if (delta < TIM4_CCR2_VAL)
   1032                    {
   1033                      uint32_t delta_tick;
   1034                      if (current_tick < previous_tick)
   1035                        delta_tick = current_tick + 0x10000 - previous_tick;
   1036                      else delta_tick = current_tick - previous_tick;
   1037                        
   1038                      delta = delta_tick + 1;
   1039                    }
   1040                    else if (delta == TIM4_CCR2_VAL)
   1041                      delta = 1; /*Намагаємося, щоб нове переивання запустилося як омога скоріше*/
   1042                    else
   1043                    {
   1044                      //Теоретично цього ніколи не мало б бути
   1045                      total_error_sw_fixed(80);
   1046                    }
   1047                    TIM4->CCR2 = (capture_new = (TIM4->CNT +  delta));
   1048                    previous_tick = current_tick;
   1049                    repeat = 0xff;
   1050                  }
   1051                }
   1052              }
   1053              while (repeat != 0);
   1054              
   1055              /*Vidladka*/
   1056          #ifdef DEBUG_TEST
   1057              static unsigned int t_1, t_2, delta_tmp;
   1058              t_1 = TIM4->CCR2;
   1059              t_2 = TIM4->CNT;
   1060              if (t_1 >= t_2) delta_tmp = t_1 - t_2;
   1061              else delta_tmp = t_1 + 0xffff - t_2;
   1062              
   1063              if (
   1064                  (delta_tmp > TIM4_CCR2_VAL) &&
   1065                  (TIM_GetITStatus(TIM4, TIM_IT_CC2) == RESET)  
   1066                 )   
   1067              {
   1068                while(delta_tmp > 0);
   1069              }
   1070          #endif
   1071              /***/
   1072              /***********************************************************/
   1073          
   1074              /***********************************************************/
   1075              //Виставляємо повідомлення про те, що канал 2 TIM4, що відповідає за періодичні функції для DataFlash працює
   1076              /***********************************************************/
   1077              control_word_of_watchdog |= WATCHDOG_DATAFLASH;
   1078              /***********************************************************/
   1079              /***********************************************************************************************/
   1080            }
   1081          
   1082          #ifdef SYSTEM_VIEWER_ENABLE
   1083            SEGGER_SYSVIEW_RecordExitISR();
   1084          #endif
   1085          }
   1086          /*****************************************************/
   1087          
   1088          /*****************************************************/
   1089          //Переривання від генеррації події про помилку для SPI_DF
   1090          /*****************************************************/
   1091          void SPI_DF_IRQHandler(void)
   1092          {
   1093          #ifdef SYSTEM_VIEWER_ENABLE
   1094            SEGGER_SYSVIEW_RecordEnterISR();
   1095          #endif
   1096          
   1097            /*
   1098            Відбулася помилкова ситуація - треба повторно виконати попередньо виконувану трансакцію
   1099            */
   1100            
   1101            /*
   1102            Запам'ятовуємо регістр статусу, який зчитаний зразу після генерації переривання - 
   1103            у ньому має бути зафіксована причина генерації переривання
   1104            Цю змінну будемо використовувати при аналізі помилки
   1105            */
   1106            uint16_t spi_df_status = SPI_DF->SR;
   1107            
   1108            /*Забороняємо генерацію переривань від потоку DMA_StreamSPI_DF_Rx*/
   1109            DMA_StreamSPI_DF_Rx->CR &= ~DMA_IT_TC;
   1110          
   1111            /*
   1112            Можливо зараз ще продовжується робота DMA контролера по прийом/передачі даних,
   1113            але осекільки зафіксовано помилку у процесі обміну, то зупиняємо їх
   1114            */
   1115            DMA_StreamSPI_DF_Tx->CR &= ~(uint32_t)DMA_SxCR_EN;
   1116            DMA_StreamSPI_DF_Tx->NDTR = 0;
   1117            DMA_StreamSPI_DF_Rx->CR &= ~(uint32_t)DMA_SxCR_EN;
   1118            DMA_StreamSPI_DF_Rx->NDTR = 0;
   1119          
   1120            /*Тимчасово забороняємо переривання від помилок на SPI_DF*/
   1121            SPI_I2S_ITConfig(SPI_DF, SPI_I2S_IT_ERR, DISABLE);
   1122          
   1123            /*
   1124            Очікуємо поки TXE=1 і BSY=0 - це ознака повногго завершення передачі даних,
   1125            а ознакою завершення прийому дані - це є генерація цього переривання
   1126            */
   1127            while ((SPI_DF->SR & SPI_I2S_FLAG_TXE) == 0);
   1128            while ((SPI_DF->SR & SPI_I2S_FLAG_BSY) != 0);
   1129          
   1130            /*Знімаємо Chip_select переводом NSS  у 1*/
   1131            GPIO_SPI_DF->BSRRL = GPIO_NSSPin_DF;
   1132          
   1133            if (
   1134                ((spi_df_status & SPI_I2S_FLAG_OVR) != 0) ||
   1135                ((SPI_DF->SR    & SPI_I2S_FLAG_OVR) != 0)
   1136               )
   1137            {
   1138              //Подія про переповнення приймача
   1139              
   1140              do
   1141              {
   1142                //Очищаємо цю подією такою комбінацією читань:
   1143                SPI_DF->DR;
   1144                SPI_DF->SR;
   1145              }
   1146              while((SPI_DF->SR & SPI_I2S_FLAG_OVR) != 0);
   1147            }
   1148          
   1149            if (
   1150                ((spi_df_status & SPI_FLAG_MODF) != 0) ||
   1151                ((SPI_DF->SR    & SPI_FLAG_MODF) != 0)  
   1152               )   
   1153            {
   1154              //Подія "Master mode fault" - теоретично нікли не малаб виникати
   1155          
   1156              do
   1157              {
   1158                //Очищаємо цю подією такою комбінацією:
   1159                SPI_DF->SR;
   1160          
   1161                //Забороняємо SPI_DF
   1162                SPI_Cmd(SPI_DF, DISABLE);
   1163                //Забороняємо SPI_DF DMA Tx запити
   1164                SPI_I2S_DMACmd(SPI_DF, SPI_I2S_DMAReq_Tx, DISABLE);
   1165                //Забороняємо SPI_DF DMA Rx запити
   1166                SPI_I2S_DMACmd(SPI_DF, SPI_I2S_DMAReq_Rx, DISABLE);
   1167              
   1168                //Примусово переводимо SPI_DF у Slave-режимі
   1169                SPI_InitTypeDef  SPI_InitStructure;
   1170                SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
   1171                SPI_InitStructure.SPI_Mode = SPI_Mode_Slave;
   1172                SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
   1173                SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
   1174                SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
   1175                SPI_InitStructure.SPI_NSS =  SPI_NSS_Soft;
   1176                SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_4/*SPI_BaudRatePrescaler_2*/;
   1177                SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
   1178                SPI_InitStructure.SPI_CRCPolynomial = 7;
   1179                SPI_Init(SPI_DF, &SPI_InitStructure);
   1180                //Дозволяємо SPI_DF - у Slave-режимі
   1181                SPI_Cmd(SPI_DF, ENABLE);
   1182          
   1183                //Знову забороняємо SPI_DF для перенастройки у Master-режим
   1184                SPI_Cmd(SPI_DF, DISABLE);
   1185              
   1186                //Повертаємо SPI_DF у Master-режим
   1187                SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
   1188                SPI_Init(SPI_DF, &SPI_InitStructure);
   1189          
   1190                //Забороняємо SPI_DF DMA Tx запити
   1191                SPI_I2S_DMACmd(SPI_DF, SPI_I2S_DMAReq_Tx, DISABLE);
   1192                //Забороняємо SPI_DF DMA Rx запити
   1193                SPI_I2S_DMACmd(SPI_DF, SPI_I2S_DMAReq_Rx, DISABLE);
   1194          
   1195                //Очищаємо прапореці, що сигналізує про завершення прийом/передачі даних для DMA по потоку DMA_StreamSPI_DF_Rx і DMA_StreamSPI_DF_Tx
   1196                DMA_ClearFlag(DMA_StreamSPI_DF_Rx, DMA_FLAG_TCSPI_DF_Rx | DMA_FLAG_HTSPI_DF_Rx | DMA_FLAG_TEISPI_DF_Rx | DMA_FLAG_DMEISPI_DF_Rx | DMA_FLAG_FEISPI_DF_Rx);
   1197                DMA_ClearFlag(DMA_StreamSPI_DF_Tx, DMA_FLAG_TCSPI_DF_Tx | DMA_FLAG_HTSPI_DF_Tx | DMA_FLAG_TEISPI_DF_Tx | DMA_FLAG_DMEISPI_DF_Tx | DMA_FLAG_FEISPI_DF_Tx);
   1198          
   1199                //Дозволяємо SPI_DF
   1200                SPI_Cmd(SPI_DF, ENABLE);
   1201              }
   1202              while ((SPI_DF->SR & SPI_FLAG_MODF) != 0);
   1203            }
   1204          
   1205            if (
   1206                ((spi_df_status & SPI_FLAG_CRCERR) != 0) ||
   1207                ((SPI_DF->SR    & SPI_FLAG_CRCERR) != 0)  
   1208               )   
   1209            {
   1210              //Подія "CRC error" - ніколи не мала б виникати у нашоій програмі
   1211          
   1212              //Відбулася невизначена помилка, тому треба піти на перезавантаження
   1213              total_error_sw_fixed(34);
   1214            }
   1215          
   1216            if ((number_chip_dataflsh_exchange >= INDEX_DATAFLASH_1) && (number_chip_dataflsh_exchange <= INDEX_DATAFLASH_2))
   1217            {
   1218              if(driver_spi_df[number_chip_dataflsh_exchange].state_execution != TRANSACTION_EXECUTING_NONE)
   1219              {
   1220                //Помилка виникла в процесі прийом/передачі
   1221                
   1222                //Фіксуємо операцію, яка виконувалася для подальшої обробки
   1223                unsigned int code_operation_copy_tmp = driver_spi_df[number_chip_dataflsh_exchange].code_operation;
   1224                
   1225                /*
   1226                Оскільки помилка зафіксована при прийомі, то, впринципі, передавання даних могло закінчитися успішно,
   1227                тому треба помітити, що треба зчитати статус готовності
   1228                */
   1229                dataflash_not_busy &= (unsigned int)(~(1 << number_chip_dataflsh_exchange));
   1230          
   1231                //Знімаємо сигналізацію, що виконується операція для даної мікросхеми
   1232                driver_spi_df[number_chip_dataflsh_exchange].state_execution = TRANSACTION_EXECUTING_NONE;
   1233                driver_spi_df[number_chip_dataflsh_exchange].code_operation = CODE_OPERATION_NONE;
   1234                
   1235                if (code_operation_copy_tmp != CODE_OPERATION_STATUS_READ) 
   1236                {
   1237                  /*
   1238                  Виключаємо подпальші дії, якщо попередня операція було читання регістру статусу,
   1239                  бо, оскільки ми зняли прапорець готовності даної мікросхеми, то ця операція всеодно
   1240                  викличеться першою, а далі підуть всі наступні операції
   1241                  */
   1242                  if (code_operation_copy_tmp == CODE_OPERATION_STATUS_READ)
   1243                  {
   1244                    /*Відбулася невизначена помилка (бо не може бути, щоб ішда якась операція, 
   1245                    але вона була поміена. що ніякої операції немає), тому треба піти на перезавантаження
   1246                    */
   1247                    total_error_sw_fixed(37);
   1248                  }
   1249                    
   1250                  //Робимо резервну копію кількості байт для передавання і буфер передавання
   1251                  if ((number_bytes_transfer_spi_df != 0) && (number_bytes_transfer_spi_df < sizeof(TxBuffer_SPI_DF)))
   1252                  {
   1253                    number_bytes_transfer_spi_df_copy = number_bytes_transfer_spi_df;
   1254                    for(unsigned int i = 0; i < number_bytes_transfer_spi_df_copy; i++)
   1255                      TxBuffer_SPI_DF_copy[i] = TxBuffer_SPI_DF[i];
   1256                  }
   1257                  else
   1258                  {
   1259                    //Відбулася невизначена помилка, тому треба піти на перезавантаження
   1260                    total_error_sw_fixed(36);
   1261                  }
   1262                  
   1263                  //Запам'ятовуємо, яка виконувалася операція
   1264                  code_operation_copy = code_operation_copy_tmp;
   1265          
   1266                  //Помічаємо, що зафіксовано помилку при обміні
   1267                  error_into_spi_df = 0xff;
   1268                }
   1269              }
   1270            }
   1271            else
   1272            {
   1273              //Відбулася невизначена помилка, тому треба піти на перезавантаження
   1274              total_error_sw_fixed(35);
   1275            }
   1276            
   1277            /*Виставляємо повідомлення про помилку обміну через SPI_DF*/
   1278            _SET_BIT(set_diagnostyka, ERROR_SPI_DF_BIT);
   1279          
   1280            //Дозволяємо переривання від помилок на SPI_DF
   1281            SPI_I2S_ITConfig(SPI_DF, SPI_I2S_IT_ERR, ENABLE);
   1282            
   1283          #ifdef SYSTEM_VIEWER_ENABLE
   1284            SEGGER_SYSVIEW_RecordExitISR();
   1285          #endif
   1286          }
   1287          /*****************************************************/
   1288            
   1289          /*****************************************************/
   1290          //Перереривання від завершення прийому DMA_StreamSPI_DF_Rx
   1291          /*****************************************************/
   1292          void DMA_StreamSPI_DF_Rx_IRQHandler(void)
   1293          {
   1294          #ifdef SYSTEM_VIEWER_ENABLE
   1295            SEGGER_SYSVIEW_RecordEnterISR();
   1296          #endif
   1297          
   1298            /*
   1299            Очікуємо поки TXE=1 і BSY=0 - це ознака повногго завершення передачі даних,
   1300            а ознакою завершення прийому дані - це є генерація цього переривання
   1301            */
   1302            while ((SPI_DF->SR & SPI_I2S_FLAG_TXE) == 0);
   1303            while ((SPI_DF->SR & SPI_I2S_FLAG_BSY) != 0);
   1304          
   1305            //Знімаємо Chip_select переводом NSS  у 1
   1306            GPIO_SPI_DF->BSRRL = GPIO_NSSPin_DF;
   1307            
   1308            //Зупиняємо потоки DMA
   1309            DMA_StreamSPI_DF_Tx->CR &= ~(uint32_t)DMA_SxCR_EN;
   1310            DMA_StreamSPI_DF_Tx->NDTR = 0;
   1311            DMA_StreamSPI_DF_Rx->CR &= ~(uint32_t)DMA_SxCR_EN;
   1312            DMA_StreamSPI_DF_Rx->NDTR = 0;
   1313          
   1314            //Забороняємо генерацію переривань від потоку DMA_StreamSPI_DF_Rx
   1315            DMA_StreamSPI_DF_Rx->CR &= ~DMA_IT_TC;
   1316            
   1317            //Очищаємо прапореці, що сигналізує про завершення передачі даних для DMA по потоку DMA_StreamSPI_DF_Rx
   1318            DMA_ClearFlag(DMA_StreamSPI_DF_Rx, DMA_FLAG_TCSPI_DF_Rx | DMA_FLAG_HTSPI_DF_Rx | DMA_FLAG_TEISPI_DF_Rx | DMA_FLAG_DMEISPI_DF_Rx | DMA_FLAG_FEISPI_DF_Rx);
   1319            
   1320            //Виставляємо повідомлення, що дані передані і готові до наступного аналізу
   1321            if ((number_chip_dataflsh_exchange == INDEX_DATAFLASH_1) || (number_chip_dataflsh_exchange == INDEX_DATAFLASH_2))
   1322              driver_spi_df[number_chip_dataflsh_exchange].state_execution = TRANSACTION_EXECUTED_WAIT_ANALIZE;
   1323            else
   1324            {
   1325              //Відбулася невизначена помилка, тому треба піти на перезавантаження
   1326              total_error_sw_fixed(20);
   1327            }
   1328                
   1329            //Обмін відбувся вдало - скидаємо повідомлення про попередньо можливу помилку обміну через SPI_DF
   1330            _SET_BIT(clear_diagnostyka, ERROR_SPI_DF_BIT);
   1331            
   1332          #ifdef SYSTEM_VIEWER_ENABLE
   1333            SEGGER_SYSVIEW_RecordExitISR();
   1334          #endif
   1335          }
   1336          /*****************************************************/
   1337          
   1338          /*****************************************************/
   1339          //Переривання від USART RS-485
   1340          /*****************************************************/
   1341          void USARTRS485_IRQHandler(void)
   1342          {
   1343          #ifdef SYSTEM_VIEWER_ENABLE
   1344            SEGGER_SYSVIEW_RecordEnterISR();
   1345          #endif
   1346          
   1347            if (USART_GetITStatus(USART_RS485, USART_IT_TC) != RESET)
   1348            {
   1349              //Переводимо мікросхкму на прийом
   1350              GPIO_485DE->BSRRH = GPIO_PIN_485DE;
   1351          
   1352              //Забороняємо генерацію переривань при завершенні передачі байту
   1353              USART_ITConfig(USART_RS485, USART_IT_TC, DISABLE);
   1354                
   1355              //Скидаємо біт, що символізує, що опстанній байт переданий
   1356              USART_ClearFlag(USART_RS485, USART_FLAG_TC);
   1357          
   1358              //Відновлюємо моніторинг каналу RS-485 , якщо не стоїть умова реконфігурувати інтерфейс
   1359              if (make_reconfiguration_RS_485 == 0) restart_monitoring_RS485();
   1360            }
   1361            
   1362            if(USART_GetITStatus(USART_RS485, USART_IT_IDLE) != RESET)
   1363            {
   1364              //Зафіксовано IDLE стан
   1365              if ((DMA_StreamRS485_Rx->CR & (uint32_t)DMA_SxCR_EN) !=0) DMA_StreamRS485_Rx->CR &= ~(uint32_t)DMA_SxCR_EN;
   1366              USART_RS485->SR;
   1367              (uint16_t)(USART_RS485->DR & (uint16_t)0x01FF);
   1368          
   1369              // Очищаємо прапореці, що сигналізує про завершення передачі даних для DMA1 по каналу RS-485_RX 
   1370              DMA_ClearFlag(DMA_StreamRS485_Rx, DMA_FLAG_TCRS485_Rx | DMA_FLAG_HTRS485_Rx | DMA_FLAG_TEIRS485_Rx | DMA_FLAG_DMEIRS485_Rx | DMA_FLAG_FEIRS485_Rx);
   1371              uint32_t NDTR_tmp = DMA_StreamRS485_Rx->NDTR;
   1372              DMA_StreamRS485_Rx->NDTR = NDTR_tmp;
   1373              DMA_StreamRS485_Rx->CR |= (uint32_t)DMA_SxCR_EN;
   1374            }
   1375          
   1376            if(USART_GetITStatus(USART_RS485, USART_IT_LBD) != RESET)
   1377            {
   1378              //Зафіксовано Break стан
   1379              USART_ClearFlag(USART_RS485, USART_FLAG_LBD);
   1380            }
   1381          
   1382            unsigned int error_status = USART_RS485->SR &  (USART_FLAG_ORE | USART_FLAG_NE | USART_FLAG_FE | USART_FLAG_PE);
   1383            if (error_status != 0)
   1384          /*    
   1385            if(
   1386               (USART_GetITStatus(USART_RS485, USART_IT_PE  ) != RESET) ||
   1387               (USART_GetITStatus(USART_RS485, USART_IT_NE  ) != RESET) ||
   1388               (USART_GetITStatus(USART_RS485, USART_IT_FE  ) != RESET) ||
   1389               (USART_GetITStatus(USART_RS485, USART_IT_ORE ) != RESET)
   1390              )
   1391          */    
   1392            {
   1393              //Зафіксовано помилку під час прийому - перезапускаємо прийом через DMA
   1394              if ((DMA_StreamRS485_Rx->CR & (uint32_t)DMA_SxCR_EN) !=0) DMA_StreamRS485_Rx->CR &= ~(uint32_t)DMA_SxCR_EN;
   1395              USART_RS485->SR;
   1396              (uint16_t)(USART_RS485->DR & (uint16_t)0x01FF);
   1397              // Очищаємо прапореці, що сигналізує про завершення передачі даних для DMA1 по каналу RS-485_RX 
   1398              DMA_ClearFlag(DMA_StreamRS485_Rx, DMA_FLAG_TCRS485_Rx | DMA_FLAG_HTRS485_Rx | DMA_FLAG_TEIRS485_Rx | DMA_FLAG_DMEIRS485_Rx | DMA_FLAG_FEIRS485_Rx);
   1399              DMA_StreamRS485_Rx->NDTR = BUFFER_RS485;
   1400              RxBuffer_RS485_count_previous = 0;
   1401              RxBuffer_RS485_count = 0;
   1402              DMA_StreamRS485_Rx->CR |= (uint32_t)DMA_SxCR_EN;
   1403            }
   1404            
   1405          #ifdef SYSTEM_VIEWER_ENABLE
   1406            SEGGER_SYSVIEW_RecordExitISR();
   1407          #endif
   1408          }
   1409          /*****************************************************/
   1410          
   1411          /*****************************************************/
   1412          //Переривання від завершення передачі даних через DMA потоку DMA_StreamRS485_Tx
   1413          /*****************************************************/
   1414          void DMA_StreamRS485_Tx_IRQHandler(void)
   1415          {
   1416          #ifdef SYSTEM_VIEWER_ENABLE
   1417            SEGGER_SYSVIEW_RecordEnterISR();
   1418          #endif
   1419          
   1420            //Дозволяємо генерацію переривань при завершенні передачі байту
   1421            USART_ITConfig(USART_RS485, USART_IT_TC, ENABLE);
   1422          
   1423            //Забороняємо генерацію переривання від DMA_StreamRS485_Tx
   1424            DMA_StreamRS485_Tx->CR &= ~DMA_IT_TC;
   1425          
   1426            //Зупиняємо потоку DMA
   1427            DMA_StreamRS485_Tx->CR &= ~(uint32_t)DMA_SxCR_EN;
   1428            DMA_StreamRS485_Tx->NDTR = 0;
   1429          
   1430            //Очищаємо прапореці, що сигналізує про завершення передачі даних для DMA1 по потоку RS-485_TX
   1431            DMA_ClearFlag(DMA_StreamRS485_Tx, DMA_FLAG_TCRS485_Tx | DMA_FLAG_HTRS485_Tx | DMA_FLAG_TEIRS485_Tx | DMA_FLAG_DMEIRS485_Tx | DMA_FLAG_FEIRS485_Tx);
   1432            
   1433          #ifdef SYSTEM_VIEWER_ENABLE
   1434            SEGGER_SYSVIEW_RecordExitISR();
   1435          #endif
   1436          }
   1437          /*****************************************************/
   1438          
   1439          /*****************************************************/
   1440          //Переривання від I2C
   1441          /*****************************************************/
   1442          void EXITI_POWER_IRQHandler(void)
   1443          {
   1444          #ifdef SYSTEM_VIEWER_ENABLE
   1445            SEGGER_SYSVIEW_RecordEnterISR();
   1446          #endif
   1447          
   1448            if(EXTI_GetITStatus(EXTI_Line_POWER) != RESET)
   1449            {
   1450              /* Clear the EXTI line 0 pending bit */
   1451              EXTI_ClearITPendingBit(EXTI_Line_POWER);
   1452              
   1453              if ((POWER_CTRL->IDR & POWER_CTRL_PIN) != (uint32_t)Bit_RESET)
   1454              {
   1455                //Живлення появилося на вході блоку живлення
   1456          
   1457                //Виставляємо повідомлення про цю подію
   1458                _SET_BIT(clear_diagnostyka, EVENT_DROP_POWER_BIT);
   1459              }
   1460              else
   1461              {
   1462                //Живлення пропало на вході блоку живлення
   1463          
   1464                //Виставляємо повідомлення про цю подію
   1465                _SET_BIT(set_diagnostyka, EVENT_DROP_POWER_BIT);
   1466              }
   1467            }
   1468            
   1469          #ifdef SYSTEM_VIEWER_ENABLE
   1470            SEGGER_SYSVIEW_RecordExitISR();
   1471          #endif
   1472          }
   1473          /*****************************************************/
   1474          
   1475          /*****************************************************/
   1476          //
   1477          /*****************************************************/
   1478          /*****************************************************/
   1479          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   DMA1_Stream0_IRQHandler
         8   -> DMA_ClearFlag
         8   -> SEGGER_SYSVIEW_RecordEnterISR
         8   -> SEGGER_SYSVIEW_RecordExitISR
       8   DMA1_Stream6_IRQHandler
         8   -> DMA_ClearFlag
         8   -> SEGGER_SYSVIEW_RecordEnterISR
         8   -> SEGGER_SYSVIEW_RecordExitISR
         8   -> USART_ITConfig
       8   DMA1_Stream7_IRQHandler
         8   -> DMA_ClearFlag
         8   -> I2C_GetFlagStatus
         8   -> SEGGER_SYSVIEW_RecordEnterISR
         8   -> SEGGER_SYSVIEW_RecordExitISR
       8   DMA2_Stream0_IRQHandler
         8   -> DMA_ClearFlag
         8   -> SEGGER_SYSVIEW_RecordEnterISR
         8   -> SEGGER_SYSVIEW_RecordExitISR
         8   -> total_error_sw_fixed
       8   EXTI0_IRQHandler
         8   -> EXTI_ClearITPendingBit
         8   -> EXTI_GetITStatus
         8   -> SEGGER_SYSVIEW_RecordEnterISR
         8   -> SEGGER_SYSVIEW_RecordExitISR
       8   I2C1_ER_IRQHandler
         8   -> SEGGER_SYSVIEW_RecordEnterISR
         8   -> SEGGER_SYSVIEW_RecordExitISR
         8   -> check_errors_i2c
       8   I2C1_EV_IRQHandler
         8   -> DMA_ClearFlag
         8   -> I2C_GetLastEvent
         8   -> SEGGER_SYSVIEW_RecordEnterISR
         8   -> SEGGER_SYSVIEW_RecordExitISR
      32   SPI1_IRQHandler
        32   -> DMA_ClearFlag
        32   -> SEGGER_SYSVIEW_RecordEnterISR
        32   -> SEGGER_SYSVIEW_RecordExitISR
        32   -> SPI_Cmd
        32   -> SPI_I2S_DMACmd
        32   -> SPI_I2S_ITConfig
        32   -> SPI_Init
        32   -> total_error_sw_fixed
      48   TIM4_IRQHandler
        48   -> GPIO_ResetBits
        48   -> GPIO_SetBits
        48   -> SEGGER_SYSVIEW_RecordEnterISR
        48   -> SEGGER_SYSVIEW_RecordExitISR
        48   -> TIM_GetITStatus
        48   -> calculate_namber_bit_waiting_for_rs_485
        48   -> changing_diagnostyka_state
        48   -> check_state_key
        48   -> dataflash_status_read
        48   -> main_function_for_dataflash_req
        48   -> main_function_for_dataflash_resp
        48   -> restart_monitoring_RS485
        48   -> start_exchange_via_spi
        48   -> total_error_sw_fixed
      32   TIM5_IRQHandler
        32   -> SEGGER_SYSVIEW_RecordEnterISR
        32   -> SEGGER_SYSVIEW_RecordExitISR
        32   -> TIM_GetITStatus
        32   -> control_reading_ADCs
        32   -> total_error_sw_fixed
       8   USART2_IRQHandler
         8   -> DMA_ClearFlag
         8   -> SEGGER_SYSVIEW_RecordEnterISR
         8   -> SEGGER_SYSVIEW_RecordExitISR
         8   -> USART_ClearFlag
         8   -> USART_GetITStatus
         8   -> USART_ITConfig
         8   -> restart_monitoring_RS485
       8   check_errors_i2c
         8   -> I2C_ClearFlag
         8   -> I2C_GetFlagStatus
      16   check_state_key
        16   -> GPIO_ReadInputDataBit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_17
       4  ??DataTable10_18
       4  ??DataTable10_19
       4  ??DataTable10_2
       4  ??DataTable10_20
       4  ??DataTable10_21
       4  ??DataTable10_22
       4  ??DataTable10_23
       4  ??DataTable10_24
       4  ??DataTable10_25
       4  ??DataTable10_26
       4  ??DataTable10_27
       4  ??DataTable10_28
       4  ??DataTable10_29
       4  ??DataTable10_3
       4  ??DataTable10_30
       4  ??DataTable10_31
       4  ??DataTable10_32
       4  ??DataTable10_33
       4  ??DataTable10_34
       4  ??DataTable10_35
       4  ??DataTable10_36
       4  ??DataTable10_37
       4  ??DataTable10_38
       4  ??DataTable10_39
       4  ??DataTable10_4
       4  ??DataTable10_40
       4  ??DataTable10_41
       4  ??DataTable10_42
       4  ??DataTable10_43
       4  ??DataTable10_44
       4  ??DataTable10_45
       4  ??DataTable10_46
       4  ??DataTable10_47
       4  ??DataTable10_48
       4  ??DataTable10_49
       4  ??DataTable10_5
       4  ??DataTable10_50
       4  ??DataTable10_51
       4  ??DataTable10_52
       4  ??DataTable10_53
       4  ??DataTable10_54
       4  ??DataTable10_55
       4  ??DataTable10_56
       4  ??DataTable10_57
       4  ??DataTable10_58
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       4  ??DataTable4
       4  ??DataTable4_1
       4  ??DataTable4_10
       4  ??DataTable4_11
       4  ??DataTable4_12
       4  ??DataTable4_13
       4  ??DataTable4_14
       4  ??DataTable4_15
       4  ??DataTable4_16
       4  ??DataTable4_17
       4  ??DataTable4_18
       4  ??DataTable4_19
       4  ??DataTable4_2
       4  ??DataTable4_20
       4  ??DataTable4_21
       4  ??DataTable4_22
       4  ??DataTable4_3
       4  ??DataTable4_4
       4  ??DataTable4_5
       4  ??DataTable4_6
       4  ??DataTable4_7
       4  ??DataTable4_8
       4  ??DataTable4_9
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_2
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable7
       4  ??DataTable7_1
       4  ??DataTable7_2
       4  ??DataTable7_3
       4  ??DataTable7_4
       4  ??DataTable7_5
       4  ??DataTable7_6
       4  ??DataTable8
       4  ??DataTable8_1
       4  ??DataTable8_2
       4  ??DataTable8_3
       4  ??DataTable9
       4  ??DataTable9_1
       4  ??DataTable9_2
       4  ??DataTable9_3
       4  ??DataTable9_4
       4  ??DataTable9_5
      82  DMA1_Stream0_IRQHandler
      62  DMA1_Stream6_IRQHandler
     148  DMA1_Stream7_IRQHandler
     138  DMA2_Stream0_IRQHandler
      62  EXTI0_IRQHandler
      86  I2C1_ER_IRQHandler
     654  I2C1_EV_IRQHandler
     634  SPI1_IRQHandler
    2654  TIM4_IRQHandler
     266  TIM5_IRQHandler
     250  USART2_IRQHandler
      40  check_errors_i2c
     164  check_state_key
       4  number_ticks_for_OF_bit_reset

 
     4 bytes in section .bss
 5 716 bytes in section .text
 
 5 512 bytes of CODE memory (+ 204 bytes shared)
     4 bytes of DATA memory

Errors: none
Warnings: none
