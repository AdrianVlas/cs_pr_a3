###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       24/Mar/2017  12:54:59
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\protections.c
#    Command line =  
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\protections.c" -D USE_STDPERIPH_DRIVER -D STM32F2XX -D
#        USE_USB_OTG_FS -D KEYBOARD_VER_1 -D SYSTEM_VIEWER_ENABLE -lc
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List" --remarks -o
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --enable_multibytes --fpu=None
#        --dlib_config G:\PRG\IAR7_50_2\arm\INC\c\DLib_Config_Full.h -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\usb\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_OTG_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Core\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\"
#        -I "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\Config\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\OS\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\SEGGER\" -On --use_c++_inline
#        --require_prototypes -I G:\PRG\IAR7_50_2\arm\CMSIS\Include\ -D
#        ARM_MATH_CM3
#    List file    =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List\protections.lst
#    Object file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj\protections.o
#
###############################################################################

G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working files\src\protections.c
      1          #include "header.h"
      2          #include "../v_A_shm/I_Shm.h"
      3          #include "../v_A_shm/prtTmr.h"
      4          /*****************************************************/
      5          //Діагностика АЦП
      6          /*****************************************************/
      7          inline void diagnostyca_adc_execution(void)
      8          {
      9            if (gnd_adc >0x51) _SET_BIT(set_diagnostyka, ERROR_GND_ADC_TEST_BIT);
     10            else _SET_BIT(clear_diagnostyka, ERROR_GND_ADC_TEST_BIT);
     11          
     12            if ((vref_adc <0x709) || (vref_adc > 0x8f5)) _SET_BIT(set_diagnostyka, ERROR_VREF_ADC_TEST_BIT);
     13            else _SET_BIT(clear_diagnostyka,ERROR_VREF_ADC_TEST_BIT);
     14          
     15            if ((vdd_adc <0x8F9) || (vdd_adc > 0xC24)) _SET_BIT(set_diagnostyka, ERROR_VDD_ADC_TEST_BIT);
     16            else _SET_BIT(clear_diagnostyka, ERROR_VDD_ADC_TEST_BIT);
     17          }
     18          /*****************************************************/
     19          
     20          /*****************************************************/
     21          //Пошук розрядності числа
     22          /*****************************************************/
     23          inline unsigned int norma_value(unsigned long long y)
     24          {
     25            unsigned long long temp=y;
     26            unsigned int rezultat =0;
     27            if (temp == 0) return 0;
     28          
     29            while(temp !=0)
     30            {
     31              temp = temp>>1;
     32              rezultat++;
     33            }
     34            return rezultat-1;
     35          }
     36          /*****************************************************/
     37          
     38          /*****************************************************/
     39          //Пошук розрядності числа типу int
     40          /*****************************************************/
     41          inline unsigned int get_order(int value)
     42          {
     43            unsigned int i = 0;
     44          
     45            if (value == 0) return 1;  
     46            if (value < 0) value =-value;
     47          
     48            while ((value >> (++i)) != 0); 
     49          
     50            return i;    
     51          }
     52          /*****************************************************/
     53          
     54          /*****************************************************/
     55          //Розрахунок кореня квадратного методом половинного ділення  з прогнозуванням розрядності числа
     56          /*****************************************************/
     57          unsigned int sqrt_64(unsigned long long y)
     58          {
     59             unsigned int b;
     60             unsigned int a;
     61             unsigned int c;
     62             unsigned int norma_rez;
     63             unsigned long long temp;
     64             
     65             norma_rez = norma_value(y)>>1;
     66             
     67             a = (1<<norma_rez) - 1;
     68             b = (1<<(norma_rez+1));
     69           
     70             do 
     71              {
     72               c = (a + b)>>1;
     73               temp = (unsigned long long)c*(unsigned long long)c; 
     74               if (temp != y)
     75                 {
     76                  if ( temp > y) b= c; else a= c;
     77                 } 
     78               else return c;
     79              }
     80             while ((b-a)>1);
     81          
     82             c = (a + b)>>1;
     83          
     84             return c ;
     85          }
     86          /*****************************************************/
     87          
     88          /*****************************************************/
     89          //Розрахунок кореня квадратного методом половинного ділення  з прогнозуванням розрядності числа
     90          /*****************************************************/
     91          inline unsigned int sqrt_32(unsigned int y)
     92          {
     93             unsigned int b;
     94             unsigned int a;
     95             unsigned int c;
     96             unsigned int norma_rez;
     97             unsigned int temp;
     98             
     99             norma_rez = norma_value(y)>>1;
    100             
    101             a = (1<<norma_rez) - 1;
    102             b = (1<<(norma_rez+1));
    103           
    104             do 
    105              {
    106               c = (a + b)>>1;
    107               temp = c*c; 
    108               if (temp != y)
    109                 {
    110                  if ( temp > y) b= c; else a= c;
    111                 } 
    112               else return c;
    113              }
    114             while ((b-a)>1);
    115          
    116             c = (a + b)>>1;
    117          
    118             return c ;
    119          }
    120          /*****************************************************/
    121          
    122          /*****************************************************/
    123          //Розрахунки віимірювань
    124          /*****************************************************/
    125          inline void calc_measurement(void)
    126          {
    127            unsigned long long sum_sqr_data_local[NUMBER_ANALOG_CANALES];
    128            
    129            //Копіюємо вхідні велечини у локальні змінні
    130            /*
    131            Оскільки для інтеградбного розгахунку сума квадратів з період ділиться на період, 
    132            що для дискретного випадку аналогічно діленню на кількість виборок, то ми це ділення якраз і робимо зміщенням
    133            */
    134            unsigned int bank_sum_sqr_data_tmp = (bank_sum_sqr_data + 1) & 0x1;
    135            for(uint32_t i =0; i < NUMBER_ANALOG_CANALES; i++ )
    136            {
    137              /***/
    138              //Розраховуємо діюче значення 3I0 по інтегральній сформулі
    139              /***/
    140              /*Добуваємо квадратний корінь*/
    141              sum_sqr_data_local[i] = sqrt_64(sum_sqr_data[bank_sum_sqr_data_tmp][i]);
    142            
    143              /*Для приведення цього значення у мА/мВ треба помножити на свій коефіцієнт*/
    144              /*Ще сигнал зараз є підсиленим у 16 раз, тому ділим його на 16*/
    145          
    146              /*
    147              Ми маємо ще отримане число поділити на корнь з NUMBER_POINT = 32 = 16*2
    148              Тобто ми маємо поділити на 4*sqrt(2)
    149              4 це зміщення на 2
    150              ((MNOGNYK_I * X )>> VAGA_DILENNJA_I)/sqrt(2) тотожне
    151             (MNOGNYK_I_DIJUCHE * X )>> VAGA_DILENNJA_I_DIJUCHE 
    152          
    153              ((MNOGNYK_U * X )>> VAGA_DILENNJA_U)/sqrt(2) тотожне
    154             (MNOGNYK_U_DIJUCHE * X )>> VAGA_DILENNJA_D_DIJUCHE 
    155              
    156              Якщо робити через пари (MNOGNYK_I_DIJUCHE;VAGA_DILENNJA_I_DIJUCHE)/(MNOGNYK_U_DIJUCHE;VAGA_DILENNJA_U_DIJUCHE) і (MNOGNYK_I;VAGA_DILENNJA_I)/(MNOGNYK_U;VAGA_DILENNJA_U)
    157              то виникає похибка при розрахунку вищих гармонік (що було коли для захистів велися такі розрахунки. У ЦС їх немає).
    158              Тому треба іти на такі спрощення виразів
    159              */
    160              
    161              float mnognyk = (i < (NUMBER_ANALOG_CANALES - 1)) ? MNOGNYK_I_DIJUCHE_FLOAT : MNOGNYK_U_DIJUCHE_FLOAT;
    162              float value_float = mnognyk*((float)sum_sqr_data_local[i])/(64.0f); /*64 = 4*16. 16 - це підсилення каналів "Analog Input"; 4 - це sqrt(16), а 16 береться з того, що 32 = 16*2 */
    163              measurement[i] = (unsigned int)value_float; 
    164              /***/
    165            }
    166          }
    167          /*****************************************************/
    168          
    169          /*****************************************************/
    170          //Модуль обробки дискретних входів
    171          /*****************************************************/
    172          inline void input_scan(void)
    173          {
    174            unsigned int state_inputs_into_pin, temp_state_inputs_into_pin; //Змінні у якій формуємо значення входів отримані із входів процесора (пінів)
    175            static unsigned int state_inputs_into_pin_trigger; //У цій змінній зберігається попередній стан піна, у випадку коли ми перевіряємо .чи утримається цей стан до кінця тактування таймера допуску
    176          
    177            /***************************/
    178            //У цій частині знімаємо стани входів процесора (пінів), які відповідають за дискретні входи
    179            /*
    180            -----------------------------
    181            значення поміщається у відпорвідні біти змінної state_inputs_into_pin
    182              "є     сигнал " - відповідає встановленому біту (1)
    183              "немає сигналу" - відповідає скинутому     біту (0)
    184            -----------------------------
    185            */
    186            unsigned int temp_state_inputs_into_pin_1 = _DEVICE_REGISTER(Bank1_SRAM2_ADDR, OFFSET_INPUTS_1) & ((1 << NUMBER_INPUTS_1) - 1);
    187            unsigned int temp_state_inputs_into_pin_2 = _DEVICE_REGISTER(Bank1_SRAM2_ADDR, OFFSET_INPUTS_2) & ((1 << NUMBER_INPUTS_2) - 1);
    188            temp_state_inputs_into_pin = temp_state_inputs_into_pin_1 | (temp_state_inputs_into_pin_2 << NUMBER_INPUTS_1);
    189            
    190            //Змінюємо порядок, щоб наймений номер відповідав нумерації на приладі
    191            state_inputs_into_pin = 0;
    192            for (unsigned int index = 0; index < NUMBER_INPUTS; index++)
    193            {
    194              if ((temp_state_inputs_into_pin & (1 << index)) != 0) 
    195              {
    196                if (index < NUMBER_INPUTS_1)
    197                  state_inputs_into_pin |= 1 << (NUMBER_INPUTS_1 - index - 1);
    198                else
    199                  state_inputs_into_pin |= 1 << index;
    200              }
    201            }
    202            /***************************/
    203            
    204            /***************************/
    205            //Обробка таймерів допуску дискретних входів
    206            /***************************/
    207            for(unsigned int i = 0; i < NUMBER_INPUTS; i++)
    208            {
    209              unsigned int maska = 1<<i;
    210              int max_value_timer = /*current_settings_prt.dopusk_dv[i]*/60;
    211          
    212              if (global_timers[INDEX_TIMER_INPUT_START + i] < 0)
    213              {
    214                //Провірка на зміну стану дискретного входу здійснюється тільки тоді, коли величина таймере є від'ємною
    215                //Що означає що таймер не запущений у попередній момент
    216                
    217                //Перевіряємо чи таеперішній стан входу відповідає попердньомук стану
    218                if ((state_inputs_into_pin & maska) != (state_inputs & maska))
    219                {
    220                  //Якщо стан входу змінився, то виконуємо дії по зміні стану
    221          
    222                  //1-дія: Запям'ятовуємо текучий стан входу
    223                  state_inputs_into_pin_trigger &= ~maska;
    224                  state_inputs_into_pin_trigger |= (state_inputs_into_pin & maska);
    225          
    226                  //2-дія: Запускаємо таймер допуску дискретного входу
    227                  global_timers[INDEX_TIMER_INPUT_START + i] = 0;
    228                }
    229              }
    230              else
    231              {
    232                //Якщо таймер запущений виконуємо дії з таймером
    233                if (global_timers[INDEX_TIMER_INPUT_START + i] < max_value_timer)
    234                {
    235                  //Якщо таймер ще не дійшов до свого макисмуму, то просто збільшуємо його величину
    236                  global_timers[INDEX_TIMER_INPUT_START + i] += DELTA_TIME_FOR_TIMERS;
    237                  
    238                  //У випадку, якщо тип сигналу на вхід подається змінний
    239                  //і ми перевіряємо чи не відбувся перехід "є сигнал"->"немає сигналу"
    240                  //то поява сигналу під час тактування таймера допуску означає, що сигнал на вході є - 
    241                  //а це означає, що треба зупинити nаймер, бо переходу "є сигнал"->"немає сигналу" на протязі тактування таймеру не зафіксовано 
    242                  if ((0/*current_settings_prt.type_of_input_signal*/ & maska) != 0)
    243                  {
    244                     if ((state_inputs_into_pin_trigger & maska) == 0)
    245                     {
    246                       if ((state_inputs_into_pin & maska) != 0)
    247                         global_timers[INDEX_TIMER_INPUT_START + i] = -1;
    248                     }
    249                  }
    250                }
    251              }
    252              
    253              //Якщо величина таймера допуска знаходиться у свому максимальному значенні, то перевіряємо, чи фактично змінився стано входу
    254              if (global_timers[INDEX_TIMER_INPUT_START + i] >= max_value_timer)
    255              {
    256                //Перевіряємо, чи стан піна змінився у порівнянні із станом, який був на момент запуску таймера допуску дискретного входу
    257                unsigned int state_1, state_2;
    258                  
    259                state_1 = state_inputs_into_pin_trigger & maska;
    260                state_2 = state_inputs_into_pin  & maska;
    261                  
    262                if (state_1 == state_2)
    263                {
    264                  //Якщо два стани співпадають, то ми вважаємо, що відбулася зіна стану дискретного входу і формуємо новий стан входу
    265                  //При цьому враховуємо що для прявого    входу 1 - це активний вхід, а 0 - це пасивний вхід
    266                  //                        для інверсного входу 0 - це активний вхід, а 1 - це пасивний вхід
    267                    state_inputs &=  ~maska;
    268                    state_inputs |=   state_2;
    269                }
    270                  
    271                //У будь-якому випадк, чи змінився стан входу, чи ні, а оскілька таймер допуску дотактував до кінця, то скидаємотаймер у висхідне від'ємне занчення
    272                global_timers[INDEX_TIMER_INPUT_START + i] = -1;
    273              }
    274            }
    275            /***************************/
    276          }
    277          /*****************************************************/
    278          
    279          /*****************************************************/
    280          //Функція обробки таймерів
    281          /*****************************************************/
    282          inline void clocking_global_timers(void)
    283          {
    284            //Опрацьовуємо дискретні входи
    285            input_scan();
    286            
    287            //опрацьовуємо всі решта таймери логіки
    288            for (unsigned int i = INDEX_TIMER_TEMP; i < MAX_NUMBER_GLOBAL_TIMERS; i++)
    289            {
    290              if (global_timers[i] >= 0)
    291              {
    292                //Першою умовою того, що таймер треба тактувати є той факт, що величина таймеру не від'ємна
    293          
    294                //Перевіряємо чи треба збільшувати величину таймеру, якщо він ще не досягнув свого максимуму
    295                if (global_timers[i] <= (0x7fffffff - DELTA_TIME_FOR_TIMERS)) global_timers[i] += DELTA_TIME_FOR_TIMERS;
    296              }
    297            }
    298          }
    299          /*****************************************************/
    300          
    301          /*****************************************************/
    302          //Функція захистів з якої здійснюються всі інші операції
    303          /*****************************************************/
    304          inline void main_protection(void)
    305          {
    306            /**************************/
    307            //Перевірка, чи треба очистити трігерні функції
    308            /**************************/
    309            if (reset_trigger_function_from_interface !=0)
    310            {
    311              
    312              //Помічаємо що ми виконали очистку по ВСІХ інтерфейсах
    313              reset_trigger_function_from_interface = 0;
    314            }
    315            /**************************/
    316            RdHrdIn((void*)&DiHrdStateUI32Bit);
    317            SetHrdOut((void*)&DoStateUI32Bit);
    318            SetHrdLed((void*)&LedStateUI32Bit);
    319            TmrCalls();
    320            DoCalcWrp();
    321            /**************************/
    322            //Опрацьовуємо натиснуті кнопки
    323            /**************************/
    324            //Активація з кнопуки
    325            if (pressed_buttons != 0)
    326            {
    327          
    328              //Очищаємо натиснуті кнопка, які ми вже опрацювали
    329              pressed_buttons =0;
    330            }
    331            /**************************/
    332              
    333            /**************************/
    334            //Опрацьовуємо сигнали з ТУ/Goose
    335            /**************************/
    336            if (activation_function_from_interface != 0)
    337            {
    338          
    339              //Очищаємо помітку активації функцій з інетфейсу, які ми вже опрацювали
    340              activation_function_from_interface = 0;
    341            }
    342            /**************************/
    343          
    344            /**************************/
    345            //Опрацьовуємо дискретні входи
    346            /**************************/
    347            //Перевіряємо чи є зараз активні входи
    348            if (state_inputs !=0)
    349            {
    350            }
    351            /**************************/
    352          
    353            /**************************/
    354            //Виконуємо фільтрацію переднього фронту для тих сигналів, які мають активуватися тільки по передньому фронтові
    355            /**************************/
    356            {
    357            }
    358            /**************************/
    359          
    360            /***********************************************************/
    361            //Розрахунок вимірювань
    362            /***********************************************************/
    363            calc_measurement();
    364          
    365            //Копіюємо вимірювання для низькопріоритетних і високопріоритетних завдань
    366            unsigned int bank_measurement_high_tmp = (bank_measurement_high ^ 0x1) & 0x1;
    367            if(semaphore_measure_values_low1 == 0)
    368            {
    369              for (unsigned int i = 0; i < NUMBER_ANALOG_CANALES; i++) 
    370              {
    371                measurement_high[bank_measurement_high_tmp][i] = measurement_middle[i] = measurement[i];
    372              }
    373            }
    374            else
    375            {
    376              for (unsigned int i = 0; i < NUMBER_ANALOG_CANALES; i++) 
    377              {
    378                measurement_high[bank_measurement_high_tmp][i] = measurement[i];
    379              }
    380            }
    381            bank_measurement_high = bank_measurement_high_tmp;
    382            /**************************/
    383          
    384            /**************************/
    385            //Сигнал "Несправность Общая"
    386            /**************************/
    387            diagnostyca_adc_execution();
    388          
    389            unsigned int diagnostyka_tmp[3];
    390            diagnostyka_tmp[0] = diagnostyka[0];
    391            diagnostyka_tmp[1] = diagnostyka[1];
    392            diagnostyka_tmp[2] = diagnostyka[2];
    393          
    394            diagnostyka_tmp[0] &= (unsigned int)(~clear_diagnostyka[0]); 
    395            diagnostyka_tmp[0] |= set_diagnostyka[0]; 
    396          
    397            diagnostyka_tmp[1] &= (unsigned int)(~clear_diagnostyka[1]); 
    398            diagnostyka_tmp[1] |= set_diagnostyka[1]; 
    399          
    400            diagnostyka_tmp[2] &= (unsigned int)(~clear_diagnostyka[2]); 
    401            diagnostyka_tmp[2] |= set_diagnostyka[2]; 
    402            
    403            diagnostyka_tmp[2] &= USED_BITS_IN_LAST_INDEX; 
    404          
    405            _CLEAR_BIT(diagnostyka_tmp, EVENT_START_SYSTEM_BIT);
    406            _CLEAR_BIT(diagnostyka_tmp, EVENT_DROP_POWER_BIT);
    407            if (
    408                (diagnostyka_tmp[0] != 0) ||
    409                (diagnostyka_tmp[1] != 0) ||
    410                (diagnostyka_tmp[2] != 0)
    411               )   
    412            {
    413              _SET_BIT(fix_block_active_state, FIX_BLOCK_DEFECT);
    414              /**************************/
    415              //Сигнал "Несправность Аварийная"
    416              /**************************/
    417              if (
    418                  ((diagnostyka_tmp[0] & MASKA_AVAR_ERROR_0) != 0) ||
    419                  ((diagnostyka_tmp[1] & MASKA_AVAR_ERROR_1) != 0) ||
    420                  ((diagnostyka_tmp[2] & MASKA_AVAR_ERROR_2) != 0)
    421                 )   
    422              {
    423                _SET_BIT(fix_block_active_state, FIX_BLOCK_AVAR_DEFECT);
    424              }
    425              else
    426              {
    427                _CLEAR_BIT(fix_block_active_state, FIX_BLOCK_AVAR_DEFECT);
    428              }
    429              /**************************/
    430            }
    431            else
    432            {
    433              _CLEAR_BIT(fix_block_active_state, FIX_BLOCK_DEFECT);
    434              _CLEAR_BIT(fix_block_active_state, FIX_BLOCK_AVAR_DEFECT);
    435            }
    436            /**************************/
    437          
    438            
    439            //Логічні схеми мають працювати тільки у тому випадку, якщо немє сигналу "Аварийная неисправность"
    440            if (_CHECK_SET_BIT(fix_block_active_state, FIX_BLOCK_AVAR_DEFECT) == 0)
    441            {
    442              //Аварійна ситуація не зафіксована
    443          
    444            }
    445            else
    446            {
    447              //Аварійна ситуація зафіксована
    448              
    449              //Скидаємо всі активні функції, крім інформативних
    450              
    451              //Деактивовуємо всі реле
    452              
    453              //Скидаємо всі таймери, які присутні у лозіці
    454              
    455            }
    456          
    457            /**************************/
    458            //Робота з функціями, які мають записуватися у енергонезалежну пам'ять
    459            /**************************/
    460          //  unsigned int comparison_true = true;
    461          //
    462          //  if (comparison_true != true)
    463          //  {
    464          //    /*
    465          //    Сигнали, значення яких записується у енергонезалежну пам'1ять змінилися.
    466          //    Подаємо команду на їх запис у енергонезалежну пам'ять
    467          //    */
    468          //    _SET_BIT(control_i2c_taskes, TASK_START_WRITE_TRG_FUNC_EEPROM_BIT);
    469          //  }
    470            /**************************/
    471            /**************************/
    472          
    473            /**************************/
    474            //Вивід інформації на виходи
    475            /**************************/
    476            
    477            if (_CHECK_SET_BIT(fix_block_active_state, FIX_BLOCK_AVAR_DEFECT) == 0)
    478            {
    479              //Не зафіксовано аварійної ситуації, тому встановлювати реле можна
    480              
    481            }
    482            else
    483            {
    484              //Зафіксовано аварійнe ситуацію, тому деактивуємо всі реле!!!
    485          
    486              //Деактивовуємо всі реле
    487            }
    488            
    489            //Виводимо інформацію по виходах на піни процесора (у зворотньому порядку)
    490            unsigned int temp_state_outputs = 0;
    491          //  for (unsigned int index = 0; index < NUMBER_OUTPUTS; index++)
    492          //  {
    493          //    if ((state_outputs & (1 << index)) != 0)
    494          //    {
    495          //      if (index < NUMBER_OUTPUTS_1)
    496          //        temp_state_outputs |= 1 << (NUMBER_OUTPUTS_1 - index - 1);
    497          //      else
    498          //        temp_state_outputs |= 1 << index;
    499          //    }
    500          //  }
    501            unsigned int temp_state_outputs_1 =  temp_state_outputs                      & ((1 << NUMBER_OUTPUTS_1) - 1);
    502            unsigned int temp_state_outputs_2 = (temp_state_outputs >> NUMBER_OUTPUTS_1) & ((1 << NUMBER_OUTPUTS_2) - 1);
    503            _DEVICE_REGISTER(Bank1_SRAM2_ADDR, OFFSET_OUTPUTS_1) = temp_state_outputs_1;
    504            _DEVICE_REGISTER(Bank1_SRAM2_ADDR, OFFSET_OUTPUTS_2) = temp_state_outputs_2;
    505            /**************************/
    506          
    507            /**************************/
    508            //Вивід інформації на світлодіоди
    509            /**************************/
    510            //Спочатку перевіряємо, чи не активовувалвся команда "Сблос индикации" - і якщо так, то попередньо скидаємо всю індикацію
    511            
    512            //Виводимо інформацію по світлоіндикаторах на світлодіоди
    513          //  _DEVICE_REGISTER(Bank1_SRAM2_ADDR, OFFSET_LEDS) = state_leds;
    514            /**************************/
    515          
    516            /**************************/
    517            //
    518            /**************************/
    519            /**************************/
    520          }
    521          /*****************************************************/
    522          
    523          /*****************************************************/
    524          //Переривання від таймеру TIM2, який обслуговує систему захистів
    525          /*****************************************************/
    526          void TIM2_IRQHandler(void)
    527          {
    528          #ifdef SYSTEM_VIEWER_ENABLE
    529            SEGGER_SYSVIEW_RecordEnterISR();
    530          #endif
    531            
    532            if (TIM_GetITStatus(TIM2, TIM_IT_CC1) != RESET)
    533            {
    534              /***********************************************************************************************/
    535              //Переривання відбулося вік каналу 1, який генерує переривання кожні 1 мс, для опраціьовування таймерів і систем захистів
    536              /***********************************************************************************************/
    537              TIM2->SR = (uint16_t)((~(uint32_t)TIM_IT_CC1) & 0xffff);
    538              uint32_t current_tick = TIM2->CCR1;
    539              
    540              /***********************************************************/
    541              //Опрцювання логічних тайменрів і дискретних входів тільки коли настройки успішно прочитані
    542              /***********************************************************/
    543              clocking_global_timers();
    544              /***********************************************************/
    545              
    546              /***********************************************************/
    547              //Опрцювання функцій захистів
    548              /***********************************************************/
    549          //    //Діагностика вузлів, яку треба проводити кожен раз перед початком опрацьовуванням логіки пристрою
    550          //    unsigned int control_state_outputs_1 = (( (~((unsigned int)(_DEVICE_REGISTER(Bank1_SRAM2_ADDR, OFFSET_OUTPUTS_1)))) >> 8) & ((1 << NUMBER_OUTPUTS_1) - 1));
    551          //    unsigned int control_state_outputs_2 = (( (~((unsigned int)(_DEVICE_REGISTER(Bank1_SRAM2_ADDR, OFFSET_OUTPUTS_2)))) >> 8) & ((1 << NUMBER_OUTPUTS_2) - 1));
    552          //    unsigned int control_state_outputs = control_state_outputs_1 | (control_state_outputs_2 << NUMBER_OUTPUTS_1);
    553          //    //Формуємо стани виходів у відповідності до зміненої нумерації
    554          //    unsigned int temp_state_outputs = 0;
    555          //    for (unsigned int index = 0; index < NUMBER_OUTPUTS; index++)
    556          //    {
    557          //      if ((state_outputs & (1 << index)) != 0) 
    558          //      {
    559          //        if (index < NUMBER_OUTPUTS_1)
    560          //          temp_state_outputs |= 1 << (NUMBER_OUTPUTS_1 - index - 1);
    561          //        else
    562          //          temp_state_outputs |= 1 << index;
    563          //      }
    564          //    }
    565          //    if (control_state_outputs != temp_state_outputs) _SET_BIT(set_diagnostyka, ERROR_DIGITAL_OUTPUTS_BIT);
    566          ////    else _SET_BIT(clear_diagnostyka, ERROR_DIGITAL_OUTPUTS_BIT);
    567              
    568              //Функції захистів
    569              main_protection();
    570              /***********************************************************/
    571          
    572              /***********************************************************/
    573              //Перевірка на необхідність зроботи резервні копії даних для самоконтролю
    574              /***********************************************************/
    575              //Триґерна інформація
    576          //    if (periodical_tasks_TEST_TRG_FUNC != 0)
    577          //    {
    578          //      //Стоїть у черзі активна задача зроботи резервні копії даних
    579          //      if ((state_i2c_task & STATE_TRG_FUNC_EEPROM_GOOD) != 0)
    580          //      {
    581          //        //Робимо копію тільки тоді, коли триґерна інформація успішно зчитана і сформована контрольна сума
    582          //        if (
    583          //            (_CHECK_SET_BIT(control_i2c_taskes, TASK_START_WRITE_TRG_FUNC_EEPROM_BIT) == 0) &&
    584          //            (_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_TRG_FUNC_EEPROM_BIT    ) == 0) &&
    585          //            (_CHECK_SET_BIT(control_i2c_taskes, TASK_START_READ_TRG_FUNC_EEPROM_BIT ) == 0) &&
    586          //            (_CHECK_SET_BIT(control_i2c_taskes, TASK_READING_TRG_FUNC_EEPROM_BIT    ) == 0)
    587          //           ) 
    588          //        {
    589          //          //На даний моммент не іде читання-запис триґерної інформації, тому можна здійснити копіювання
    590          //          for (unsigned int i = 0; i < N_BIG; i++) trigger_active_functions_ctrl[i] = trigger_active_functions[i];
    591          //          crc_trg_func_ctrl = crc_trg_func;
    592          //
    593          //          //Скидаємо активну задачу формування резервної копії 
    594          //          periodical_tasks_TEST_TRG_FUNC = false;
    595          //          //Виставляємо активну задачу контролю достовірності по резервній копії 
    596          //          periodical_tasks_TEST_TRG_FUNC_LOCK = true;
    597          //        }
    598          //      }
    599          //      else
    600          //      {
    601          //        //Скидаємо активну задачу формування резервної копії 
    602          //        periodical_tasks_TEST_TRG_FUNC = false;
    603          //      }
    604          //    }
    605              /***********************************************************/
    606          
    607              /***********************************************************/
    608              //Встановлюємо "значення лічильника для наступного переривання"
    609              /***********************************************************/
    610              uint32_t capture_new;
    611              unsigned int delta;
    612              TIM2->CCR1 = (capture_new = (current_tick + (delta = TIM2_CCR1_VAL)));
    613              
    614              unsigned int repeat;
    615              unsigned int previous_tick;
    616              do
    617              {
    618                repeat = 0;
    619                current_tick = TIM2->CNT;
    620          
    621                uint64_t delta_time = 0;
    622                if (capture_new < current_tick)
    623                  delta_time = capture_new + 0x100000000 - current_tick;
    624                else delta_time = capture_new - current_tick;
    625          
    626                if ((delta_time > delta) || (delta_time == 0))
    627                {
    628                  if (TIM_GetITStatus(TIM2, TIM_IT_CC1) == RESET)
    629                  {
    630                    if (delta < TIM2_CCR1_VAL)
    631                    {
    632                      uint64_t delta_tick;
    633                      if (current_tick < previous_tick)
    634                        delta_tick = current_tick + 0x100000000 - previous_tick;
    635                      else delta_tick = current_tick - previous_tick;
    636                        
    637                      delta = delta_tick + 1;
    638                    }
    639                    else if (delta == TIM2_CCR1_VAL)
    640                      delta = 1; /*Намагаємося, щоб нове переивання запустилося як омога скоріше*/
    641                    else
    642                    {
    643                      //Теоретично цього ніколи не мало б бути
    644                      total_error_sw_fixed(83);
    645                    }
    646                    TIM2->CCR1 = (capture_new = (TIM2->CNT +  delta));
    647                    previous_tick = current_tick;
    648                    repeat = 0xff;
    649                  }
    650                }
    651              }
    652              while (repeat != 0);
    653              /***********************************************************/
    654              
    655              /***********************************************************/
    656              //Виставляємо повідомлення про те, система захисів праціює
    657              /***********************************************************/
    658              control_word_of_watchdog |= WATCHDOG_PROTECTION;
    659              /***********************************************************/
    660              /***********************************************************************************************/
    661            }
    662            else
    663            {
    664              total_error_sw_fixed(23);
    665            }
    666            
    667          #ifdef SYSTEM_VIEWER_ENABLE
    668            SEGGER_SYSVIEW_RecordExitISR();
    669          #endif
    670          }
    671          /*****************************************************/
    672          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      56   TIM2_IRQHandler
        56   -> SEGGER_SYSVIEW_RecordEnterISR
        56   -> SEGGER_SYSVIEW_RecordExitISR
        56   -> TIM_GetITStatus
        56   -> clocking_global_timers
        56   -> main_protection
        56   -> total_error_sw_fixed
      56   calc_measurement
        56   -> __aeabi_f2uiz
        56   -> __aeabi_fdiv
        56   -> __aeabi_fmul
        56   -> __aeabi_ul2f
        56   -> sqrt_64
       8   clocking_global_timers
         8   -> input_scan
       0   diagnostyca_adc_execution
      24   input_scan
      24   main_protection
        24   -> DoCalcWrp
        24   -> RdHrdIn
        24   -> SetHrdLed
        24   -> SetHrdOut
        24   -> TmrCalls
        24   -> calc_measurement
        24   -> diagnostyca_adc_execution
       8   norma_value
      40   sqrt_64
        40   -> norma_value


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
       4  ??DataTable0_3
     274  TIM2_IRQHandler
     128  calc_measurement
      60  clocking_global_timers
     156  diagnostyca_adc_execution
     300  input_scan
     468  main_protection
      50  norma_value
     102  sqrt_64
       4  state_inputs_into_pin_trigger

 
     4 bytes in section .bss
 1 554 bytes in section .text
 
 392 bytes of CODE memory (+ 1 162 bytes shared)
   0 bytes of DATA memory (+     4 bytes shared)

Errors: none
Warnings: none
