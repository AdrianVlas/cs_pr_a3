###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       24/Mar/2017  12:55:00
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\start_settings.c
#    Command line =  
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\start_settings.c" -D USE_STDPERIPH_DRIVER -D STM32F2XX -D
#        USE_USB_OTG_FS -D KEYBOARD_VER_1 -D SYSTEM_VIEWER_ENABLE -lc
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List" --remarks -o
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --enable_multibytes --fpu=None
#        --dlib_config G:\PRG\IAR7_50_2\arm\INC\c\DLib_Config_Full.h -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\usb\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_OTG_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Core\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\"
#        -I "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\Config\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\OS\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\SEGGER\" -On --use_c++_inline
#        --require_prototypes -I G:\PRG\IAR7_50_2\arm\CMSIS\Include\ -D
#        ARM_MATH_CM3
#    List file    =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List\start_settings.lst
#    Object file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj\start_settings.o
#
###############################################################################

G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working files\src\start_settings.c
      1          #include "header.h"
      2          
      3          
      4          /**************************************/
      5          //Тестування зовнішньої SRAM
      6          /**************************************/
      7          inline void test_external_SRAM(void)
      8          {
      9            //Визнапчаємо кількість двохбайтих слів
     10            unsigned int size_SRAM_word = (((unsigned int)&__ICFEDIT_region_RAM1_size__) + 1) >> 1;
     11            
     12            //Визначаємо вказівник на початок зовнішньої оперативної пам'яті
     13             unsigned short int *point = ((unsigned short int *)&__ICFEDIT_region_RAM1_start__);
     14            
     15            //Заповнюємо кожну комірку зовнішьої оперативної пам'яті її адресою
     16            for (unsigned int i = 0; i < size_SRAM_word; i++) *point++ = (unsigned short int)(i & 0xffff);
     17            
     18            //Перевіряємо зчитуванням, чи у всіх комірках прописані ті числа, які ми попередньо записали
     19            unsigned int error = 0, i = 0;
     20            point = ((unsigned short int *)&__ICFEDIT_region_RAM1_start__);
     21            while((i < size_SRAM_word) && (error == 0))
     22            {
     23              if ((*point) == ((unsigned short int)(i & 0xffff)))
     24              {
     25                //Тест даної комірки пройшов вдало
     26                i++;
     27                *point++ = 0;
     28              }
     29              else
     30              {
     31                //Тест даної комірки не пройшов вдало
     32                
     33                error = 0xff;
     34                //Виставляємо повідомлення про помилку тесту зовнішьої оперативної пам'яті
     35                _SET_BIT(set_diagnostyka, ERROR_EXTERNAL_SRAM_BIT);
     36              }
     37            }
     38          }
     39          /**************************************/
     40          
     41          /**************************************/
     42          //Стартова ініціалізація змінниз
     43          /**************************************/
     44          void global_vareiables_installation(void)
     45          {
     46            /**************************/
     47            //Вимірювальна система
     48            /**************************/
     49            for (unsigned int i = 0; i < NUMBER_INPUTs_ADCs; i++)
     50            {
     51              output_adc[i].tick = 0;
     52              output_adc[i].value = 0;
     53            }
     54            
     55            for (unsigned int i = 0; i < NUMBER_GND_ADC; i++)
     56            {
     57              for(unsigned int j = 0; j < NUMBER_POINT; j++)
     58              {
     59                gnd_adc_moment_value[i][j] = GND_NORMAL_VALUE;
     60              }
     61              gnd_adc_averange_sum[i] = GND_NORMAL_VALUE*NUMBER_POINT;
     62              gnd_adc_averange[i] = GND_NORMAL_VALUE;
     63            }
     64            gnd_adc = GND_NORMAL_VALUE;
     65          
     66            for(unsigned int i = 0; i < NUMBER_POINT; i++)
     67            {
     68              vref_adc_moment_value[i] = VREF_NORMAL_VALUE;
     69              vdd_adc_moment_value[i] = VDD_NORMAL_VALUE;
     70          
     71              vref_adc_moment_value[i] = VREF_NORMAL_VALUE;
     72              vdd_adc_moment_value[i] = VDD_NORMAL_VALUE;
     73            }
     74            
     75            for(unsigned int i=0; i<(NUMBER_ANALOG_CANALES*NUMBER_POINT*NUMBER_PERIOD_TRANSMIT); i++)
     76              current_data[i] = 0;
     77            
     78            for(unsigned int i=0; i<NUMBER_ANALOG_CANALES; i++)
     79            {
     80              ADCs_data_raw[i].tick = 0;
     81              ADCs_data_raw[i].value = 0;
     82                
     83              ustuvannja_meas[i] = ustuvannja[i] = DEFAULT_USTUVANNJA_VALUE;
     84            }
     85          
     86            /**************************/
     87          
     88            /**************************/
     89            //Ініціалізація глобальних таймерів
     90            /**************************/
     91            for(unsigned int i = 0; i < MAX_NUMBER_GLOBAL_TIMERS; i++) global_timers[i] = -1;
     92            /**************************/
     93          
     94            /**************************/
     95            //
     96            /**************************/
     97            /**************************/
     98          
     99            for(unsigned int i = 0; i < MAX_ROW_LCD; i++)
    100            {
    101              for (unsigned int j = 0; j < MAX_COL_LCD; j++) working_ekran[i][j] = ' ';
    102            }
    103            for (unsigned int i=0; i<NUMBER_KEY_KEYBOARD; i++) time_set_keyboard[i] = 0;
    104           
    105            for(enum _menu2_levels i = MAIN_MANU2_LEVEL; i < MAX_NUMBER_MENU2_LEVEL; i++)
    106            {
    107              if ((i == PASSWORD_MENU2_LEVEL) || (i == SET_NEW_PASSWORD_MENU2_LEVEL)) position_in_current_level_menu2[i] = INDEX_PASSWORD_M2_LINE1;
    108              else  position_in_current_level_menu2[i] = 0;
    109            }
    110            
    111            //Визначення початкового стану екрану
    112            current_state_menu2.current_level = MAIN_MANU2_LEVEL;
    113            current_state_menu2.index_position = position_in_current_level_menu2[current_state_menu2.current_level];
    114            current_state_menu2.position_cursor_y = current_state_menu2.index_position;
    115            current_state_menu2.p_max_row = NULL;
    116            current_state_menu2.max_row = MAX_ROW_MAIN_M2;
    117            current_state_menu2.func_move = move_into_main;
    118            current_state_menu2.func_show = make_ekran_main;
    119            current_state_menu2.func_press_enter = press_enter_in_main_and_list_passwords;
    120            current_state_menu2.func_press_esc = NULL;
    121            current_state_menu2.func_change = NULL;
    122            current_state_menu2.binary_data = false;
    123            current_state_menu2.edition = ED_VIEWING;
    124          
    125            time[0] = 0x0;
    126            time[1] = 0x0;
    127            time[2] = 0x0;
    128            time[3] = 0x0;
    129            time[4] = 0x0;
    130            time[5] = 0x0;
    131            time[6] = 0x0;
    132            calibration = 0;
    133          
    134            time_copy[0] = 0x0;
    135            time_copy[1] = 0x0;
    136            time_copy[2] = 0x0;
    137            time_copy[3] = 0x0;
    138            time_copy[4] = 0x0;
    139            time_copy[5] = 0x0;
    140            time_copy[6] = 0x0;
    141            calibration_copy = 0;
    142            
    143            /**************************/
    144            //Ініціалізація структури усправління драйвером I2C
    145            /**************************/
    146            //Стан обміну
    147            driver_i2c.state_execution = -1;
    148            //Ідентифікатор пристрою, з яким ведетьсяобмін
    149            driver_i2c.device_id = -1;
    150            //Код операції
    151            driver_i2c.action =- 1;
    152            //Значення решти полів поки не грає ролі 
    153            /**************************/
    154          }
    155          /**************************************/
    156          
    157          /**************************************/
    158          //Конфігурація I2C
    159          /**************************************/
    160          void Configure_I2C(I2C_TypeDef* I2Cx)
    161          {
    162            I2C_InitTypeDef  I2C_InitStructure;
    163            GPIO_InitTypeDef GPIO_InitStructure;
    164            uint16_t current_count_tim4, new_count_tim4;
    165            unsigned int delta;
    166          
    167            /* Забороняємо I2C  */
    168            I2C_Cmd(I2Cx, DISABLE);
    169          
    170            /***
    171            Добиваємося, щоб на SDA встановилася 1
    172            ***/
    173            /* Настроюємо I2C піни SCL Output Open-drain */
    174            GPIO_InitStructure.GPIO_Pin = GPIO_I2C_SCL;
    175            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    176            GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
    177            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    178            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    179            GPIO_Init(GPIO_I2C, &GPIO_InitStructure);
    180            /* Встановлюємо піни SCL у високий рівень*/
    181            GPIO_SetBits(GPIO_I2C, GPIO_I2C_SCL);
    182            while(GPIO_ReadOutputDataBit(GPIO_I2C, GPIO_I2C_SCL) == Bit_RESET);
    183          
    184            /*Настроюємо I2C піни SDA  на ввід*/
    185            GPIO_InitStructure.GPIO_Pin = GPIO_I2C_SDA;
    186            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    187            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    188            GPIO_Init(GPIO_I2C, &GPIO_InitStructure);
    189            
    190            while(GPIO_ReadInputDataBit(GPIO_I2C, GPIO_I2C_SDA) == RESET)
    191            {
    192              /* SCL -> "0" */
    193              GPIO_ResetBits(GPIO_I2C, GPIO_I2C_SCL);
    194              current_count_tim4 = ((uint16_t)TIM4->CNT);
    195              delta = 0;
    196              while (delta < 4) // <= 4x10 = 40(мкс)
    197              {
    198                new_count_tim4 = ((uint16_t)TIM4->CNT);
    199                if (new_count_tim4 >= current_count_tim4) delta = new_count_tim4 - current_count_tim4;
    200                else delta = (0x10000 - current_count_tim4) + new_count_tim4; //0x10000 - це повний період таймера, бо ми настроїли його тактуватиу інтервалі [0; 65535]
    201              }
    202          
    203              /* SCL -> "1" */
    204              GPIO_SetBits(GPIO_I2C, GPIO_I2C_SCL);
    205              while(GPIO_ReadOutputDataBit(GPIO_I2C, GPIO_I2C_SCL) == Bit_RESET);
    206              current_count_tim4 = ((uint16_t)TIM4->CNT);
    207              delta = 0;
    208              while (delta < 4) // <= 4x10 = 40(мкс)
    209              {
    210                new_count_tim4 = ((uint16_t)TIM4->CNT);
    211                if (new_count_tim4 >= current_count_tim4) delta = new_count_tim4 - current_count_tim4;
    212                else delta = (0x10000 - current_count_tim4) + new_count_tim4; //0x10000 - це повний період таймера, бо ми настроїли його тактуватиу інтервалі [0; 65535]
    213              }
    214            }
    215            /*******/
    216            
    217            /***
    218            Переводимо піна під упавління мікроконтролера
    219            ***/
    220            /* Настроюємо I2C пін SDA як Output Open-drain */
    221            GPIO_InitStructure.GPIO_Pin = GPIO_I2C_SDA;
    222            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    223            GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
    224            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    225            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    226            GPIO_Init(GPIO_I2C, &GPIO_InitStructure);
    227            /* Встановлюємо піни SCL і SDA у високий рівень*/
    228            GPIO_SetBits(GPIO_I2C, (GPIO_I2C_SCL | GPIO_I2C_SDA));
    229            while(GPIO_ReadOutputDataBit(GPIO_I2C, GPIO_I2C_SCL) == Bit_RESET);
    230            /*******/
    231            
    232            /***
    233            Симулюємо SOFTWARE RESET для EEPROM: Start + 9-bit + Start + Stop 
    234            ****/
    235          
    236            /*- Start -*/
    237            /*SCL = 1 і SCA = 1*/
    238          
    239            /* SCL -> "0" */
    240            GPIO_ResetBits(GPIO_I2C, GPIO_I2C_SCL);
    241            current_count_tim4 = ((uint16_t)TIM4->CNT);
    242            delta = 0;
    243            while (delta < 2) // <= 2x10 = 20(мкс)
    244            {
    245              new_count_tim4 = ((uint16_t)TIM4->CNT);
    246              if (new_count_tim4 >= current_count_tim4) delta = new_count_tim4 - current_count_tim4;
    247              else delta = (0x10000 - current_count_tim4) + new_count_tim4; //0x10000 - це повний період таймера, бо ми настроїли його тактуватиу інтервалі [0; 65535]
    248            }
    249              
    250            /* SCL -> "1" */
    251            GPIO_SetBits(GPIO_I2C, GPIO_I2C_SCL);
    252            while(GPIO_ReadOutputDataBit(GPIO_I2C, GPIO_I2C_SCL) == Bit_RESET);
    253            current_count_tim4 = ((uint16_t)TIM4->CNT);
    254            delta = 0;
    255            while (delta < 2) // <= 2x10 = 20(мкс)
    256            {
    257              new_count_tim4 = ((uint16_t)TIM4->CNT);
    258              if (new_count_tim4 >= current_count_tim4) delta = new_count_tim4 - current_count_tim4;
    259              else delta = (0x10000 - current_count_tim4) + new_count_tim4; //0x10000 - це повний період таймера, бо ми настроїли його тактуватиу інтервалі [0; 65535]
    260            }
    261            
    262            /* SDA -> "0" */
    263            GPIO_ResetBits(GPIO_I2C, GPIO_I2C_SDA);
    264            current_count_tim4 = ((uint16_t)TIM4->CNT);
    265            delta = 0;
    266            while (delta < 2) // <= 2x10 = 20(мкс)
    267            {
    268              new_count_tim4 = ((uint16_t)TIM4->CNT);
    269              if (new_count_tim4 >= current_count_tim4) delta = new_count_tim4 - current_count_tim4;
    270              else delta = (0x10000 - current_count_tim4) + new_count_tim4; //0x10000 - це повний період таймера, бо ми настроїли його тактуватиу інтервалі [0; 65535]
    271            }
    272          
    273            /* SCL -> "0" */
    274            GPIO_ResetBits(GPIO_I2C, GPIO_I2C_SCL);
    275            current_count_tim4 = ((uint16_t)TIM4->CNT);
    276            delta = 0;
    277            while (delta < 2) // <= 2x10 = 20(мкс)
    278            {
    279              new_count_tim4 = ((uint16_t)TIM4->CNT);
    280              if (new_count_tim4 >= current_count_tim4) delta = new_count_tim4 - current_count_tim4;
    281              else delta = (0x10000 - current_count_tim4) + new_count_tim4; //0x10000 - це повний період таймера, бо ми настроїли його тактуватиу інтервалі [0; 65535]
    282            }
    283            
    284            /* SDA -> "1" */
    285            GPIO_SetBits(GPIO_I2C, GPIO_I2C_SDA);
    286          
    287            /*- 9 циклів -*/
    288            for(unsigned int i = 0; i < 9; i++)
    289            {
    290              /* SCL = "0" */
    291              current_count_tim4 = ((uint16_t)TIM4->CNT);
    292              delta = 0;
    293              while (delta < 2) // <= 2x10 = 20(мкс)
    294              {
    295                new_count_tim4 = ((uint16_t)TIM4->CNT);
    296                if (new_count_tim4 >= current_count_tim4) delta = new_count_tim4 - current_count_tim4;
    297                else delta = (0x10000 - current_count_tim4) + new_count_tim4; //0x10000 - це повний період таймера, бо ми настроїли його тактуватиу інтервалі [0; 65535]
    298              }
    299          
    300              /* SCL -> "1" */
    301              GPIO_SetBits(GPIO_I2C, GPIO_I2C_SCL);
    302              while(GPIO_ReadOutputDataBit(GPIO_I2C, GPIO_I2C_SCL) == Bit_RESET);
    303              current_count_tim4 = ((uint16_t)TIM4->CNT);
    304              delta = 0;
    305              while (delta < 4) // <= 4x10 = 40(мкс)
    306              {
    307                new_count_tim4 = ((uint16_t)TIM4->CNT);
    308                if (new_count_tim4 >= current_count_tim4) delta = new_count_tim4 - current_count_tim4;
    309                else delta = (0x10000 - current_count_tim4) + new_count_tim4; //0x10000 - це повний період таймера, бо ми настроїли його тактуватиу інтервалі [0; 65535]
    310              }
    311          
    312              /* SCL -> "0" */
    313              GPIO_ResetBits(GPIO_I2C, GPIO_I2C_SCL);
    314              current_count_tim4 = ((uint16_t)TIM4->CNT);
    315              delta = 0;
    316              while (delta < 2) // <= 2x10 = 20(мкс)
    317              {
    318                new_count_tim4 = ((uint16_t)TIM4->CNT);
    319                if (new_count_tim4 >= current_count_tim4) delta = new_count_tim4 - current_count_tim4;
    320                else delta = (0x10000 - current_count_tim4) + new_count_tim4; //0x10000 - це повний період таймера, бо ми настроїли його тактуватиу інтервалі [0; 65535]
    321              }
    322            }
    323          
    324            /*- Start -*/
    325            /*SCL = 0 і SCA = 1*/
    326          
    327            current_count_tim4 = ((uint16_t)TIM4->CNT);
    328            delta = 0;
    329            while (delta < 2) // <= 2x10 = 20(мкс)
    330            {
    331              new_count_tim4 = ((uint16_t)TIM4->CNT);
    332              if (new_count_tim4 >= current_count_tim4) delta = new_count_tim4 - current_count_tim4;
    333              else delta = (0x10000 - current_count_tim4) + new_count_tim4; //0x10000 - це повний період таймера, бо ми настроїли його тактуватиу інтервалі [0; 65535]
    334            }
    335              
    336            /* SCL -> "1" */
    337            GPIO_SetBits(GPIO_I2C, GPIO_I2C_SCL);
    338            while(GPIO_ReadOutputDataBit(GPIO_I2C, GPIO_I2C_SCL) == Bit_RESET);
    339            current_count_tim4 = ((uint16_t)TIM4->CNT);
    340            delta = 0;
    341            while (delta < 2) // <= 2x10 = 20(мкс)
    342            {
    343              new_count_tim4 = ((uint16_t)TIM4->CNT);
    344              if (new_count_tim4 >= current_count_tim4) delta = new_count_tim4 - current_count_tim4;
    345              else delta = (0x10000 - current_count_tim4) + new_count_tim4; //0x10000 - це повний період таймера, бо ми настроїли його тактуватиу інтервалі [0; 65535]
    346            }
    347            
    348            /* SDA -> "0" */
    349            GPIO_ResetBits(GPIO_I2C, GPIO_I2C_SDA);
    350            current_count_tim4 = ((uint16_t)TIM4->CNT);
    351            delta = 0;
    352            while (delta < 2) // <= 2x10 = 20(мкс)
    353            {
    354              new_count_tim4 = ((uint16_t)TIM4->CNT);
    355              if (new_count_tim4 >= current_count_tim4) delta = new_count_tim4 - current_count_tim4;
    356              else delta = (0x10000 - current_count_tim4) + new_count_tim4; //0x10000 - це повний період таймера, бо ми настроїли його тактуватиу інтервалі [0; 65535]
    357            }
    358          
    359            /* SCL -> "0" */
    360            GPIO_ResetBits(GPIO_I2C, GPIO_I2C_SCL);
    361            current_count_tim4 = ((uint16_t)TIM4->CNT);
    362            delta = 0;
    363            while (delta < 2) // <= 2x10 = 20(мкс)
    364            {
    365              new_count_tim4 = ((uint16_t)TIM4->CNT);
    366              if (new_count_tim4 >= current_count_tim4) delta = new_count_tim4 - current_count_tim4;
    367              else delta = (0x10000 - current_count_tim4) + new_count_tim4; //0x10000 - це повний період таймера, бо ми настроїли його тактуватиу інтервалі [0; 65535]
    368            }
    369          
    370            /*- Stop -*/
    371            /*SCL = 0 і SCA = 0*/
    372          
    373            current_count_tim4 = ((uint16_t)TIM4->CNT);
    374            delta = 0;
    375            while (delta < 2) // <= 2x10 = 20(мкс)
    376            {
    377              new_count_tim4 = ((uint16_t)TIM4->CNT);
    378              if (new_count_tim4 >= current_count_tim4) delta = new_count_tim4 - current_count_tim4;
    379              else delta = (0x10000 - current_count_tim4) + new_count_tim4; //0x10000 - це повний період таймера, бо ми настроїли його тактуватиу інтервалі [0; 65535]
    380            }
    381              
    382            /* SCL -> "1" */
    383            GPIO_SetBits(GPIO_I2C, GPIO_I2C_SCL);
    384            while(GPIO_ReadOutputDataBit(GPIO_I2C, GPIO_I2C_SCL) == Bit_RESET);
    385            current_count_tim4 = ((uint16_t)TIM4->CNT);
    386            delta = 0;
    387            while (delta < 2) // <= 2x10 = 20(мкс)
    388            {
    389              new_count_tim4 = ((uint16_t)TIM4->CNT);
    390              if (new_count_tim4 >= current_count_tim4) delta = new_count_tim4 - current_count_tim4;
    391              else delta = (0x10000 - current_count_tim4) + new_count_tim4; //0x10000 - це повний період таймера, бо ми настроїли його тактуватиу інтервалі [0; 65535]
    392            }
    393            
    394            /* SDA -> "1" */
    395            GPIO_SetBits(GPIO_I2C, GPIO_I2C_SDA);
    396            current_count_tim4 = ((uint16_t)TIM4->CNT);
    397            delta = 0;
    398            while (delta < 2) // <= 2x10 = 20(мкс)
    399            {
    400              new_count_tim4 = ((uint16_t)TIM4->CNT);
    401              if (new_count_tim4 >= current_count_tim4) delta = new_count_tim4 - current_count_tim4;
    402              else delta = (0x10000 - current_count_tim4) + new_count_tim4; //0x10000 - це повний період таймера, бо ми настроїли його тактуватиу інтервалі [0; 65535]
    403            }
    404          
    405            /* SCL -> "0" */
    406            GPIO_ResetBits(GPIO_I2C, GPIO_I2C_SCL);
    407            current_count_tim4 = ((uint16_t)TIM4->CNT);
    408            delta = 0;
    409            while (delta < 2) // <= 2x10 = 20(мкс)
    410            {
    411              new_count_tim4 = ((uint16_t)TIM4->CNT);
    412              if (new_count_tim4 >= current_count_tim4) delta = new_count_tim4 - current_count_tim4;
    413              else delta = (0x10000 - current_count_tim4) + new_count_tim4; //0x10000 - це повний період таймера, бо ми настроїли його тактуватиу інтервалі [0; 65535]
    414            }
    415          
    416            /* Встановлюємо піни SCL і SDA у високий рівень*/
    417            GPIO_SetBits(GPIO_I2C, (GPIO_I2C_SCL | GPIO_I2C_SDA));
    418            while(GPIO_ReadOutputDataBit(GPIO_I2C, GPIO_I2C_SCL) == Bit_RESET);
    419            /*******/
    420            
    421            /*
    422            Повертаємо піни під управління I2C
    423            */
    424            //Конфігуруємо піни PB8/I2C1_SCL і PB9/I2C1_SDA
    425            GPIO_PinAFConfig(GPIO_I2C, GPIO_I2C_SCLSource, GPIO_AF_I2C);
    426            GPIO_PinAFConfig(GPIO_I2C, GPIO_I2C_SDASource, GPIO_AF_I2C);
    427          
    428            /* Настроюємо I2C піни: SCL і SDA */
    429            GPIO_InitStructure.GPIO_Pin =  GPIO_I2C_SCL | GPIO_I2C_SDA;
    430            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    431            GPIO_InitStructure.GPIO_OType = GPIO_OType_OD;
    432            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    433            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    434            GPIO_Init(GPIO_I2C, &GPIO_InitStructure);
    435            /*******/
    436          
    437            /* Скидаємо всі I2C регістри */
    438            I2C_SoftwareResetCmd(I2Cx, ENABLE);
    439            I2C_SoftwareResetCmd(I2Cx, DISABLE);
    440          
    441            /* Дозволяємо I2C*/
    442            I2C_Cmd(I2Cx, ENABLE);
    443          
    444          
    445            I2C_InitStructure.I2C_Mode = I2C_Mode_I2C;
    446            I2C_InitStructure.I2C_DutyCycle = I2C_DutyCycle_2;
    447            I2C_InitStructure.I2C_OwnAddress1 = EEPROM_ADDRESS;
    448            I2C_InitStructure.I2C_Ack = I2C_Ack_Enable;
    449            I2C_InitStructure.I2C_AcknowledgedAddress = I2C_AcknowledgedAddress_7bit;
    450            I2C_InitStructure.I2C_ClockSpeed = (low_speed_i2c == 0 ) ? CLOCKSPEED_1MBIT : CLOCKSPEED;
    451            I2C_Init(I2Cx, &I2C_InitStructure);
    452          
    453            /* Дозволяємо для I2C генерацію переривань по помилках */
    454            I2C_ITConfig(I2Cx, I2C_IT_ERR, ENABLE);
    455          }
    456          /**************************************/
    457          
    458          /**************************************/
    459          //Стартова ініціалізація периферії процесора
    460          /**************************************/
    461          void start_settings_peripherals(void)
    462          {
    463            /**********************/
    464            //Настроювання мікроконтролера: ядра + периферії
    465            /**********************/
    466            Set_System();
    467            /**********************/
    468          
    469            /**********************/
    470            //Настроюємо DBG модуль
    471            /**********************/
    472            DBGMCU_APB1PeriphConfig(DBGMCU_TIM2_STOP | DBGMCU_TIM5_STOP | DBGMCU_TIM4_STOP | DBGMCU_I2C1_SMBUS_TIMEOUT, ENABLE);
    473            /**********************/
    474          
    475            /**********************/
    476            //Настроювання переривань
    477            /**********************/
    478            Interrupts_Config();
    479            /**********************/
    480          
    481            /**********************/
    482            //Настроювання зовнішню шину
    483            /**********************/
    484            FSMC_SRAM_Init();
    485            _DEVICE_REGISTER(Bank1_SRAM2_ADDR, OFFSET_OUTPUTS_1) = 0;
    486            _DEVICE_REGISTER(Bank1_SRAM2_ADDR, OFFSET_OUTPUTS_2) = 0;
    487            _DEVICE_REGISTER(Bank1_SRAM2_ADDR, OFFSET_LEDS) = 0;
    488            /**********************/
    489          
    490            /**********************/
    491            //Настроювання пінів процесора
    492            /**********************/
    493            GPIO_InitTypeDef GPIO_InitStructure;
    494          
    495            /**************/
    496            //Піни на вивід
    497            /**************/
    498            /* Пін зовнішнього Watchdog, як Output push-pull */
    499            GPIO_InitStructure.GPIO_Pin = GPIO_PIN_EXTERNAL_WATCHDOG;
    500            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_OUT;
    501            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    502            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    503            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    504            GPIO_Init(GPIO_EXTERNAL_WATCHDOG, &GPIO_InitStructure);
    505            /* Знімаємо пін зовнішнього Watchdog */
    506            GPIO_ResetBits(GPIO_EXTERNAL_WATCHDOG, GPIO_PIN_EXTERNAL_WATCHDOG);
    507            
    508            /*
    509            Виконуємо стартову ініціалізацію змінних? а потім скидаємо Watchdog
    510            Після цього продовжуємо настройку периферії
    511            
    512            Це потрібно, щоб уникнути перезапуску приладу
    513            */
    514            /**********************/
    515            //Тестуємо зовнішню SRAM
    516            /**********************/
    517            test_external_SRAM();
    518            /**********************/
    519            
    520            //Змінюємо стан біту зовнішнього Watchdog на протилежний
    521            GPIO_WriteBit(
    522                          GPIO_EXTERNAL_WATCHDOG,
    523                          GPIO_PIN_EXTERNAL_WATCHDOG,
    524                          (BitAction)(1 - GPIO_ReadOutputDataBit(GPIO_EXTERNAL_WATCHDOG, GPIO_PIN_EXTERNAL_WATCHDOG))
    525                         );
    526              
    527            /**********************/
    528            //Стартова ініціалізація змінних у зовнішіній і у внітрішній SRAM
    529            /**********************/
    530            global_vareiables_installation();
    531            /**********************/
    532              
    533            //Змінюємо стан біту зовнішнього Watchdog на протилежний
    534            GPIO_WriteBit(
    535                          GPIO_EXTERNAL_WATCHDOG,
    536                          GPIO_PIN_EXTERNAL_WATCHDOG,
    537                          (BitAction)(1 - GPIO_ReadOutputDataBit(GPIO_EXTERNAL_WATCHDOG, GPIO_PIN_EXTERNAL_WATCHDOG))
    538                         );
    539            /*****/ 
    540          
    541            /*
    542            Продовжуємо виконувати ініціалізацію периферії  
    543            */
    544              
    545            /* Конфігурація піну CON-L, як Output push-pull */
    546            GPIO_InitStructure.GPIO_Pin = CON_L_PIN;
    547            GPIO_Init(CON_L, &GPIO_InitStructure);
    548            /* Скидаємо пін CON-L, щоб покищо управляти свтоіндикаторами не можна було*/
    549            GPIO_ResetBits(CON_L, CON_L_PIN);
    550          
    551            /* Конфігурація піну CON-OUTPUTS, як Output push-pull */
    552            GPIO_InitStructure.GPIO_Pin = CON_1_OUTPUTS_PIN;
    553            GPIO_Init(CON_OUTPUTS, &GPIO_InitStructure);
    554            /* Знімаємо пін CON-OUTPUTS-1, щоб покищо управляти виходами не можна було*/
    555            GPIO_ResetBits(CON_OUTPUTS, CON_1_OUTPUTS_PIN);
    556          
    557            GPIO_InitStructure.GPIO_Pin = CON_2_OUTPUTS_PIN;
    558            GPIO_Init(CON_OUTPUTS, &GPIO_InitStructure);
    559            /* Знімаємо пін CON-OUTPUTS-2, щоб покищо управляти виходамии не можна було*/
    560            GPIO_ResetBits(CON_OUTPUTS, CON_2_OUTPUTS_PIN);
    561          
    562            GPIO_InitStructure.GPIO_Pin = CON_3_OUTPUTS_PIN;
    563            GPIO_Init(CON_OUTPUTS, &GPIO_InitStructure);
    564            /* Знімаємо пін CON-OUTPUTS-3, щоб покищо управляти виходами не можна було*/
    565            GPIO_ResetBits(CON_OUTPUTS, CON_3_OUTPUTS_PIN);
    566            
    567            /* Конфігурація піну LCD-BL, як Output push-pull */
    568            GPIO_InitStructure.GPIO_Pin = LCD_BL_PIN;
    569            GPIO_Init(LCD_BL, &GPIO_InitStructure);
    570            /* Виставляємоо пін LCD-BL для того, щоб включити підсвітку LCD*/
    571            GPIO_SetBits(LCD_BL, LCD_BL_PIN);
    572          
    573            /* Конфігурація піну LCD-R/W, як Output push-pull */
    574            GPIO_InitStructure.GPIO_Pin = LCD_RW_PIN;
    575            GPIO_Init(LCD_RW, &GPIO_InitStructure);
    576            /* Знімаємо пін LCD-R/W*/
    577            GPIO_ResetBits(LCD_RW, LCD_RW_PIN);
    578          
    579            /* Конфігурація піну LCD-RS, як Output push-pull */
    580            GPIO_InitStructure.GPIO_Pin = LCD_RS_PIN;
    581            GPIO_Init(LCD_RS, &GPIO_InitStructure);
    582            /* Знімаємо пін LCD-RS*/
    583            GPIO_ResetBits(LCD_RS, LCD_RS_PIN);
    584          
    585            /*SW_1 клавіатури */
    586            GPIO_InitStructure.GPIO_Pin = KEYBOARD_SW_1_PIN;
    587            GPIO_Init(KEYBOARD, &GPIO_InitStructure);
    588            /* Виставляємо пін SW1*/
    589            GPIO_SetBits(KEYBOARD, KEYBOARD_SW_1_PIN);
    590          
    591            /*SW_2 клавіатури */
    592            GPIO_InitStructure.GPIO_Pin = KEYBOARD_SW_2_PIN;
    593            GPIO_Init(KEYBOARD, &GPIO_InitStructure);
    594            /* Виставляємо пін SW2*/
    595            GPIO_SetBits(KEYBOARD, KEYBOARD_SW_2_PIN);
    596          
    597            /*SW_3 клавіатури */
    598            GPIO_InitStructure.GPIO_Pin = KEYBOARD_SW_3_PIN;
    599            GPIO_Init(KEYBOARD, &GPIO_InitStructure);
    600            /*Виставляємо пін SW3*/
    601            GPIO_SetBits(KEYBOARD, KEYBOARD_SW_3_PIN);
    602          
    603            /*SW_4 клавіатури */
    604            GPIO_InitStructure.GPIO_Pin = KEYBOARD_SW_4_PIN;
    605            GPIO_Init(KEYBOARD, &GPIO_InitStructure);
    606            /*Виставляємо пін SW4*/
    607            GPIO_SetBits(KEYBOARD, KEYBOARD_SW_4_PIN);
    608          
    609            /*Вибір АЦП */
    610            GPIO_InitStructure.GPIO_Pin = GPIO_SELECTPin_ADC;
    611            GPIO_Init(GPIO_SELECT_ADC, &GPIO_InitStructure);
    612            GPIO_ResetBits(GPIO_SELECT_ADC, GPIO_SELECTPin_ADC);
    613          
    614            /*NSS_ADC каналу SPI_ADC */
    615            GPIO_InitStructure.GPIO_Pin = GPIO_NSSPin_ADC;
    616            GPIO_Init(GPIO_SPI_ADC, &GPIO_InitStructure);
    617            GPIO_SetBits(GPIO_SPI_ADC, GPIO_NSSPin_ADC);
    618          
    619            /*NSS_ADC каналу SPI_DF */
    620            GPIO_InitStructure.GPIO_Pin = GPIO_NSSPin_DF;
    621            GPIO_Init(GPIO_SPI_DF, &GPIO_InitStructure);
    622            GPIO_SetBits(GPIO_SPI_DF, GPIO_NSSPin_DF);
    623          
    624            /*GPIO_SPI_DF_TOGGLE - вибір мікросхеми DataFlash*/
    625            GPIO_InitStructure.GPIO_Pin = GPIO_SPI_DF_TOGGLE_Pin;
    626            GPIO_Init(GPIO_SPI_DF_TOGGLE, &GPIO_InitStructure);
    627            /*Вибираємо мікросхему з 1МБ*/
    628            GPIO_SetBits(GPIO_SPI_DF_TOGGLE, GPIO_SPI_DF_TOGGLE_Pin);
    629          
    630            /* Пін 485DE*/
    631            GPIO_InitStructure.GPIO_Pin = GPIO_PIN_485DE;
    632            GPIO_Init(GPIO_485DE, &GPIO_InitStructure);
    633            /* Знімаємо пін 485DE */
    634            GPIO_ResetBits(GPIO_485DE, GPIO_PIN_485DE);
    635            /**************/
    636          
    637            /**************/
    638            //Піни на ввід
    639            /**************/
    640            /*SW_A клавіатури */
    641            GPIO_InitStructure.GPIO_Pin = KEYBOARD_SW_A_PIN;
    642            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN;
    643            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    644            GPIO_Init(KEYBOARD_SW_A, &GPIO_InitStructure);
    645          
    646            /*SW_B клавіатури */
    647            GPIO_InitStructure.GPIO_Pin = KEYBOARD_SW_B_PIN;
    648            GPIO_Init(KEYBOARD_SW_B, &GPIO_InitStructure);
    649          
    650            /*SW_C клавіатури */
    651            GPIO_InitStructure.GPIO_Pin = KEYBOARD_SW_C_PIN;
    652            GPIO_Init(KEYBOARD_SW_C, &GPIO_InitStructure);
    653          
    654            /*Контроль живлення */
    655            GPIO_InitStructure.GPIO_Pin = POWER_CTRL_PIN;
    656            GPIO_Init(POWER_CTRL, &GPIO_InitStructure);
    657            /**************/
    658          
    659            /**************/
    660            //Піни альтернативних функцій
    661            /**************/
    662            //Перекидаємо піни PB13/SPI2_SCK, PB14/SPI2_MISO і  PB15/SPI2_MOSI
    663            GPIO_PinAFConfig(GPIO_SPI_ADC, GPIO_SCKPin_ADCSource, GPIO_AF_SPI_ADC);
    664            GPIO_PinAFConfig(GPIO_SPI_ADC, GPIO_MISOPin_ADCSource, GPIO_AF_SPI_ADC);
    665            GPIO_PinAFConfig(GPIO_SPI_ADC, GPIO_MOSIPin_ADCSource, GPIO_AF_SPI_ADC);
    666          
    667            /* Configure SPI_ADC SCK, MISO і MOSI */
    668            GPIO_InitStructure.GPIO_Pin = GPIO_SCKPin_ADC | GPIO_MISOPin_ADC | GPIO_MOSIPin_ADC;
    669            GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF;
    670            GPIO_InitStructure.GPIO_OType = GPIO_OType_PP;
    671            GPIO_InitStructure.GPIO_PuPd = GPIO_PuPd_NOPULL;
    672            GPIO_InitStructure.GPIO_Speed = GPIO_Speed_100MHz;
    673            GPIO_Init(GPIO_SPI_ADC, &GPIO_InitStructure);
    674          
    675            //Перекидаємо піни PA5/SPI1_SCK, PA6/SPI1_MISO і  PA7/SPI1_MOSI
    676            GPIO_PinAFConfig(GPIO_SPI_DF, GPIO_SCKPin_DFSource, GPIO_AF_SPI_DF);
    677            GPIO_PinAFConfig(GPIO_SPI_DF, GPIO_MISOPin_DFSource, GPIO_AF_SPI_DF);
    678            GPIO_PinAFConfig(GPIO_SPI_DF, GPIO_MOSIPin_DFSource, GPIO_AF_SPI_DF);
    679          
    680            /* Configure SPI_DF SCK, MISO і MOSI */
    681            GPIO_InitStructure.GPIO_Pin = GPIO_SCKPin_DF | GPIO_MISOPin_DF | GPIO_MOSIPin_DF;
    682            GPIO_Init(GPIO_SPI_DF, &GPIO_InitStructure);
    683          
    684            //Перекидаємо піни PA2/Tx_RS-485, PA3/Rx_RS-485
    685            GPIO_PinAFConfig(GPIO_USART_RS485, GPIO_TxPin_RS485Source, GPIO_AF_USART_RS_485);
    686            GPIO_PinAFConfig(GPIO_USART_RS485, GPIO_RxPin_RS485Source, GPIO_AF_USART_RS_485);
    687          
    688            /* Configure USART_RS485 Rx/Tx as alternate function push-pull */
    689            GPIO_InitStructure.GPIO_Pin = GPIO_TxPin_RS485 | GPIO_RxPin_RS485;
    690            GPIO_Init(GPIO_USART_RS485, &GPIO_InitStructure);
    691            /**********************/
    692          
    693            /* Під'єднання EXTI Line0 to POWER_CTRL_PIN піну */
    694            SYSCFG_EXTILineConfig(EXTI_PortSource_POWER, EXTI_PinSource_POWER);  
    695            /**********************/
    696          
    697             /* Конфігурування EXTI Line0 */
    698            EXTI_InitTypeDef   EXTI_InitStructure;
    699          
    700            EXTI_InitStructure.EXTI_Line = EXTI_Line_POWER;
    701            EXTI_InitStructure.EXTI_Mode = EXTI_Mode_Interrupt;
    702            EXTI_InitStructure.EXTI_Trigger = EXTI_Trigger_Rising_Falling;  
    703            EXTI_InitStructure.EXTI_LineCmd = ENABLE;
    704            EXTI_Init(&EXTI_InitStructure);
    705            /**********************/
    706          
    707            /**********************/
    708            //Настроювання DMA контролерів
    709            /**********************/
    710            DMA_InitTypeDef  DMA_InitStructure;
    711          
    712            /* DMA настроюємо для прийому даних по I2C*/
    713            DMA_DeInit(DMA_StreamI2C_Rx);
    714            while (DMA_GetCmdStatus(DMA_StreamI2C_Rx) != DISABLE);
    715            
    716            DMA_InitStructure.DMA_Channel = DMA_ChannelI2C_Rx;
    717            DMA_InitStructure.DMA_PeripheralBaseAddr = I2C_DR_Address;
    718            DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)Temporaty_I2C_Buffer;
    719            DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
    720            DMA_InitStructure.DMA_BufferSize = SIZE_PAGE_EEPROM + 2;
    721            DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;
    722            DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;
    723            DMA_InitStructure.DMA_PeripheralDataSize = DMA_MemoryDataSize_Byte;
    724            DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_Byte;
    725            DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;
    726            DMA_InitStructure.DMA_Priority = DMA_Priority_High;
    727            DMA_InitStructure.DMA_FIFOMode = DMA_FIFOMode_Disable;
    728            DMA_InitStructure.DMA_FIFOThreshold = DMA_FIFOThreshold_HalfFull;
    729            DMA_InitStructure.DMA_MemoryBurst = DMA_MemoryBurst_Single;
    730            DMA_InitStructure.DMA_PeripheralBurst = DMA_PeripheralBurst_Single;
    731            DMA_Init(DMA_StreamI2C_Rx, &DMA_InitStructure);
    732            DMA_ClearFlag(DMA_StreamI2C_Rx, DMA_FLAG_TCI2C_Rx | DMA_FLAG_HTI2C_Rx | DMA_FLAG_TEII2C_Rx | DMA_FLAG_DMEII2C_Rx | DMA_FLAG_FEII2C_Rx);
    733          
    734            /* DMA настроюємо для передавання даних по I2C*/
    735            DMA_DeInit(DMA_StreamI2C_Tx);
    736            while (DMA_GetCmdStatus(DMA_StreamI2C_Tx) != DISABLE);
    737            
    738            DMA_InitStructure.DMA_Channel = DMA_ChannelI2C_Tx;
    739            DMA_InitStructure.DMA_PeripheralBaseAddr = I2C_DR_Address;
    740            DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)Temporaty_I2C_Buffer;
    741            DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
    742            DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;
    743            DMA_Init(DMA_StreamI2C_Tx, &DMA_InitStructure);
    744            DMA_ClearFlag(DMA_StreamI2C_Tx, DMA_FLAG_TCI2C_Tx | DMA_FLAG_HTI2C_Tx | DMA_FLAG_TEII2C_Tx | DMA_FLAG_DMEII2C_Tx | DMA_FLAG_FEII2C_Tx);
    745          
    746            /* DMA настроюємо для передачі даних по SPI_DF*/
    747            DMA_DeInit(DMA_StreamSPI_DF_Tx);
    748            while (DMA_GetCmdStatus(DMA_StreamSPI_DF_Tx) != DISABLE);
    749            
    750            DMA_InitStructure.DMA_Channel = DMA_ChannelSPI_DF_Tx;
    751            DMA_InitStructure.DMA_PeripheralBaseAddr = SPI_DF_DR_Address;
    752            DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)TxBuffer_SPI_DF;
    753            DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
    754            DMA_InitStructure.DMA_BufferSize = SIZE_PAGE_DATAFLASH_MAX + 10;
    755            DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh; /*Так як № потоку DMA_StreamSPI_DF_Tx > за № потоку DMA_StreamSPI_DF_Rx, то DMA_StreamSPI_DF_Rx має пріориет над DMA_StreamSPI_DF_Tx при однаковому програмному пріоритеті*/
    756            DMA_Init(DMA_StreamSPI_DF_Tx, &DMA_InitStructure);
    757            DMA_ClearFlag(DMA_StreamSPI_DF_Tx, DMA_FLAG_TCSPI_DF_Tx | DMA_FLAG_HTSPI_DF_Tx | DMA_FLAG_TEISPI_DF_Tx | DMA_FLAG_DMEISPI_DF_Tx | DMA_FLAG_FEISPI_DF_Tx);
    758          
    759            /* DMA настроюємо для прийому даних по SPI_DF*/
    760            DMA_DeInit(DMA_StreamSPI_DF_Rx);
    761            while (DMA_GetCmdStatus(DMA_StreamSPI_DF_Rx) != DISABLE);
    762            
    763            DMA_InitStructure.DMA_Channel = DMA_ChannelSPI_DF_Rx;
    764            DMA_InitStructure.DMA_PeripheralBaseAddr = SPI_DF_DR_Address;
    765            DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)RxBuffer_SPI_DF;
    766            DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
    767            DMA_InitStructure.DMA_Priority = DMA_Priority_VeryHigh; /*Так як № потоку DMA_StreamSPI_DF_Tx > за № потоку DMA_StreamSPI_DF_Rx, то DMA_StreamSPI_DF_Rx має пріориет над DMA_StreamSPI_DF_Tx при однаковому програмному пріоритеті*/
    768            DMA_Init(DMA_StreamSPI_DF_Rx, &DMA_InitStructure);
    769            DMA_ClearFlag(DMA_StreamSPI_DF_Rx, DMA_FLAG_TCSPI_DF_Rx | DMA_FLAG_HTSPI_DF_Rx | DMA_FLAG_TEISPI_DF_Rx | DMA_FLAG_DMEISPI_DF_Rx | DMA_FLAG_FEISPI_DF_Rx);
    770          
    771            /* Прийом по RS-485*/
    772            DMA_DeInit(DMA_StreamRS485_Rx);
    773            while (DMA_GetCmdStatus(DMA_StreamRS485_Rx) != DISABLE);
    774            
    775            DMA_InitStructure.DMA_Channel = DMA_ChannelRS485_Rx;
    776            DMA_InitStructure.DMA_PeripheralBaseAddr = USARTRS485_DR_Base;
    777            DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)RxBuffer_RS485;
    778            DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralToMemory;
    779            DMA_InitStructure.DMA_BufferSize = BUFFER_RS485;
    780            DMA_InitStructure.DMA_Priority = DMA_Priority_Low;
    781            DMA_Init(DMA_StreamRS485_Rx, &DMA_InitStructure);
    782            DMA_ClearFlag(DMA_StreamRS485_Rx, DMA_FLAG_TCRS485_Rx | DMA_FLAG_HTRS485_Rx | DMA_FLAG_TEIRS485_Rx | DMA_FLAG_DMEIRS485_Rx | DMA_FLAG_FEIRS485_Rx);
    783            
    784            /* Передача по RS-485*/
    785            DMA_DeInit(DMA_StreamRS485_Tx);
    786            while (DMA_GetCmdStatus(DMA_StreamRS485_Tx) != DISABLE);
    787          
    788            DMA_InitStructure.DMA_Channel = DMA_ChannelRS485_Tx;
    789            DMA_InitStructure.DMA_PeripheralBaseAddr = USARTRS485_DR_Base;
    790            DMA_InitStructure.DMA_Memory0BaseAddr = (uint32_t)TxBuffer_RS485;
    791            DMA_InitStructure.DMA_DIR = DMA_DIR_MemoryToPeripheral;
    792            DMA_InitStructure.DMA_BufferSize = 0;
    793            DMA_InitStructure.DMA_Priority = DMA_Priority_Low;
    794            DMA_Init(DMA_StreamRS485_Tx, &DMA_InitStructure);
    795            DMA_ClearFlag(DMA_StreamRS485_Tx, DMA_FLAG_TCRS485_Tx | DMA_FLAG_HTRS485_Tx | DMA_FLAG_TEIRS485_Tx | DMA_FLAG_DMEIRS485_Tx | DMA_FLAG_FEIRS485_Tx);
    796            /**********************/
    797          
    798            /**********************/
    799            //Настроювання SPI для  АЦП з початковою ініціалізацією АП
    800            /**********************/
    801            SPI_InitTypeDef  SPI_InitStructure;
    802            
    803            SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
    804            SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
    805            SPI_InitStructure.SPI_DataSize = SPI_DataSize_16b;
    806            SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
    807            SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;
    808            SPI_InitStructure.SPI_NSS =  SPI_NSS_Soft;
    809            SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_2;/*30МГц/2 = 15 МГц*/
    810            SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
    811            SPI_InitStructure.SPI_CRCPolynomial = 7;
    812            SPI_Init(SPI_ADC, &SPI_InitStructure);
    813          
    814            /* Дозволяємо SPI_ADC */
    815            SPI_Cmd(SPI_ADC, ENABLE);
    816            
    817            //Стартовий запуск АЦП
    818            //Скидаємо признаки помилок
    819            if  (SPI_I2S_GetFlagStatus(SPI_ADC, SPI_I2S_FLAG_RXNE) == SET) SPI_I2S_ReceiveData(SPI_ADC);
    820            while (SPI_I2S_GetFlagStatus(SPI_ADC, SPI_I2S_FLAG_OVR) == SET) SPI_I2S_ReceiveData(SPI_ADC);
    821                
    822            for (unsigned int i = 0; i < NUMBER_ADCs; i++)
    823            {
    824          //    if (i == 0) GPIO_SELECT_ADC->BSRRH = GPIO_SELECTPin_ADC;
    825          //    else GPIO_SELECT_ADC->BSRRL = GPIO_SELECTPin_ADC; 
    826              
    827              //Посилаємо перше слово 0xffff
    828              while (SPI_I2S_GetFlagStatus(SPI_ADC, SPI_I2S_FLAG_TXE) == RESET);          //Очікуємо, поки SPI стане вільним
    829              GPIO_ResetBits(GPIO_SPI_ADC, GPIO_NSSPin_ADC);                              //Виставляємо chip_select
    830              SPI_I2S_SendData(SPI_ADC, 0xFFFF);                                          //Відправляємо число 0xffff
    831              while (SPI_I2S_GetFlagStatus(SPI_ADC, SPI_I2S_FLAG_RXNE) == RESET);         //Очікуємо завершення трансакції по прийнятті даних по MISO
    832              GPIO_SetBits(GPIO_SPI_ADC, GPIO_NSSPin_ADC);                                //Знімаємо chip_select
    833              SPI_I2S_ReceiveData(SPI_ADC);                                               //Читаємо прийняті дані
    834          
    835              //Посилаємо друге слово 0xffff
    836              while (SPI_I2S_GetFlagStatus(SPI_ADC, SPI_I2S_FLAG_TXE) == RESET);          //Очікуємо, поки SPI стане вільним
    837              GPIO_ResetBits(GPIO_SPI_ADC, GPIO_NSSPin_ADC);                              //Виставляємо chip_select
    838              SPI_I2S_SendData(SPI_ADC, 0xFFFF);                                          //Відправляємо число 0xffff
    839              while (SPI_I2S_GetFlagStatus(SPI_ADC, SPI_I2S_FLAG_RXNE) == RESET);         //Очікуємо завершення трансакції по прийнятті даних по MISO
    840              GPIO_SetBits(GPIO_SPI_ADC, GPIO_NSSPin_ADC);                                //Знімаємо chip_select
    841              SPI_I2S_ReceiveData(SPI_ADC);                                               //Читаємо прийняті дані
    842            }
    843            
    844            //Дозволяємо переривання від прийнятого байту по SPI
    845            SPI_I2S_ITConfig(SPI_ADC, SPI_I2S_IT_RXNE, ENABLE);
    846            /**********************/
    847          
    848            /**********************/
    849            //Настроювання TIM4 на генерацію переривань кожні 10 мс для клавіатури і 1 мс для низькопріоритетних задач
    850            /**********************/
    851            /* Настроюємо TIM4 */
    852            /* ---------------------------------------------------------------
    853            TIM4 Настроювання: Output Compare Timing Mode:
    854            TIM4CLK = (30*2) МГц, Prescaler = 600, TIM4 counter clock = 100 кГц
    855            CC1 update rate = TIM4 counter clock / CCR1_Val = 100 Hz
    856            CC2 update rate = TIM4 counter clock / CCR1_Val = 1000 Hz
    857            --------------------------------------------------------------- */
    858            TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
    859            TIM_OCInitTypeDef  TIM_OCInitStructure;
    860          
    861            TIM_TimeBaseStructure.TIM_Period = 65535;
    862            TIM_TimeBaseStructure.TIM_Prescaler = (600-1);
    863            TIM_TimeBaseStructure.TIM_ClockDivision = 0;
    864            TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
    865            TIM_TimeBaseInit(TIM4, &TIM_TimeBaseStructure);
    866          
    867            /* Output Compare Timing Mode настроювання: Канал:1 */
    868            TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_Timing;
    869            TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Disable;
    870            TIM_OCInitStructure.TIM_Pulse = TIM4_CCR1_VAL;
    871            TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
    872            TIM_OC1Init(TIM4, &TIM_OCInitStructure);
    873            
    874            TIM_OC1PreloadConfig(TIM4, TIM_OCPreload_Disable);
    875          
    876            /* Дозволяємо переривання від каналу 1 таймера 4*/
    877            TIM_ITConfig(TIM4, TIM_IT_CC1, ENABLE);
    878          
    879            /* Дозволяєм роботу таймера */
    880            TIM_Cmd(TIM4, ENABLE);
    881            /**********************/
    882          
    883            /**********************/
    884            //Конфігуруємо I2C
    885            /**********************/
    886            Configure_I2C(I2C);
    887            /**********************/
    888          
    889            /**********************/
    890            //Читаємо збережені дані юстування з EEPROM
    891            /**********************/
    892            comparison_writing &= (unsigned int)(~COMPARISON_WRITING_USTUVANNJA);/*зчитування, а не порівняння*/
    893            _SET_BIT(control_i2c_taskes, TASK_START_READ_USTUVANNJA_EEPROM_BIT);
    894            while(
    895                  (control_i2c_taskes[0]     != 0) ||
    896                  (control_i2c_taskes[1]     != 0) ||
    897                  (driver_i2c.state_execution > 0)
    898                 )
    899            {
    900              //Робота з watchdogs
    901              if ((control_word_of_watchdog & WATCHDOG_KYYBOARD) == WATCHDOG_KYYBOARD)
    902              {
    903                //Змінюємо стан біту зовнішнього Watchdog на протилежний
    904                GPIO_WriteBit(
    905                              GPIO_EXTERNAL_WATCHDOG,
    906                              GPIO_PIN_EXTERNAL_WATCHDOG,
    907                              (BitAction)(1 - GPIO_ReadOutputDataBit(GPIO_EXTERNAL_WATCHDOG, GPIO_PIN_EXTERNAL_WATCHDOG))
    908                             );
    909              }
    910          
    911              main_routines_for_i2c();
    912              changing_diagnostyka_state();//Підготовлюємо новий потенційно можливий запис для реєстратора програмних подій
    913              if (_CHECK_SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT) != 0)
    914              {
    915                //Повне роозблоковування обміну з мікросхемами для драйверу I2C
    916                _CLEAR_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);
    917              }
    918            }
    919            /**********************/
    920          
    921            /**********************/
    922            //Читаємо збережені дані реєстратора програмних подій з EEPROM
    923            /**********************/
    924            comparison_writing &= (unsigned int)(~COMPARISON_WRITING_INFO_REJESTRATOR_PR_ERR);/*зчитування, а не порівняння*/
    925            _SET_BIT(control_i2c_taskes, TASK_START_READ_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT);
    926            while(
    927                  (control_i2c_taskes[0]     != 0) ||
    928                  (control_i2c_taskes[1]     != 0) ||
    929                  (driver_i2c.state_execution > 0)
    930                 )
    931            {
    932              //Робота з watchdogs
    933              if ((control_word_of_watchdog & WATCHDOG_KYYBOARD) == WATCHDOG_KYYBOARD)
    934              {
    935                //Змінюємо стан біту зовнішнього Watchdog на протилежний
    936                GPIO_WriteBit(
    937                              GPIO_EXTERNAL_WATCHDOG,
    938                              GPIO_PIN_EXTERNAL_WATCHDOG,
    939                              (BitAction)(1 - GPIO_ReadOutputDataBit(GPIO_EXTERNAL_WATCHDOG, GPIO_PIN_EXTERNAL_WATCHDOG))
    940                             );
    941              }
    942          
    943              main_routines_for_i2c();
    944              changing_diagnostyka_state();//Підготовлюємо новий потенційно можливий запис для реєстратора програмних подій
    945              if (_CHECK_SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT) != 0)
    946              {
    947                //Повне роозблоковування обміну з мікросхемами для драйверу I2C
    948                _CLEAR_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);
    949              }
    950            }
    951            /**********************/
    952          
    953            /**********************/
    954            //Читаємо збережені дані конфігурації з EEPROM
    955            /**********************/
    956            comparison_writing &= (unsigned int)(~COMPARISON_WRITING_CONFIG);/*зчитування, а не порівняння*/
    957            _SET_BIT(control_i2c_taskes, TASK_START_READ_CONFIG_EEPROM_BIT);
    958            while(
    959                  (control_i2c_taskes[0]     != 0) ||
    960                  (control_i2c_taskes[1]     != 0) ||
    961                  (driver_i2c.state_execution > 0)
    962                 )
    963            {
    964              //Робота з watchdogs
    965              if ((control_word_of_watchdog & WATCHDOG_KYYBOARD) == WATCHDOG_KYYBOARD)
    966              {
    967                //Змінюємо стан біту зовнішнього Watchdog на протилежний
    968                GPIO_WriteBit(
    969                              GPIO_EXTERNAL_WATCHDOG,
    970                              GPIO_PIN_EXTERNAL_WATCHDOG,
    971                              (BitAction)(1 - GPIO_ReadOutputDataBit(GPIO_EXTERNAL_WATCHDOG, GPIO_PIN_EXTERNAL_WATCHDOG))
    972                             );
    973              }
    974          
    975              main_routines_for_i2c();
    976              changing_diagnostyka_state();//Підготовлюємо новий потенційно можливий запис для реєстратора програмних подій
    977              if (_CHECK_SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT) != 0)
    978              {
    979                //Повне роозблоковування обміну з мікросхемами для драйверу I2C
    980                _CLEAR_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);
    981              }
    982            }
    983            /**********************/
    984          
    985            if((state_i2c_task & STATE_CONFIG_EEPROM_GOOD) != 0)
    986            {
    987              /**********************/
    988              //Читаємо збережені дані настройок з EEPROM
    989              /**********************/
    990              comparison_writing &= (unsigned int)(~COMPARISON_WRITING_SETTINGS);/*зчитування, а не порівняння*/
    991              _SET_BIT(control_i2c_taskes, TASK_START_READ_SETTINGS_EEPROM_BIT);
    992              while(
    993                    (control_i2c_taskes[0]     != 0) ||
    994                    (control_i2c_taskes[1]     != 0) ||
    995                    (driver_i2c.state_execution > 0)
    996                   )
    997              {
    998                //Робота з watchdogs
    999                if ((control_word_of_watchdog & WATCHDOG_KYYBOARD) == WATCHDOG_KYYBOARD)
   1000                {
   1001                  //Змінюємо стан біту зовнішнього Watchdog на протилежний
   1002                  GPIO_WriteBit(
   1003                                GPIO_EXTERNAL_WATCHDOG,
   1004                                GPIO_PIN_EXTERNAL_WATCHDOG,
   1005                                (BitAction)(1 - GPIO_ReadOutputDataBit(GPIO_EXTERNAL_WATCHDOG, GPIO_PIN_EXTERNAL_WATCHDOG))
   1006                               );
   1007                }
   1008          
   1009                main_routines_for_i2c();
   1010                changing_diagnostyka_state();//Підготовлюємо новий потенційно можливий запис для реєстратора програмних подій
   1011                if (_CHECK_SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT) != 0)
   1012                {
   1013                  //Повне роозблоковування обміну з мікросхемами для драйверу I2C
   1014                  _CLEAR_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);
   1015                }
   1016              }
   1017              /**********************/
   1018          
   1019          //    /**********************/
   1020          //    //Читаємо збережені дані про тригерну інформацію
   1021          //    /**********************/
   1022          //    comparison_writing &= (unsigned int)(~COMPARISON_WRITING_TRG_FUNC);/*зчитування, а не порівняння*/
   1023          //    _SET_BIT(control_i2c_taskes, TASK_START_READ_TRG_FUNC_EEPROM_BIT);
   1024          //    while(
   1025          //          (control_i2c_taskes[0]     != 0) ||
   1026          //          (control_i2c_taskes[1]     != 0) ||
   1027          //          (driver_i2c.state_execution > 0)
   1028          //        )
   1029          //    {
   1030          //      //Робота з watchdogs
   1031          //      if ((control_word_of_watchdog & WATCHDOG_KYYBOARD) == WATCHDOG_KYYBOARD)
   1032          //      {
   1033          //        //Змінюємо стан біту зовнішнього Watchdog на протилежний
   1034          //        GPIO_WriteBit(
   1035          //                      GPIO_EXTERNAL_WATCHDOG,
   1036          //                      GPIO_PIN_EXTERNAL_WATCHDOG,
   1037          //                      (BitAction)(1 - GPIO_ReadOutputDataBit(GPIO_EXTERNAL_WATCHDOG, GPIO_PIN_EXTERNAL_WATCHDOG))
   1038          //                     );
   1039          //      }
   1040          //
   1041          //      main_routines_for_i2c();
   1042          //      changing_diagnostyka_state();//Підготовлюємо новий потенційно можливий запис для реєстратора програмних подій
   1043          //      if (_CHECK_SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT) != 0)
   1044          //      {
   1045          //        //Повне роозблоковування обміну з мікросхемами для драйверу I2C
   1046          //        _CLEAR_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);
   1047          //      }
   1048          //    }
   1049          //    /**********************/
   1050            }
   1051            else
   1052            {
   1053              /*
   1054              Оскільки конфігурації достовірної немає, тому немає сенсу зчитувати налаштування,
   1055              триґерну інформацію, стани сигнальних входів, трияерних індикаторів
   1056              
   1057              Тому помічаємо інформацію, що вищеперечисленої інформації немає
   1058              */
   1059              //Помічаємо, що прочитаний блок настройок є пустим
   1060              state_i2c_task &= (unsigned int)(~(STATE_SETTINGS_EEPROM_FAIL | STATE_SETTINGS_EEPROM_GOOD));
   1061              state_i2c_task |= STATE_SETTINGS_EEPROM_EMPTY;
   1062              //Виствляємо повідомлення у слові діагностики
   1063              _SET_BIT(clear_diagnostyka, ERROR_SETTINGS_EEPROM_BIT);
   1064              _SET_BIT(set_diagnostyka, ERROR_SETTINGS_EEPROM_EMPTY_BIT);
   1065          
   1066          //    //Помічаємо, що прочитаний блок є пустим
   1067          //    state_i2c_task &= (unsigned int)(~(STATE_TRG_FUNC_EEPROM_FAIL | STATE_TRG_FUNC_EEPROM_GOOD));
   1068          //    state_i2c_task |= STATE_TRG_FUNC_EEPROM_EMPTY;
   1069          //    //Виствляємо повідомлення у слові діагностики
   1070          //    _SET_BIT(clear_diagnostyka, ERROR_TRG_FUNC_EEPROM_BIT);
   1071          //    _SET_BIT(set_diagnostyka, ERROR_TRG_FUNC_EEPROM_EMPTY_BIT);
   1072            }
   1073          
   1074            /**********************/
   1075            //Виставляємо початкову інформацію на виходи і світлоіндикатори і дозволяємо з ними роботу
   1076            /**********************/
   1077            {
   1078              //Виводимо інформацію по світлоіндикаторах на світлодіоди
   1079          //    _DEVICE_REGISTER(Bank1_SRAM2_ADDR, OFFSET_LEDS) = state_leds;
   1080              //Виставляємо пін CON-L, щоб можна було управляти свтоіндикаторами
   1081              GPIO_SetBits(CON_L, CON_L_PIN);
   1082          
   1083              //Виводимо інформацію по виходах на піни процесора (у зворотньому порядку)
   1084              unsigned int temp_state_outputs = 0;
   1085          //    for (unsigned int index = 0; index < NUMBER_OUTPUTS; index++)
   1086          //    {
   1087          //      if ((state_outputs & (1 << index)) != 0)
   1088          //      {
   1089          //        if (index < NUMBER_OUTPUTS_1)
   1090          //          temp_state_outputs |= 1 << (NUMBER_OUTPUTS_1 - index - 1);
   1091          //        else
   1092          //          temp_state_outputs |= 1 << index;
   1093          //      }
   1094          //    }
   1095              unsigned int temp_state_outputs_1 =  temp_state_outputs                      & ((1 << NUMBER_OUTPUTS_1) - 1);
   1096              unsigned int temp_state_outputs_2 = (temp_state_outputs >> NUMBER_OUTPUTS_1) & ((1 << NUMBER_OUTPUTS_2) - 1);
   1097              _DEVICE_REGISTER(Bank1_SRAM2_ADDR, OFFSET_OUTPUTS_1) = temp_state_outputs_1;
   1098              _DEVICE_REGISTER(Bank1_SRAM2_ADDR, OFFSET_OUTPUTS_2) = temp_state_outputs_2;
   1099              //Виставляємо пін CON-OUTPUTS-1, щоб можна було управляти виходами
   1100              GPIO_SetBits(CON_OUTPUTS, CON_1_OUTPUTS_PIN);
   1101              //Знімаємо пін CON-OUTPUTS-2, щоб можна було управляти виходамии
   1102              GPIO_ResetBits(CON_OUTPUTS, CON_2_OUTPUTS_PIN);
   1103              //Виставляємо  пін CON-OUTPUTS-3, щоб можна було управляти виходами
   1104              GPIO_SetBits(CON_OUTPUTS, CON_3_OUTPUTS_PIN);
   1105            }
   1106            /**********************/
   1107          
   1108            //Переконфігуровуємо I2C
   1109            low_speed_i2c = 0xff;
   1110            Configure_I2C(I2C);
   1111          
   1112            /**********************/
   1113            //Настроювання TIM2 на генерацію переривань кожні 1 мс для системи захистів
   1114            /**********************/
   1115            /* Настроюємо TIM2 */
   1116            /* ---------------------------------------------------------------
   1117            TIM2 Настроювання: Output Compare Timing Mode:
   1118            TIM2CLK = 30*2 МГц, Prescaler = 2000, TIM2 counter clock = 30 кГц
   1119            CC1 update rate = TIM2 counter clock / CCR1_Val = 1000 Hz
   1120            --------------------------------------------------------------- */
   1121            TIM_TimeBaseStructure.TIM_Period = 0xffffffff;
   1122            TIM_TimeBaseStructure.TIM_Prescaler = (2000-1);
   1123            TIM_TimeBaseStructure.TIM_ClockDivision = 0;
   1124            TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
   1125            TIM_TimeBaseInit(TIM2, &TIM_TimeBaseStructure);
   1126          
   1127            /* Output Compare Timing Mode настроювання: Канал:1 */
   1128            TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_Timing;
   1129            TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Disable;
   1130            TIM_OCInitStructure.TIM_Pulse = TIM2_CCR1_VAL;
   1131            TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
   1132            TIM_OC1Init(TIM2, &TIM_OCInitStructure);
   1133            
   1134            TIM_OC1PreloadConfig(TIM2, TIM_OCPreload_Disable);
   1135          
   1136            /* Дозволяємо переривання від каналу 1 таймера 2*/
   1137            TIM_ITConfig(TIM2, TIM_IT_CC1, ENABLE);
   1138            /**********************/
   1139          
   1140            /**********************/
   1141            //Настроювання TIM5 на генерацію переривань кожні 0,625 мс
   1142            /**********************/
   1143            /* Настроюємо TIM5 */
   1144            /* ---------------------------------------------------------------
   1145            TIM5 Настроювання: Output Compare Timing Mode:
   1146            TIM2CLK = 30*2 МГц, Prescaler = 1, TIM5 counter clock = 60 МГц
   1147            CC1 update rate = TIM5 counter clock / CCR1_Val = 1600 Hz
   1148            --------------------------------------------------------------- */
   1149            TIM_TimeBaseStructure.TIM_Period = 0xffffffff;
   1150            TIM_TimeBaseStructure.TIM_Prescaler = (1-1);
   1151            TIM_TimeBaseStructure.TIM_ClockDivision = 0;
   1152            TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
   1153            TIM_TimeBaseInit(TIM5, &TIM_TimeBaseStructure);
   1154          
   1155            /* Output Compare Timing Mode настроювання: Канал:1 */
   1156            TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_Timing;
   1157            TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Disable;
   1158            TIM_OCInitStructure.TIM_Pulse = TIM5_CCR1_VAL;
   1159            TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
   1160            TIM_OC1Init(TIM5, &TIM_OCInitStructure);
   1161            TIM_OC1PreloadConfig(TIM5, TIM_OCPreload_Disable);
   1162          
   1163            /* Дозволяємо переривання від каналу 1 таймера 5*/
   1164            TIM_ITConfig(TIM5, TIM_IT_CC1, ENABLE);
   1165            /**********************/
   1166            
   1167            /**********************/
   1168            //Настроювання SPI для  DataFlash з початковим читанням , чи мікросхеми переведені у потрібний режим
   1169            /**********************/
   1170            SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;
   1171            SPI_InitStructure.SPI_Mode = SPI_Mode_Master;
   1172            SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;
   1173            SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;
   1174            SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;
   1175            SPI_InitStructure.SPI_NSS =  SPI_NSS_Soft;
   1176            SPI_InitStructure.SPI_BaudRatePrescaler = /*SPI_BaudRatePrescaler_4*/SPI_BaudRatePrescaler_2;
   1177            SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;
   1178            SPI_InitStructure.SPI_CRCPolynomial = 7;
   1179            SPI_Init(SPI_DF, &SPI_InitStructure);
   1180          
   1181            /* Забороняємо SPI_DF DMA Tx запити */
   1182            SPI_I2S_DMACmd(SPI_DF, SPI_I2S_DMAReq_Tx, DISABLE);
   1183            /* Забороняємо SPI_DF DMA Rx запити */
   1184            SPI_I2S_DMACmd(SPI_DF, SPI_I2S_DMAReq_Rx, DISABLE);
   1185          
   1186            //Очищаємо прапореці, що сигналізує про завершення прийом/передачі даних для DMA по потоку DMA_StreamSPI_DF_Rx і DMA_StreamSPI_DF_Tx
   1187            DMA_ClearFlag(DMA_StreamSPI_DF_Rx, DMA_FLAG_TCSPI_DF_Rx | DMA_FLAG_HTSPI_DF_Rx | DMA_FLAG_TEISPI_DF_Rx | DMA_FLAG_DMEISPI_DF_Rx | DMA_FLAG_FEISPI_DF_Rx);
   1188            DMA_ClearFlag(DMA_StreamSPI_DF_Tx, DMA_FLAG_TCSPI_DF_Tx | DMA_FLAG_HTSPI_DF_Tx | DMA_FLAG_TEISPI_DF_Tx | DMA_FLAG_DMEISPI_DF_Tx | DMA_FLAG_FEISPI_DF_Tx);
   1189          
   1190            //Дозволяємо переривання від помилок на SPI_DF
   1191            SPI_I2S_ITConfig(SPI_DF, SPI_I2S_IT_ERR, ENABLE);
   1192          
   1193            /* Дозволяємо SPI_DF */
   1194            SPI_Cmd(SPI_DF, ENABLE);
   1195            /**********************/
   1196          
   1197              //Робота з watchdogs
   1198              if ((control_word_of_watchdog & WATCHDOG_KYYBOARD) == WATCHDOG_KYYBOARD)
   1199              {
   1200                //Змінюємо стан біту зовнішнього Watchdog на протилежний
   1201                GPIO_WriteBit(
   1202                              GPIO_EXTERNAL_WATCHDOG,
   1203                              GPIO_PIN_EXTERNAL_WATCHDOG,
   1204                              (BitAction)(1 - GPIO_ReadOutputDataBit(GPIO_EXTERNAL_WATCHDOG, GPIO_PIN_EXTERNAL_WATCHDOG))
   1205                             );
   1206              }
   1207          
   1208            /**********************/
   1209            //Ініціалізація USB
   1210            /**********************/
   1211            USBD_Init(&USB_OTG_dev,
   1212          #ifdef USE_USB_OTG_HS 
   1213                      USB_OTG_HS_CORE_ID,
   1214          #else            
   1215                      USB_OTG_FS_CORE_ID,
   1216          #endif  
   1217                      &USR_desc, 
   1218                      &USBD_CDC_cb, 
   1219                      &USR_cb);
   1220            /**********************/
   1221          
   1222              //Робота з watchdogs
   1223              if ((control_word_of_watchdog & WATCHDOG_KYYBOARD) == WATCHDOG_KYYBOARD)
   1224              {
   1225                //Змінюємо стан біту зовнішнього Watchdog на протилежний
   1226                GPIO_WriteBit(
   1227                              GPIO_EXTERNAL_WATCHDOG,
   1228                              GPIO_PIN_EXTERNAL_WATCHDOG,
   1229                              (BitAction)(1 - GPIO_ReadOutputDataBit(GPIO_EXTERNAL_WATCHDOG, GPIO_PIN_EXTERNAL_WATCHDOG))
   1230                             );
   1231              }
   1232          }
   1233          /**************************************/
   1234          
   1235          /**************************************/
   1236          //Мінімальна конфігурація
   1237          /**************************************/
   1238          void min_config(__CONFIG *target_label)
   1239          {
   1240            target_label->device_id = VERSIA_PZ;
   1241          
   1242            target_label->n_input = NUMBER_INPUTS;
   1243            target_label->n_output = NUMBER_OUTPUTS;
   1244            target_label->n_led = NUMBER_LEDS;
   1245            
   1246            target_label->n_alarm = 0;
   1247            target_label->n_group_alarm = 0;
   1248            target_label->n_and = 0;
   1249            target_label->n_or = 0;
   1250            target_label->n_xor = 0;
   1251            target_label->n_not = 0;
   1252            target_label->n_timer = 0;
   1253            target_label->n_trigger = 0;
   1254            
   1255            target_label->n_meander = 0;
   1256            
   1257            for(unsigned int i = 0; i < (7+1); i++)
   1258            {
   1259              target_label->time_config[i] = DEFAULT_PARAMS_FIX_CHANGES;
   1260            }
   1261          }
   1262          /**************************************/
   1263          
   1264          /**************************************/
   1265          //Мінімальні налаштування
   1266          /**************************************/
   1267          void min_settings(__SETTINGS_FIX *target_label)
   1268          {
   1269          
   1270            target_label->password_1 = 0;
   1271            target_label->password_2 = 0;
   1272            target_label->timeout_deactivation_password_interface_USB = TIMEOUT_DEACTIVATION_PASSWORD_MIN;
   1273            target_label->password_interface_USB = 0;
   1274            target_label->timeout_deactivation_password_interface_RS485 = TIMEOUT_DEACTIVATION_PASSWORD_MIN;
   1275            target_label->password_interface_RS485 = 0;
   1276            
   1277            target_label->timeout_idle_new_settings = TIMEOUT_NEW_SETTINGS_MIN;
   1278            
   1279            for(unsigned int i=0; i< ((M_ADDRESS_LAST_USER_REGISTER_DATA - M_ADDRESS_FIRST_USER_REGISTER_DATA) + 1); i++) target_label->user_register[i] = 0;
   1280          
   1281            for(unsigned int i=0; i<MAX_CHAR_IN_NAME_OF_CELL; i++) target_label->name_of_cell[i] = ' ';
   1282            target_label->name_of_cell[4 ] = 'N';
   1283            target_label->name_of_cell[5 ] = 'o';
   1284            target_label->name_of_cell[7 ] = 'n';
   1285            target_label->name_of_cell[8 ] = 'a';
   1286            target_label->name_of_cell[9 ] = 'm';
   1287            target_label->name_of_cell[10] = 'e';
   1288            
   1289            target_label->address = KOEF_ADDRESS_MIN;
   1290            target_label->baud_RS485 = VALUE_BAUD_RS485_MIN;
   1291            target_label->pare_bit_RS485 = VALUE_PARE_RS485_MAX; //томущо восновному контроль парності має бути в EVEN - а це число відповідає VALUE_PARE_INTERFACE_MAX
   1292            target_label->number_stop_bit_RS485 = VALUE_STOP_BITS_RS485_MIN;
   1293            target_label->time_out_1_RS485 = VALUE_TIME_OUT_1_RS485_MIN;
   1294            
   1295            target_label->language = LANGUAGE_EN;
   1296            
   1297            for(unsigned int i = 0; i < (7+1); i++)
   1298            {
   1299              target_label->time_setpoints[i] = DEFAULT_PARAMS_FIX_CHANGES;
   1300            }
   1301          }
   1302          /**************************************/
   1303          
   1304          
   1305          /**************************************/
   1306          //Виводимо повідомлення про те, що настройки не зчитані успішно
   1307          /**************************************/
   1308          void error_reading_with_eeprom()
   1309          {
   1310            const unsigned char string_info[MAX_NAMBER_LANGUAGE][7][MAX_COL_LCD] = 
   1311            {
   1312              {
   1313                "Конфигурации нет",
   1314                " Ош.конфигурации",
   1315                " Недост.динам.п.",
   1316                "  Настроек нет  ",
   1317                "  Ош.настроек   ",
   1318                "  Триг.инф.нет  ",
   1319                "  Ош.триг.инф.  "
   1320              },
   1321              {
   1322                "   Конф.нема    ",
   1323                "Пом.конфігурації",
   1324                " Недост.динам.п.",
   1325                "Налаштувань нема",
   1326                " Пом.налаштувань",
   1327                " Триґ.інф.нема  ",
   1328                " Пом.триґ.інф.  "
   1329              },
   1330              {
   1331                "    No Conf.    ",
   1332                "   Conf.Err.    ",
   1333                "No enough dyn.m.",
   1334                "  No settings   ",
   1335                " Settings Err.  ",
   1336                "  Триг.инф.нет  ",
   1337                "  Ош.триг.инф.  "
   1338              },
   1339              {
   1340                "Конфигурации нет",
   1341                " Ош.конфигурации",
   1342                " Недост.динам.п.",
   1343                "  Настроек нет  ",
   1344                "  Ош.настроек   ",
   1345                "  Триг.инф.нет  ",
   1346                "  Ош.триг.инф.  "
   1347              } 
   1348            };
   1349            const unsigned char string_action[MAX_NAMBER_LANGUAGE][2][MAX_COL_LCD] =
   1350            {
   1351              {
   1352                "Мин.парам.:Enter",
   1353                " Сбросить: Enter"
   1354              },
   1355              {
   1356                "Мін.парам.:Enter",
   1357                " Скинути: Enter "
   1358              },
   1359              {
   1360                "Min.param :Enter",
   1361                "  Reset: Enter  "
   1362              },
   1363              {
   1364                "Мин.парам.:Enter",
   1365                " Сбросить: Enter"
   1366              }
   1367            };
   1368            
   1369            int index_language;
   1370            if (((state_i2c_task & STATE_CONFIG_EEPROM_GOOD) == 0) || ((state_i2c_task & STATE_SETTINGS_EEPROM_GOOD) == 0)) index_language = index_language_in_array(LANGUAGE_ABSENT);
   1371            else index_language = index_language_in_array(settings_fix_prt.language);
   1372          
   1373            if ((state_i2c_task & (
   1374                                   STATE_CONFIG_EEPROM_EMPTY          | 
   1375                                   STATE_CONFIG_EEPROM_FAIL           | 
   1376                                   STATE_CONFIG_EEPROM_NO_FREE_MEMORY |
   1377                                   STATE_SETTINGS_EEPROM_EMPTY        | 
   1378                                   STATE_SETTINGS_EEPROM_FAIL       /*| 
   1379                                   STATE_TRG_FUNC_EEPROM_EMPTY        | 
   1380                                   STATE_TRG_FUNC_EEPROM_FAIL*/
   1381                                  )) != 0)
   1382            {
   1383              //Робота з watchdogs
   1384              if ((control_word_of_watchdog & WATCHDOG_KYYBOARD) == WATCHDOG_KYYBOARD)
   1385              {
   1386                //Змінюємо стан біту зовнішнього Watchdog на протилежний
   1387                GPIO_WriteBit(
   1388                              GPIO_EXTERNAL_WATCHDOG,
   1389                              GPIO_PIN_EXTERNAL_WATCHDOG,
   1390                              (BitAction)(1 - GPIO_ReadOutputDataBit(GPIO_EXTERNAL_WATCHDOG, GPIO_PIN_EXTERNAL_WATCHDOG))
   1391                             );
   1392              }
   1393              
   1394              unsigned int index_info, index_action, information_type;
   1395              if((state_i2c_task & STATE_CONFIG_EEPROM_EMPTY) != 0)
   1396              {
   1397                index_info = 0;
   1398                index_action = 0;
   1399                information_type = 1;
   1400              }
   1401              else if((state_i2c_task & STATE_CONFIG_EEPROM_FAIL) != 0)
   1402              {
   1403                index_info = 1;
   1404                index_action = 0;
   1405                information_type = 1;
   1406              }
   1407              else if((state_i2c_task & STATE_CONFIG_EEPROM_NO_FREE_MEMORY) != 0)
   1408              {
   1409                index_info = 2;
   1410                index_action = 0;
   1411                information_type = 1;
   1412              }
   1413              else if((state_i2c_task & STATE_SETTINGS_EEPROM_EMPTY) != 0)
   1414              {
   1415                index_info = 3;
   1416                index_action = 0;
   1417                information_type = 2;
   1418              }
   1419              else if((state_i2c_task & STATE_SETTINGS_EEPROM_FAIL) != 0)
   1420              {
   1421                index_info = 4;
   1422                index_action = 0;
   1423                information_type = 2;
   1424              }
   1425          //    else if((state_i2c_task & STATE_TRG_FUNC_EEPROM_EMPTY) != 0)
   1426          //    {
   1427          //      index_info = 5;
   1428          //      index_action = 1;
   1429          //      information_type = 3;
   1430          //    }
   1431          //    else if((state_i2c_task & STATE_TRG_FUNC_EEPROM_FAIL) != 0)
   1432          //    {
   1433          //      index_info = 6;
   1434          //      index_action = 1;
   1435          //      information_type = 3;
   1436          //    }
   1437          
   1438              //Копіюємо  рядки у робочий екран
   1439              for (unsigned int i=0; i< MAX_ROW_LCD; i++)
   1440              {
   1441                for (unsigned int j = 0; j<MAX_COL_LCD; j++) 
   1442                {
   1443                  if (i == 0) working_ekran[i][j] = string_info[index_language][index_info][j];
   1444                  else if (i == 1) working_ekran[i][j] = string_action[index_language][index_action][j];
   1445                  else working_ekran[i][j] = ' ';
   1446                }
   1447              }
   1448            
   1449              //Обновити повністю весь екран
   1450              current_state_menu2.current_action = ACTION_WITH_CARRENT_EKRANE_FULL_UPDATE;
   1451          
   1452              //Обновляємо інформацію на екрані
   1453              view_whole_ekran();
   1454              
   1455              //Чекаємо поки не буде натиснута кнопка ENTER
   1456              while ((new_state_keyboard & (1<<BIT_KEY_ENTER)) ==0)
   1457              {
   1458                //Робота з watchdogs
   1459                if ((control_word_of_watchdog & WATCHDOG_KYYBOARD) == WATCHDOG_KYYBOARD)
   1460                {
   1461                  //Змінюємо стан біту зовнішнього Watchdog на протилежний
   1462                  GPIO_WriteBit(
   1463                                GPIO_EXTERNAL_WATCHDOG,
   1464                                GPIO_PIN_EXTERNAL_WATCHDOG,
   1465                                (BitAction)(1 - GPIO_ReadOutputDataBit(GPIO_EXTERNAL_WATCHDOG, GPIO_PIN_EXTERNAL_WATCHDOG))
   1466                               );
   1467                }
   1468              }
   1469          
   1470              new_state_keyboard = 0;
   1471              
   1472              if (information_type == 1)
   1473              {
   1474                //Записуємо мінімальну конфігурацію
   1475                min_config(&current_config);
   1476                _SET_BIT(control_i2c_taskes, TASK_START_WRITE_CONFIG_EEPROM_BIT);
   1477                
   1478              }
   1479              else if (information_type == 2)
   1480              {
   1481                //Записуємо мінімальну конфігурацію
   1482                min_settings(&settings_fix);
   1483                _SET_BIT(control_i2c_taskes, TASK_START_WRITE_SETTINGS_EEPROM_BIT);
   1484                
   1485              }
   1486          //    else if (information_type == 3)
   1487          //    {
   1488          //      for (unsigned int i = 0; i < N_BIG; i++) trigger_active_functions[i] = 0x0;
   1489          //
   1490          //      //Записуємо очищену триґерну інформацію
   1491          //      _SET_BIT(control_i2c_taskes, TASK_START_WRITE_TRG_FUNC_EEPROM_BIT);
   1492          //    }
   1493              
   1494              //Чекаємо завершення запису
   1495              while(
   1496                    (control_i2c_taskes[0]     != 0) ||
   1497                    (control_i2c_taskes[1]     != 0) ||
   1498                    (driver_i2c.state_execution > 0)
   1499                   )
   1500              {
   1501                //Робота з watchdogs
   1502                if ((control_word_of_watchdog & WATCHDOG_KYYBOARD) == WATCHDOG_KYYBOARD)
   1503                {
   1504                  //Змінюємо стан біту зовнішнього Watchdog на протилежний
   1505                  GPIO_WriteBit(
   1506                                GPIO_EXTERNAL_WATCHDOG,
   1507                                GPIO_PIN_EXTERNAL_WATCHDOG,
   1508                                (BitAction)(1 - GPIO_ReadOutputDataBit(GPIO_EXTERNAL_WATCHDOG, GPIO_PIN_EXTERNAL_WATCHDOG))
   1509                               );
   1510                }
   1511          
   1512                main_routines_for_i2c();
   1513                changing_diagnostyka_state();//Підготовлюємо новий потенційно можливий запис для реєстратора програмних подій
   1514                //Оскільки ще тамер вимірювальної системи не запущений, то цю операцію треба робити тут
   1515                if (_CHECK_SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT) != 0)
   1516                {
   1517                  //Повне роозблоковування запуск заблокованих задач запису в EEPROM для драйверу I2C
   1518                  _CLEAR_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);
   1519                }
   1520              }
   1521          
   1522              if (information_type == 1)
   1523              {
   1524                //Повтрокно зчитуємо конфігурацію
   1525                comparison_writing &= (unsigned int)(~COMPARISON_WRITING_CONFIG);/*зчитування, а не порівняння*/
   1526                _SET_BIT(control_i2c_taskes, TASK_START_READ_CONFIG_EEPROM_BIT);
   1527              }
   1528              else if (information_type == 2)
   1529              {
   1530                //Повтрокно зчитуємо налаштування
   1531                comparison_writing &= (unsigned int)(~COMPARISON_WRITING_SETTINGS);/*зчитування, а не порівняння*/
   1532                _SET_BIT(control_i2c_taskes, TASK_START_READ_SETTINGS_EEPROM_BIT);
   1533              }
   1534          //    else if (information_type == 3)
   1535          //    {
   1536          //      //Повтрокно зчитуємо триґерну інформацію
   1537          //      comparison_writing &= (unsigned int)(~COMPARISON_WRITING_TRG_FUNC);/*зчитування, а не порівняння*/
   1538          //      _SET_BIT(control_i2c_taskes, TASK_START_READ_TRG_FUNC_EEPROM_BIT);
   1539          //    }
   1540          
   1541              //Чекаємо завершення читання
   1542              while(
   1543                    (control_i2c_taskes[0]     != 0) ||
   1544                    (control_i2c_taskes[1]     != 0) ||
   1545                    (driver_i2c.state_execution > 0)
   1546                   )
   1547              {
   1548                //Робота з watchdogs
   1549                if ((control_word_of_watchdog & WATCHDOG_KYYBOARD) == WATCHDOG_KYYBOARD)
   1550                {
   1551                  //Змінюємо стан біту зовнішнього Watchdog на протилежний
   1552                  GPIO_WriteBit(
   1553                                GPIO_EXTERNAL_WATCHDOG,
   1554                                GPIO_PIN_EXTERNAL_WATCHDOG,
   1555                                (BitAction)(1 - GPIO_ReadOutputDataBit(GPIO_EXTERNAL_WATCHDOG, GPIO_PIN_EXTERNAL_WATCHDOG))
   1556                               );
   1557                }
   1558                
   1559                main_routines_for_i2c();
   1560                changing_diagnostyka_state();//Підготовлюємо новий потенційно можливий запис для реєстратора програмних подій
   1561                //Оскільки ще тамер вимірювальної системи не запущений, то цю операцію треба робити тут
   1562                if (_CHECK_SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT) != 0)
   1563                {
   1564                  //Повне роозблоковування запуск заблокованих задач запису в EEPROM для драйверу I2C
   1565                  _CLEAR_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);
   1566                }
   1567              }
   1568            }
   1569          }  
   1570          /**************************************/
   1571          
   1572          /**************************************/
   1573          //стартова перевірка (і при необхідності перенастройка на потрібні параметри) DataFlash
   1574          /**************************************/
   1575          void start_checking_dataflash(void)
   1576          {
   1577            //Читаємо статуми мікросхеми 1
   1578            unsigned char page_size_256, page_size_256_total = 1;
   1579            unsigned int ready_busy;
   1580            number_chip_dataflsh_exchange = INDEX_DATAFLASH_1;
   1581            
   1582            for (unsigned int i = 0; i < NUMBER_DATAFLASH_CHIP; i++)
   1583            {
   1584              page_size_256 = 1;
   1585              dataflash_status_read(number_chip_dataflsh_exchange);
   1586              while (driver_spi_df[number_chip_dataflsh_exchange].state_execution != TRANSACTION_EXECUTED_WAIT_ANALIZE)
   1587              {
   1588                if (driver_spi_df[number_chip_dataflsh_exchange].state_execution == TRANSACTION_EXECUTING_NONE)
   1589                {
   1590                  /*
   1591                  ця ситуація могла виникнути тільки в одному випадку - якщо в процесі прийом/передачі
   1592                  зафісована була помилка у SPI_DF, тому повторно виконуємо запуск читання регістру статусу
   1593                  */
   1594                  dataflash_status_read(number_chip_dataflsh_exchange);
   1595                }
   1596                
   1597                //Робота з watchdogs
   1598                if ((control_word_of_watchdog & WATCHDOG_KYYBOARD) == WATCHDOG_KYYBOARD)
   1599                {
   1600                  //Змінюємо стан біту зовнішнього Watchdog на протилежний
   1601                  GPIO_WriteBit(
   1602                                GPIO_EXTERNAL_WATCHDOG,
   1603                                GPIO_PIN_EXTERNAL_WATCHDOG,
   1604                                (BitAction)(1 - GPIO_ReadOutputDataBit(GPIO_EXTERNAL_WATCHDOG, GPIO_PIN_EXTERNAL_WATCHDOG))
   1605                               );
   1606                }
   1607              }
   1608              page_size_256 &= RxBuffer_SPI_DF[1] & (1<< 0); 
   1609              ready_busy = RxBuffer_SPI_DF[1] & (1<< 7);
   1610              driver_spi_df[number_chip_dataflsh_exchange].state_execution = TRANSACTION_EXECUTING_NONE;
   1611              driver_spi_df[number_chip_dataflsh_exchange].code_operation = CODE_OPERATION_NONE;
   1612              if (page_size_256 == 0)
   1613              {
   1614                //Треба подати команду на перевід мікросхеми з розміром сторінки 256 байт
   1615                
   1616                //Перевіряємо, чи мікросхема зараз є вільною по біту Ready/Busy
   1617                while (ready_busy == 0)/*перший раз біт ready/busy беремо з попередньої операції читання регістру статусу*/
   1618                {
   1619                  dataflash_status_read(number_chip_dataflsh_exchange);
   1620                  while (driver_spi_df[number_chip_dataflsh_exchange].state_execution != TRANSACTION_EXECUTED_WAIT_ANALIZE)
   1621                  {
   1622                    if (driver_spi_df[number_chip_dataflsh_exchange].state_execution == TRANSACTION_EXECUTING_NONE)
   1623                    {
   1624                      /*
   1625                      ця ситуація могла виникнути тільки в одному випадку - якщо в процесі прийом/передачі
   1626                      зафісована була помилка у SPI_DF, тому повторно виконуємо запуск читання регістру статусу
   1627                      */
   1628                      dataflash_status_read(number_chip_dataflsh_exchange);
   1629                    }
   1630                    
   1631                    //Робота з watchdogs
   1632                    if ((control_word_of_watchdog & WATCHDOG_KYYBOARD) == WATCHDOG_KYYBOARD)
   1633                    {
   1634                      //Змінюємо стан біту зовнішнього Watchdog на протилежний
   1635                      GPIO_WriteBit(
   1636                                    GPIO_EXTERNAL_WATCHDOG,
   1637                                    GPIO_PIN_EXTERNAL_WATCHDOG,
   1638                                    (BitAction)(1 - GPIO_ReadOutputDataBit(GPIO_EXTERNAL_WATCHDOG, GPIO_PIN_EXTERNAL_WATCHDOG))
   1639                                   );
   1640                    }
   1641                  }
   1642                  ready_busy = RxBuffer_SPI_DF[1] & (1<< 7);
   1643                  driver_spi_df[number_chip_dataflsh_exchange].state_execution = TRANSACTION_EXECUTING_NONE;
   1644                  driver_spi_df[number_chip_dataflsh_exchange].code_operation = CODE_OPERATION_NONE;
   1645                }
   1646                
   1647                //Подаємо команду на переналаштування DataFlash
   1648                dataflash_set_pagesize_256(number_chip_dataflsh_exchange);
   1649                while (driver_spi_df[number_chip_dataflsh_exchange].state_execution != TRANSACTION_EXECUTED_WAIT_ANALIZE)
   1650                {
   1651                  /*
   1652                  Тут я вирішив не аналізувати випадок збою, бо після виконання цієї операції
   1653                  треба буде виклю чити і включити прилад (причому скоріше всього це буде на заводі), 
   1654                  тому у гіршому випадку мікросхема скаже, що вона ще не переведена на потрібну ширину сторінки
   1655                  */
   1656                  
   1657                  //Робота з watchdogs
   1658                  if ((control_word_of_watchdog & WATCHDOG_KYYBOARD) == WATCHDOG_KYYBOARD)
   1659                  {
   1660                    //Змінюємо стан біту зовнішнього Watchdog на протилежний
   1661                    GPIO_WriteBit(
   1662                                  GPIO_EXTERNAL_WATCHDOG,
   1663                                  GPIO_PIN_EXTERNAL_WATCHDOG,
   1664                                  (BitAction)(1 - GPIO_ReadOutputDataBit(GPIO_EXTERNAL_WATCHDOG, GPIO_PIN_EXTERNAL_WATCHDOG))
   1665                                 );
   1666                  }
   1667                }
   1668                driver_spi_df[number_chip_dataflsh_exchange].state_execution = TRANSACTION_EXECUTING_NONE;
   1669                driver_spi_df[number_chip_dataflsh_exchange].code_operation = CODE_OPERATION_NONE;
   1670                
   1671                //Очікуємо, поки попредня команда переналаштування мікросхеми виконається
   1672                do
   1673                {
   1674                  dataflash_status_read(number_chip_dataflsh_exchange);
   1675                  while (driver_spi_df[number_chip_dataflsh_exchange].state_execution != TRANSACTION_EXECUTED_WAIT_ANALIZE)
   1676                  {
   1677                    if (driver_spi_df[number_chip_dataflsh_exchange].state_execution == TRANSACTION_EXECUTING_NONE)
   1678                    {
   1679                      /*
   1680                      ця ситуація могла виникнути тільки в одному випадку - якщо в процесі прийом/передачі
   1681                      зафісована була помилка у SPI_DF, тому повторно виконуємо запуск читання регістру статусу
   1682                      */
   1683                      dataflash_status_read(number_chip_dataflsh_exchange);
   1684                    }
   1685                
   1686                    //Робота з watchdogs
   1687                    if ((control_word_of_watchdog & WATCHDOG_KYYBOARD) == WATCHDOG_KYYBOARD)
   1688                    {
   1689                      //Змінюємо стан біту зовнішнього Watchdog на протилежний
   1690                      GPIO_WriteBit(
   1691                                    GPIO_EXTERNAL_WATCHDOG,
   1692                                    GPIO_PIN_EXTERNAL_WATCHDOG,
   1693                                    (BitAction)(1 - GPIO_ReadOutputDataBit(GPIO_EXTERNAL_WATCHDOG, GPIO_PIN_EXTERNAL_WATCHDOG))
   1694                                   );
   1695                    }
   1696                  }
   1697                  ready_busy = RxBuffer_SPI_DF[1] & (1<< 7);
   1698                  driver_spi_df[number_chip_dataflsh_exchange].state_execution = TRANSACTION_EXECUTING_NONE;
   1699                  driver_spi_df[number_chip_dataflsh_exchange].code_operation = CODE_OPERATION_NONE;
   1700                }
   1701                while (ready_busy == 0);/*біт ready/busy беремо з попереднії операцій читання регістру статусу, а з нової операції читання регістру статсусу*/
   1702                
   1703              }
   1704          
   1705              page_size_256_total &=  page_size_256;
   1706              number_chip_dataflsh_exchange = (number_chip_dataflsh_exchange + 1) & (NUMBER_DATAFLASH_CHIP - 1);
   1707            }
   1708            
   1709            if (error_into_spi_df != 0)
   1710            {
   1711              /*
   1712              Якщо була зафіксована помилка під час переходу на ширину сторінки 256 байт
   1713              (під час читання регістру статусу змінна error_into_spi_df не встановлюється
   1714              у ненульове значення), то робимо примусовий перезапуск з допомогою внутрішнього
   1715              (і зовнішнього, якщо джампер є) watchdog-а
   1716              */
   1717              while(1);
   1718            }
   1719            
   1720            if (page_size_256_total == 0)
   1721            {
   1722              const unsigned char name_string[MAX_NAMBER_LANGUAGE][2][MAX_COL_LCD] = 
   1723              {
   1724                {
   1725                  " Перезапустите  ",
   1726                  "   устройство   "
   1727                },
   1728                {
   1729                  " Перезапустіть  ",
   1730                  "    пристрій    "
   1731                },
   1732                {
   1733                  "     Reset      ",
   1734                  "   the device   "
   1735                },
   1736                {
   1737                  " Перезапустите  ",
   1738                  "   устройство   "
   1739                }
   1740              };
   1741          
   1742              int index_language = index_language_in_array(settings_fix_prt.language);
   1743              
   1744              //Робота з watchdogs
   1745              if ((control_word_of_watchdog & WATCHDOG_KYYBOARD) == WATCHDOG_KYYBOARD)
   1746              {
   1747                //Змінюємо стан біту зовнішнього Watchdog на протилежний
   1748                GPIO_WriteBit(
   1749                              GPIO_EXTERNAL_WATCHDOG,
   1750                              GPIO_PIN_EXTERNAL_WATCHDOG,
   1751                              (BitAction)(1 - GPIO_ReadOutputDataBit(GPIO_EXTERNAL_WATCHDOG, GPIO_PIN_EXTERNAL_WATCHDOG))
   1752                             );
   1753              }
   1754          
   1755              //Копіюємо  рядки у робочий екран
   1756              for (unsigned int i=0; i< MAX_ROW_LCD; i++)
   1757              {
   1758                for (unsigned int j = 0; j<MAX_COL_LCD; j++) working_ekran[i][j] = name_string[index_language][i][j];
   1759              }
   1760            
   1761              //Обновити повністю весь екран
   1762              current_state_menu2.current_action = ACTION_WITH_CARRENT_EKRANE_FULL_UPDATE;
   1763          
   1764              //Обновляємо інформацію на екрані
   1765              view_whole_ekran();
   1766              
   1767              //Чекаємо, поки пристрій буде перезапущений
   1768              while(1)
   1769              {
   1770                //Робота з watchdogs
   1771                if ((control_word_of_watchdog & WATCHDOG_KYYBOARD) == WATCHDOG_KYYBOARD)
   1772                {
   1773                  //Змінюємо стан біту зовнішнього Watchdog на протилежний
   1774                  GPIO_WriteBit(
   1775                                GPIO_EXTERNAL_WATCHDOG,
   1776                                GPIO_PIN_EXTERNAL_WATCHDOG,
   1777                                (BitAction)(1 - GPIO_ReadOutputDataBit(GPIO_EXTERNAL_WATCHDOG, GPIO_PIN_EXTERNAL_WATCHDOG))
   1778                               );
   1779                }
   1780              }
   1781            }
   1782          }
   1783          /**************************************/
   1784          
   1785          /**************************************/
   1786          //Запускаємо канал 2 таймеру 4 на генерацію переривань кожну 1 мс
   1787          /**************************************/
   1788          void start_tim4_canal2_for_interrupt_1mc(void)
   1789          {
   1790            TIM_OCInitTypeDef  TIM_OCInitStructure;
   1791          
   1792            /* Output Compare Timing Mode настроювання: Канал:2 */
   1793            TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_Timing;
   1794            TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Disable;
   1795            TIM_OCInitStructure.TIM_Pulse = ((uint16_t)TIM4->CNT) + TIM4_CCR2_VAL;
   1796            TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
   1797            TIM_OC2Init(TIM4, &TIM_OCInitStructure);
   1798            
   1799            TIM_OC2PreloadConfig(TIM4, TIM_OCPreload_Disable);
   1800          
   1801            /* Дозволяємо переривання від каналу 2 таймера 4*/
   1802            TIM_ITConfig(TIM4, TIM_IT_CC2, ENABLE);
   1803          
   1804          //  //Обновляємо новий час запуску переривання
   1805          //  TIM4->CCR2 = ((uint16_t)TIM4->CNT) + TIM4_CCR2_VAL;
   1806          }
   1807          /**************************************/
   1808          
   1809          /**************************************/
   1810          //Запускаємо канал 3 таймеру 4 на генерацію переривань як мінімум 10 мкс
   1811          /**************************************/
   1812          void start_tim4_canal3_for_interrupt_10mkc(void)
   1813          {
   1814            TIM_OCInitTypeDef  TIM_OCInitStructure;
   1815            
   1816            if (number_bits_rs_485_waiting < 10) calculate_namber_bit_waiting_for_rs_485();
   1817          
   1818            /* Output Compare Timing Mode настроювання: Канал:2 */
   1819            TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_Timing;
   1820            TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Disable;
   1821            unsigned int delta = TIM4_CCR3_VAL*number_bits_rs_485_waiting;
   1822            TIM_OCInitStructure.TIM_Pulse = ((uint16_t)TIM4->CNT) + delta;
   1823            TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;
   1824            TIM_OC3Init(TIM4, &TIM_OCInitStructure);
   1825            
   1826            TIM_OC3PreloadConfig(TIM4, TIM_OCPreload_Disable);
   1827          
   1828            /* Дозволяємо переривання від каналу 3 таймера 4*/
   1829            TIM_ITConfig(TIM4, TIM_IT_CC3, ENABLE);
   1830          }
   1831          /**************************************/
   1832          
   1833          /**************************************/
   1834          //
   1835          /**************************************/
   1836          /**************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      48   Configure_I2C
        48   -> GPIO_Init
        48   -> GPIO_PinAFConfig
        48   -> GPIO_ReadInputDataBit
        48   -> GPIO_ReadOutputDataBit
        48   -> GPIO_ResetBits
        48   -> GPIO_SetBits
        48   -> I2C_Cmd
        48   -> I2C_ITConfig
        48   -> I2C_Init
        48   -> I2C_SoftwareResetCmd
     600   error_reading_with_eeprom
       600   -> GPIO_ReadOutputDataBit
       600   -> GPIO_WriteBit
       600   -> __aeabi_memcpy4
       600   -> changing_diagnostyka_state
       600   -> index_language_in_array
       600   -> main_routines_for_i2c
       600   -> min_config
       600   -> min_settings
       600   -> view_whole_ekran
       0   global_vareiables_installation
       0   min_config
       0   min_settings
     152   start_checking_dataflash
       152   -> GPIO_ReadOutputDataBit
       152   -> GPIO_WriteBit
       152   -> __aeabi_memcpy4
       152   -> dataflash_set_pagesize_256
       152   -> dataflash_status_read
       152   -> index_language_in_array
       152   -> view_whole_ekran
     152   start_settings_peripherals
       152   -> Configure_I2C
       152   -> DBGMCU_APB1PeriphConfig
       152   -> DMA_ClearFlag
       152   -> DMA_DeInit
       152   -> DMA_GetCmdStatus
       152   -> DMA_Init
       152   -> EXTI_Init
       152   -> FSMC_SRAM_Init
       152   -> GPIO_Init
       152   -> GPIO_PinAFConfig
       152   -> GPIO_ReadOutputDataBit
       152   -> GPIO_ResetBits
       152   -> GPIO_SetBits
       152   -> GPIO_WriteBit
       152   -> Interrupts_Config
       152   -> SPI_Cmd
       152   -> SPI_I2S_DMACmd
       152   -> SPI_I2S_GetFlagStatus
       152   -> SPI_I2S_ITConfig
       152   -> SPI_I2S_ReceiveData
       152   -> SPI_I2S_SendData
       152   -> SPI_Init
       152   -> SYSCFG_EXTILineConfig
       152   -> Set_System
       152   -> TIM_Cmd
       152   -> TIM_ITConfig
       152   -> TIM_OC1Init
       152   -> TIM_OC1PreloadConfig
       152   -> TIM_TimeBaseInit
       152   -> USBD_Init
       152   -> changing_diagnostyka_state
       152   -> global_vareiables_installation
       152   -> main_routines_for_i2c
       152   -> test_external_SRAM
      24   start_tim4_canal2_for_interrupt_1mc
        24   -> TIM_ITConfig
        24   -> TIM_OC2Init
        24   -> TIM_OC2PreloadConfig
      32   start_tim4_canal3_for_interrupt_10mkc
        32   -> TIM_ITConfig
        32   -> TIM_OC3Init
        32   -> TIM_OC3PreloadConfig
        32   -> calculate_namber_bit_waiting_for_rs_485
       8   test_external_SRAM


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_10
       4  ??DataTable1_11
       4  ??DataTable1_12
       4  ??DataTable1_13
       4  ??DataTable1_14
       4  ??DataTable1_15
       4  ??DataTable1_16
       4  ??DataTable1_17
       4  ??DataTable1_18
       4  ??DataTable1_19
       4  ??DataTable1_2
       4  ??DataTable1_20
       4  ??DataTable1_21
       4  ??DataTable1_22
       4  ??DataTable1_23
       4  ??DataTable1_24
       4  ??DataTable1_25
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
       4  ??DataTable1_8
       4  ??DataTable1_9
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_13
       4  ??DataTable3_14
       4  ??DataTable3_15
       4  ??DataTable3_16
       4  ??DataTable3_17
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_15
       4  ??DataTable6_16
       4  ??DataTable6_17
       4  ??DataTable6_18
       4  ??DataTable6_19
       4  ??DataTable6_2
       4  ??DataTable6_20
       4  ??DataTable6_21
       4  ??DataTable6_22
       4  ??DataTable6_23
       4  ??DataTable6_24
       4  ??DataTable6_25
       4  ??DataTable6_26
       4  ??DataTable6_27
       4  ??DataTable6_28
       4  ??DataTable6_29
       4  ??DataTable6_3
       4  ??DataTable6_30
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
     448  ?_0
     128  ?_1
     128  ?_2
    1562  Configure_I2C
     764  error_reading_with_eeprom
     638  global_vareiables_installation
      72  min_config
     154  min_settings
     680  start_checking_dataflash
    2856  start_settings_peripherals
      62  start_tim4_canal2_for_interrupt_1mc
      78  start_tim4_canal3_for_interrupt_10mkc
      92  test_external_SRAM

 
   704 bytes in section .rodata
 7 298 bytes in section .text
 
 7 206 bytes of CODE  memory (+ 92 bytes shared)
   704 bytes of CONST memory

Errors: none
Warnings: none
