###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       24/Mar/2017  12:54:56
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\menu_choose_communication_parameters.c
#    Command line =  
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\menu_choose_communication_parameters.c" -D
#        USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -D KEYBOARD_VER_1
#        -D SYSTEM_VIEWER_ENABLE -lc
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List" --remarks -o
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --enable_multibytes --fpu=None
#        --dlib_config G:\PRG\IAR7_50_2\arm\INC\c\DLib_Config_Full.h -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\usb\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_OTG_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Core\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\"
#        -I "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\Config\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\OS\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\SEGGER\" -On --use_c++_inline
#        --require_prototypes -I G:\PRG\IAR7_50_2\arm\CMSIS\Include\ -D
#        ARM_MATH_CM3
#    List file    =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List\menu_choose_communication_parameters.lst
#    Object file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj\menu_choose_communication_parameters.o
#
###############################################################################

G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working files\src\menu_choose_communication_parameters.c
      1          #include "header.h"
      2          
      3          /*****************************************************/
      4          //Формуємо екран відображення заголовків настроювання комунікації
      5          /*****************************************************/
      6          void make_ekran_choose_communication_parameters(void)
      7          {
      8            const uint8_t name_string[MAX_NAMBER_LANGUAGE][MAX_ROW_CHCP_M2][MAX_COL_LCD + 1] = 
      9            {
     10              {
     11                " Имя ячейки     ",
     12                " Адрес ячейки   ",
     13                " Настр.RS-485   "
     14              },
     15              {
     16                " Ім'я комірки   ",
     17                " Адреса комірки ",
     18                " Налашт.RS-485  "
     19              },
     20              {
     21                " Bay name       ",
     22                " Bay Address    ",
     23                " RS-485 Settings"
     24              },
     25              {
     26                " Имя ячейки     ",
     27                " Адрес ячейки   ",
     28                " Настр.RS-485   "
     29              }
     30            };
     31            int index_language = index_language_in_array(select_struct_settings_fix()->language);
     32          
     33            unsigned int position_temp = current_state_menu2.index_position;
     34            unsigned int index_in_ekran = (position_temp >> POWER_MAX_ROW_LCD) << POWER_MAX_ROW_LCD;
     35            
     36            //Копіюємо  рядки у робочий екран
     37            for (size_t i = 0; i < MAX_ROW_LCD; i++)
     38            {
     39              for (size_t j = 0; j < MAX_COL_LCD; j++) 
     40              {
     41                working_ekran[i][j] = (index_in_ekran < MAX_ROW_CHCP_M2) ? name_string[index_language][index_in_ekran][j] : ' ';
     42              }
     43              index_in_ekran++;
     44            }
     45          
     46            //Курсор по горизонталі відображається на першій позиції
     47            current_state_menu2.position_cursor_x = 0;
     48            //Відображення курору по вертикалі
     49            current_state_menu2.position_cursor_y = position_temp & (MAX_ROW_LCD - 1);
     50            //Курсор видимий
     51            current_state_menu2.cursor_on = 1;
     52            //Курсор не мигає
     53            current_state_menu2.cursor_blinking_on = 0;
     54            //Обновити повністю весь екран
     55            current_state_menu2.current_action = ACTION_WITH_CARRENT_EKRANE_FULL_UPDATE;
     56          }
     57          /*****************************************************/
     58          
     59          /*****************************************************/
     60          //Формуємо екран відображення імені ячейки
     61          /*****************************************************/
     62          void make_ekran_name_of_cell(void)
     63          {
     64            //Можливо треба буде додати  нові символи при зміні мови цією функцією
     65            index_language_in_array(select_struct_settings_fix()->language);
     66            
     67            unsigned int position_temp = current_state_menu2.index_position;
     68            unsigned int index_in_ekran = (position_temp >> POWER_MAX_ROW_LCD) << POWER_MAX_ROW_LCD;
     69            
     70              uint8_t *p_name_of_cell;
     71              p_name_of_cell = (current_state_menu2.edition == ED_VIEWING) ? settings_fix_prt.name_of_cell : settings_fix.name_of_cell;
     72            //Копіюємо  рядки у робочий екран
     73            for (size_t i = 0; i < MAX_ROW_LCD; i++)
     74            {
     75              for (size_t j = 0; j<MAX_COL_LCD; j++)
     76              {
     77                 uint8_t symbol = (((index_in_ekran << POWER_MAX_COL_LCD) + j) < MAX_CHAR_IN_NAME_OF_CELL) ? p_name_of_cell[(index_in_ekran << POWER_MAX_COL_LCD) + j] : ' ';
     78                 working_ekran[i][j] = (symbol >= 0x20) ? symbol : ' ';
     79              }
     80          
     81              index_in_ekran++;
     82            }
     83          
     84            //Курсор по горизонталі відображається на першій позиції
     85            current_state_menu2.position_cursor_x = 0;
     86            //Відображення курору по вертикалі
     87            current_state_menu2.position_cursor_y = position_temp & (MAX_ROW_LCD - 1);
     88            //Курсор  не видимий
     89            current_state_menu2.cursor_on = 0;
     90            //Курсор не мигає
     91            current_state_menu2.cursor_blinking_on = 0;
     92            //Обновити повністю весь екран
     93            current_state_menu2.current_action = ACTION_WITH_CARRENT_EKRANE_FULL_UPDATE;
     94          }
     95          /*****************************************************/
     96          
     97          /*****************************************************/
     98          //Формуємо екран відображення адреси для комунікації з верхнім рівнем
     99          /*****************************************************/
    100          void make_ekran_address(void)
    101          {
    102            if (
    103                (current_state_menu2.edition == ED_WARNING_EDITION_BUSY) ||
    104                (current_state_menu2.edition == ED_WARNING_ENTER_ESC)
    105               )   
    106            {
    107              const uint8_t information_about_info[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
    108              {
    109                "Ред.не разрешено",
    110                "Ред.не дозволене",
    111                "Ed.isn't allowed",
    112                "Ред.не разрешено",
    113              };
    114          
    115              const uint8_t information_about_error[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
    116              {
    117                " Вых.за диапазон",
    118                " Вих.за діапазон",
    119                "  Out of Limits ",
    120                "Вых.за диапазон "
    121              };
    122          
    123              enum _edition_stats edition = current_state_menu2.edition;
    124              make_ekran_about_info(((edition == ED_WARNING_EDITION_BUSY) ? false : true), ((edition == ED_WARNING_EDITION_BUSY) ? information_about_info : information_about_error));
    125            }
    126            else
    127            {
    128              const uint8_t name_string[MAX_NAMBER_LANGUAGE][MAX_ROW_ADDRESS_M2][MAX_COL_LCD + 1] = 
    129              {
    130                "     Адрес      ",
    131                "     Адреса     ",
    132                "    Address     ",
    133                "     Адрес      "
    134              };
    135              int index_language = index_language_in_array(select_struct_settings_fix()->language);
    136            
    137              unsigned int position_temp = current_state_menu2.index_position;
    138              //Множення на два величини position_temp потрібне для того, бо на одну позицію ми використовуємо два рядки (назва + значення)
    139              unsigned int index_in_ekran = ((position_temp << 1) >> POWER_MAX_ROW_LCD) << POWER_MAX_ROW_LCD;
    140          
    141              uint32_t *p_address;
    142              if (current_state_menu2.edition == ED_VIEWING) p_address = &settings_fix_prt.address;
    143              else if (current_state_menu2.edition == ED_CAN_BE_EDITED) p_address = &settings_fix.address;
    144              else p_address = &settings_fix_edit.address;
    145            
    146              unsigned int first_symbol;
    147              uint32_t vaga, value;
    148            
    149              for (size_t i = 0; i < MAX_ROW_LCD; i++)
    150              {
    151                unsigned int index_in_ekran_tmp = index_in_ekran >> 1;
    152                if (index_in_ekran_tmp < MAX_ROW_ADDRESS_M2)
    153                {
    154                  if ((i & 0x1) == 0)
    155                  {
    156                    //У непарному номері рядку виводимо заголовок
    157                    for (size_t j = 0; j < MAX_COL_LCD; j++) working_ekran[i][j] = name_string[index_language][index_in_ekran_tmp][j];
    158          
    159                    first_symbol = 0; //помічаємо, що ще ніодин значущий символ не виведений
    160                    vaga = 100; //максимальний ваговий коефіцієнт
    161                    value = *p_address;
    162                  }
    163                  else
    164                  {
    165                    //У парному номері рядку виводимо значення уставки
    166                    for (size_t j = 0; j < MAX_COL_LCD; j++)
    167                    {
    168                      if ((j < COL_ADDRESS_BEGIN) ||  (j > COL_ADDRESS_END ))working_ekran[i][j] = ' ';
    169                      else
    170                        calc_int_symbol_and_put_into_working_ekran((working_ekran[i] + j), &value, &vaga, &first_symbol);
    171                    }
    172                  }
    173                }
    174                else
    175                  for (size_t j = 0; j < MAX_COL_LCD; j++) working_ekran[i][j] = ' ';
    176          
    177                index_in_ekran++;
    178              }
    179          
    180              //Відображення курору по вертикалі і курсор завжди має бути у полі із значенням устаки
    181              current_state_menu2.position_cursor_y = ((position_temp<<1) + 1) & (MAX_ROW_LCD - 1);
    182          
    183              if (current_state_menu2.edition <= ED_CAN_BE_EDITED)
    184              {
    185                int last_position_cursor_x = MAX_COL_LCD;
    186                current_state_menu2.position_cursor_x = COL_ADDRESS_BEGIN;
    187                last_position_cursor_x = COL_ADDRESS_END;
    188          
    189                //Підтягуємо курсор до першого символу
    190                while (
    191                       ((working_ekran[current_state_menu2.position_cursor_y][current_state_menu2.position_cursor_x + 1]) == ' ') && 
    192                       (current_state_menu2.position_cursor_x < (last_position_cursor_x -1))
    193                      )
    194                {
    195                  current_state_menu2.position_cursor_x++;
    196                }
    197          
    198                //Курсор ставимо так, щоб він був перед числом
    199                if (
    200                    ((working_ekran[current_state_menu2.position_cursor_y][current_state_menu2.position_cursor_x]) != ' ') && 
    201                    (current_state_menu2.position_cursor_x > 0)
    202                   )
    203                {
    204                  current_state_menu2.position_cursor_x--;
    205                }
    206              }
    207              //Курсор видимий
    208              current_state_menu2.cursor_on = 1;
    209              //Курсор не мигає
    210              if(current_state_menu2.edition <= ED_CAN_BE_EDITED) current_state_menu2.cursor_blinking_on = 0;
    211              else current_state_menu2.cursor_blinking_on = 1;
    212            }
    213            //Обновити повністю весь екран
    214            current_state_menu2.current_action = ACTION_WITH_CARRENT_EKRANE_FULL_UPDATE;
    215          }
    216          /*****************************************************/
    217          
    218          /*****************************************************/
    219          /*
    220          Натискування Enter у вікні відображення адреси
    221          */
    222          /*****************************************************/
    223          enum _result_pressed_enter_during_edition press_enter_in_address(void)
    224          {
    225            enum _result_pressed_enter_during_edition result = RPEDE_NONE;
    226            switch (current_state_menu2.edition)
    227            {
    228            case ED_VIEWING:
    229            case ED_CAN_BE_EDITED:
    230              {
    231                current_state_menu2.position_cursor_x = COL_ADDRESS_BEGIN;
    232                break;
    233              }
    234            case ED_EDITION:
    235              {
    236                //Перевіряємо, чи дані рельно змінилися
    237                result = RPEDE_DATA_NOT_CHANGED;
    238                
    239                uint32_t *p_value_edit = &settings_fix_edit.address;
    240                uint32_t *p_value_cont = &settings_fix.address;
    241          
    242                if (*p_value_cont != *p_value_edit) 
    243                {
    244                  if (check_data_setpoint(*p_value_edit, KOEF_ADDRESS_MIN, KOEF_ADDRESS_MAX) == 1)
    245                  {
    246                    *p_value_cont = *p_value_edit;
    247                        
    248                    config_settings_modified |= MASKA_CHANGED_SETTINGS;
    249                    result = RPEDE_DATA_CHANGED_OK;
    250                  }
    251                  else result = RPEDE_DATA_CHANGED_OUT_OF_RANGE;
    252                }
    253          
    254                break;
    255              }
    256            }
    257            
    258            return result;
    259          }
    260          /*****************************************************/
    261          
    262          /*****************************************************/
    263          /*
    264          Натискування ESC у вікні витримок дискретного входу
    265          */
    266          /*****************************************************/
    267          void press_esc_in_address(void)
    268          {
    269            uint32_t *p_value_edit = &settings_fix_edit.address;
    270            uint32_t *p_value_cont = &settings_fix.address;
    271          
    272            *p_value_edit = *p_value_cont;
    273          }
    274          /*****************************************************/
    275          
    276          /*****************************************************/
    277          //Зміна налаштувань допуску дискретного входу
    278          /*****************************************************
    279          Вхідні параметри
    280          (1 << BIT_KEY_DOWN) - натснуто кнопку вниз
    281          (1 << BIT_KEY_UP)   - атиснуто кнопку вверх
    282          (1 << BIT_KEY_RIGHT)- натснуто кнопку праворуч
    283          (1 << BIT_KEY_LEFT) - атиснуто кнопку ліворуч
    284          
    285          Вхідні параметри
    286            Немає
    287          *****************************************************/
    288          void change_address(unsigned int action)
    289          {
    290            //Вводимо число у відповідне поле
    291            if (action & ((1 << BIT_KEY_DOWN) | (1 << BIT_KEY_UP)))
    292            {
    293              settings_fix_edit.address = edit_setpoint(((action & (1 << BIT_KEY_UP)) != 0), settings_fix_edit.address, 0, 0, COL_ADDRESS_END, 1);
    294            }
    295            else if (
    296                     ((action & (1 << BIT_KEY_LEFT )) != 0) ||
    297                     ((action & (1 << BIT_KEY_RIGHT)) != 0)
    298                    )   
    299            {
    300              if (action & (1 << BIT_KEY_LEFT ))
    301              {
    302                current_state_menu2.position_cursor_x--;
    303                if ((current_state_menu2.position_cursor_x < COL_ADDRESS_BEGIN) ||
    304                    (current_state_menu2.position_cursor_x > COL_ADDRESS_END))
    305                  current_state_menu2.position_cursor_x = COL_ADDRESS_END;
    306              }
    307              else
    308              {
    309                current_state_menu2.position_cursor_x++;
    310                if ((current_state_menu2.position_cursor_x < COL_ADDRESS_BEGIN) ||
    311                    (current_state_menu2.position_cursor_x > COL_ADDRESS_END))
    312                  current_state_menu2.position_cursor_x = COL_ADDRESS_BEGIN;
    313              }
    314              
    315            }
    316          }
    317          /*****************************************************/
    318          
    319          /*****************************************************/
    320          //Формуємо екран відображення заголовків настроювання комунікації
    321          /*****************************************************/
    322          void make_ekran_choose_setting_RS485(void)
    323          {
    324            const uint8_t name_string[MAX_NAMBER_LANGUAGE][MAX_ROW_SETTING_RS485_M2][MAX_COL_LCD + 1] = 
    325            {
    326              {
    327                " Скорость обмена",
    328                " Контр.четности ",
    329                " Колич.стоп-бит ",
    330                " Конец приёма   "
    331              },
    332              {
    333                " Швидкість обм. ",
    334                " Контр.парності ",
    335                "Кільк.стоп-біт  ",
    336                "Кінець приймання"
    337              },
    338              {
    339                " Baud rate      ",
    340                " Parity         ",
    341                " Stop Bits      ",
    342                "End of Reception"
    343              },
    344              {
    345                " Скорость обмена",
    346                " Контр.четности ",
    347                " Колич.стоп-бит ",
    348                " Конец приёма   "
    349              }
    350            };
    351            int index_language = index_language_in_array(select_struct_settings_fix()->language);
    352            
    353            unsigned int position_temp = current_state_menu2.index_position;
    354            unsigned int index_in_ekran = (position_temp >> POWER_MAX_ROW_LCD) << POWER_MAX_ROW_LCD;
    355            
    356            //Копіюємо  рядки у робочий екран
    357            for (size_t i = 0; i < MAX_ROW_LCD; i++)
    358            {
    359              for (size_t j = 0; j < MAX_COL_LCD; j++) 
    360              {
    361                working_ekran[i][j] = (index_in_ekran < MAX_ROW_SETTING_RS485_M2) ? name_string[index_language][index_in_ekran][j] : ' ';
    362              }
    363              index_in_ekran++;
    364            }
    365          
    366            //Курсор по горизонталі відображається на першій позиції
    367            current_state_menu2.position_cursor_x = 0;
    368            //Відображення курору по вертикалі
    369            current_state_menu2.position_cursor_y = position_temp & (MAX_ROW_LCD - 1);
    370            //Курсор видимий
    371            current_state_menu2.cursor_on = 1;
    372            //Курсор не мигає
    373            current_state_menu2.cursor_blinking_on = 0;
    374            //Обновити повністю весь екран
    375            current_state_menu2.current_action = ACTION_WITH_CARRENT_EKRANE_FULL_UPDATE;
    376          }
    377          /*****************************************************/
    378          
    379          /*****************************************************/
    380          //Формуємо екран відображення швидкостіобміну для інтерфейсу
    381          /*****************************************************/
    382          void make_ekran_baud_RS485(void)
    383          {
    384            if (
    385                (current_state_menu2.edition == ED_WARNING_EDITION_BUSY) ||
    386                (current_state_menu2.edition == ED_WARNING_ENTER_ESC)
    387               )   
    388            {
    389              const uint8_t information_about_info[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
    390              {
    391                "Ред.не разрешено",
    392                "Ред.не дозволене",
    393                "Ed.isn't allowed",
    394                "Ред.не разрешено",
    395              };
    396          
    397              const uint8_t information_about_error[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
    398              {
    399                " Вых.за диапазон",
    400                " Вих.за діапазон",
    401                "  Out of Limits ",
    402                "Вых.за диапазон "
    403              };
    404          
    405              enum _edition_stats edition = current_state_menu2.edition;
    406              make_ekran_about_info(((edition == ED_WARNING_EDITION_BUSY) ? false : true), ((edition == ED_WARNING_EDITION_BUSY) ? information_about_info : information_about_error));
    407            }
    408            else
    409            {
    410              const unsigned char name_string[MAX_NAMBER_LANGUAGE][MAX_ROW_FOR_VIEW_BAUD_RS485][MAX_COL_LCD + 1] = 
    411              {
    412                " Скорость обмена",
    413                " Швидкість обм. ",
    414                "   Baud rate    ",
    415                " Скорость обмена"
    416              };
    417              int index_language = index_language_in_array(select_struct_settings_fix()->language);
    418            
    419              unsigned int position_temp = current_state_menu2.index_position;
    420              //Множення на два величини position_temp потрібне для того, бо на одну позицію ми використовуємо два рядки (назва + значення)
    421              unsigned int index_in_ekran = ((position_temp << 1) >> POWER_MAX_ROW_LCD) << POWER_MAX_ROW_LCD;
    422          
    423              uint32_t value;
    424              if (current_state_menu2.edition == ED_VIEWING) value = settings_fix_prt.baud_RS485;
    425              else if (current_state_menu2.edition == ED_CAN_BE_EDITED) value = settings_fix.baud_RS485;
    426              else value = settings_fix_edit.baud_RS485;
    427            
    428              for (size_t i = 0; i < MAX_ROW_LCD; i++)
    429              {
    430                unsigned int index_in_ekran_tmp = index_in_ekran >> 1;
    431                if (index_in_ekran_tmp < MAX_ROW_FOR_VIEW_BAUD_RS485)
    432                {
    433                  if ((i & 0x1) == 0)
    434                  {
    435                    //У непарному номері рядку виводимо заголовок
    436                    for (size_t j = 0; j < MAX_COL_LCD; j++) working_ekran[i][j] = name_string[index_language][index_in_ekran_tmp][j];
    437                  }
    438                  else
    439                  {
    440                    //У парному номері рядку виводимо значення уставки
    441                    if (value < MAX_NUMBER_BAUD_RS485)
    442                    {
    443                      const uint8_t information[MAX_NUMBER_BAUD_RS485][MAX_COL_LCD + 1] = 
    444                      {
    445                        "      9600      ",
    446                        "     14400      ",
    447                        "     19200      ",
    448                        "     28800      ",
    449                        "     38400      ",
    450                        "     57600      ",
    451                        "     115200     "
    452                      };
    453                      const unsigned int cursor_x[MAX_NUMBER_BAUD_RS485] = {5, 4, 4, 4, 4, 4, 4};
    454          
    455                      for (size_t j = 0; j < MAX_COL_LCD; j++) working_ekran[i][j] = information[value][j];
    456                      if (position_temp == index_in_ekran_tmp)
    457                      {
    458                        current_state_menu2.position_cursor_x = cursor_x[value];
    459                      }
    460                    }
    461                    else
    462                    {
    463                      const uint8_t information_error[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
    464                      {
    465                        "     Ошибка     ",
    466                        "    Помилка     ",
    467                        "     Error      ",
    468                        "     Ошибка     "
    469                      };
    470                      const unsigned int cursor_x_error[MAX_NAMBER_LANGUAGE] = {4, 3, 4, 4};
    471          
    472                      for (size_t j = 0; j < MAX_COL_LCD; j++) working_ekran[i][j] = information_error[index_language][j];
    473                      if (position_temp == index_in_ekran_tmp)
    474                      {
    475                        current_state_menu2.position_cursor_x = cursor_x_error[index_language];
    476                      }
    477                    }
    478                  }
    479                }
    480                else
    481                  for (size_t j = 0; j < MAX_COL_LCD; j++) working_ekran[i][j] = ' ';
    482          
    483                index_in_ekran++;
    484              }
    485          
    486              //Відображення курору по вертикалі і курсор завжди має бути у полі із значенням устаки
    487              current_state_menu2.position_cursor_y = ((position_temp << 1) + 1) & (MAX_ROW_LCD - 1);
    488              //Курсор видимий
    489              current_state_menu2.cursor_on = 1;
    490              //Курсор не мигає
    491              if(current_state_menu2.edition <= ED_CAN_BE_EDITED) current_state_menu2.cursor_blinking_on = 0;
    492              else current_state_menu2.cursor_blinking_on = 1;
    493              //Обновити повністю весь екран
    494            }
    495            current_state_menu2.current_action = ACTION_WITH_CARRENT_EKRANE_FULL_UPDATE;
    496          }
    497          /*****************************************************/
    498          
    499          /*****************************************************/
    500          /*
    501          Натискування Enter у вікні відображення налаштувань швидкості
    502          */
    503          /*****************************************************/
    504          enum _result_pressed_enter_during_edition press_enter_in_baud_RS485(void)
    505          {
    506            enum _result_pressed_enter_during_edition result = RPEDE_NONE;
    507            switch (current_state_menu2.edition)
    508            {
    509            case ED_EDITION:
    510              {
    511                //Перевіряємо, чи дані рельно змінилися
    512                result = RPEDE_DATA_NOT_CHANGED;
    513                
    514                int32_t *p_value_edit = &settings_fix_edit.baud_RS485;
    515                int32_t *p_value_cont = &settings_fix.baud_RS485;
    516                if (*p_value_cont != *p_value_edit) 
    517                {
    518                  if (check_data_setpoint(*p_value_edit, VALUE_BAUD_RS485_MIN, VALUE_BAUD_RS485_MAX) == 1)
    519                  {
    520                    *p_value_cont = *p_value_edit;
    521                    
    522                    config_settings_modified |= MASKA_CHANGED_SETTINGS;
    523                    result = RPEDE_DATA_CHANGED_OK;
    524                  }
    525                  else result = RPEDE_DATA_CHANGED_OUT_OF_RANGE;
    526                }
    527          
    528                break;
    529              }
    530            }
    531            
    532            return result;
    533          }
    534          /*****************************************************/
    535          
    536          /*****************************************************/
    537          /*
    538          Натискування ESC у вікні налаштувань швидкості
    539          */
    540          /*****************************************************/
    541          void press_esc_in_baud_RS485(void)
    542          {
    543            settings_fix_edit.baud_RS485 = settings_fix.baud_RS485; 
    544          }
    545          /*****************************************************/
    546          
    547          /*****************************************************/
    548          //Зміна налаштувань швидкості
    549          /*****************************************************
    550          Вхідні параметри
    551          (1 << BIT_KEY_RIGHT)- натснуто кнопку праворуч
    552          (1 << BIT_KEY_LEFT) - атиснуто кнопку ліворуч
    553          
    554          Вхідні параметри
    555            Немає
    556          *****************************************************/
    557          void change_baud_RS485(unsigned int action)
    558          {
    559            //Вводимо число у відповідне поле
    560            if (
    561                ((action & (1 << BIT_KEY_LEFT )) != 0) ||
    562                ((action & (1 << BIT_KEY_RIGHT)) != 0)
    563               )   
    564            {
    565              int32_t value = settings_fix_edit.baud_RS485;
    566              if ((action & (1 << BIT_KEY_RIGHT)) != 0) 
    567              {
    568                if ((++value) > VALUE_BAUD_RS485_MAX)
    569                  value = VALUE_BAUD_RS485_MIN;
    570              }
    571              else 
    572              {
    573                if ((--value) < VALUE_BAUD_RS485_MIN)
    574                  value = VALUE_BAUD_RS485_MAX;
    575              }
    576              settings_fix_edit.baud_RS485 = value;
    577            }
    578          }
    579          /*****************************************************/
    580          
    581          /*****************************************************/
    582          //Формуємо екран відображення контролю парності для інтерфейсу
    583          /*****************************************************/
    584          void make_ekran_pare_RS485()
    585          {
    586            if (
    587                (current_state_menu2.edition == ED_WARNING_EDITION_BUSY) ||
    588                (current_state_menu2.edition == ED_WARNING_ENTER_ESC)
    589               )   
    590            {
    591              const uint8_t information_about_info[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
    592              {
    593                "Ред.не разрешено",
    594                "Ред.не дозволене",
    595                "Ed.isn't allowed",
    596                "Ред.не разрешено",
    597              };
    598          
    599              const uint8_t information_about_error[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
    600              {
    601                " Вых.за диапазон",
    602                " Вих.за діапазон",
    603                "  Out of Limits ",
    604                "Вых.за диапазон "
    605              };
    606          
    607              enum _edition_stats edition = current_state_menu2.edition;
    608              make_ekran_about_info(((edition == ED_WARNING_EDITION_BUSY) ? false : true), ((edition == ED_WARNING_EDITION_BUSY) ? information_about_info : information_about_error));
    609            }
    610            else
    611            {
    612              const uint8_t name_string[MAX_NAMBER_LANGUAGE][MAX_ROW_FOR_VIEW_PARE_RS485][MAX_COL_LCD + 1] = 
    613              {
    614                " Контр.четности ",
    615                " Контр.парності ",
    616                "     Parity     ",
    617                " Контр.четности "
    618              };
    619              int index_language = index_language_in_array(select_struct_settings_fix()->language);
    620            
    621              unsigned int position_temp = current_state_menu2.index_position;
    622              //Множення на два величини position_temp потрібне для того, бо на одну позицію ми використовуємо два рядки (назва + значення)
    623              unsigned int index_in_ekran = ((position_temp << 1) >> POWER_MAX_ROW_LCD) << POWER_MAX_ROW_LCD;
    624            
    625              uint32_t value;
    626              if (current_state_menu2.edition == ED_VIEWING) value = settings_fix_prt.pare_bit_RS485;
    627              else if (current_state_menu2.edition == ED_CAN_BE_EDITED) value = settings_fix.pare_bit_RS485;
    628              else value = settings_fix_edit.pare_bit_RS485;
    629            
    630              for (size_t i = 0; i < MAX_ROW_LCD; i++)
    631              {
    632                unsigned int index_in_ekran_tmp = index_in_ekran >> 1;
    633                if (index_in_ekran_tmp < MAX_ROW_FOR_VIEW_PARE_RS485)
    634                {
    635                  if ((i & 0x1) == 0)
    636                  {
    637                    //У непарному номері рядку виводимо заголовок
    638                    for (size_t j = 0; j < MAX_COL_LCD; j++) working_ekran[i][j] = name_string[index_language][index_in_ekran_tmp][j];
    639                  }
    640                  else
    641                  {
    642                    if (value < MAX_NUMBER_PARE_RS485)
    643                    {
    644                      const uint8_t information[MAX_NAMBER_LANGUAGE][MAX_NUMBER_PARE_RS485][MAX_COL_LCD + 1] = 
    645                      {
    646                        {"      Нет       ", "     Нечет.     ", "      Чет.      "},
    647                        {"      Нема      ", "    Непарн.     ", "      Парн.     "},
    648                        {"      None      ", "      Odd       ", "      Even      "},
    649                        {"      Нет       ", "     Нечет.     ", "      Чет.      "}
    650                      };
    651                      const unsigned int cursor_x[MAX_NAMBER_LANGUAGE][MAX_NUMBER_PARE_RS485 + 1] = 
    652                      {
    653                        {5, 4, 5, 4},
    654                        {5, 3, 5, 3},
    655                        {5, 5, 5, 4},
    656                        {5, 4, 5, 4}
    657                      };
    658          
    659                      for (size_t j = 0; j < MAX_COL_LCD; j++) working_ekran[i][j] = information[index_language][value][j];
    660                      if (position_temp == index_in_ekran_tmp)
    661                      {
    662                        current_state_menu2.position_cursor_x = cursor_x[index_language][value];
    663                      }
    664                    }
    665                    else
    666                    {
    667                      const uint8_t information_error[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
    668                      {
    669                        "     Ошибка     ",
    670                        "    Помилка     ",
    671                        "     Error      ",
    672                        "     Ошибка     "
    673                      };
    674                      const unsigned int cursor_x_error[MAX_NAMBER_LANGUAGE] = {4, 3, 4, 4};
    675          
    676                      for (size_t j = 0; j < MAX_COL_LCD; j++) working_ekran[i][j] = information_error[index_language][j];
    677                      if (position_temp == index_in_ekran_tmp)
    678                      {
    679                        current_state_menu2.position_cursor_x = cursor_x_error[index_language];
    680                      }
    681                    }
    682                  }
    683                }
    684                else
    685                  for (size_t j = 0; j<MAX_COL_LCD; j++) working_ekran[i][j] = ' ';
    686          
    687                index_in_ekran++;
    688              }
    689          
    690              //Відображення курору по вертикалі і курсор завжди має бути у полі із значенням устаки
    691              current_state_menu2.position_cursor_y = ((position_temp << 1) + 1) & (MAX_ROW_LCD - 1);
    692              //Курсор видимий
    693              current_state_menu2.cursor_on = 1;
    694              //Курсор не мигає
    695              if(current_state_menu2.edition <= ED_CAN_BE_EDITED) current_state_menu2.cursor_blinking_on = 0;
    696              else current_state_menu2.cursor_blinking_on = 1;
    697            }
    698            //Обновити повністю весь екран
    699            current_state_menu2.current_action = ACTION_WITH_CARRENT_EKRANE_FULL_UPDATE;
    700          }
    701          /*****************************************************/
    702          
    703          /*****************************************************/
    704          /*
    705          Натискування Enter у вікні відображення парності
    706          */
    707          /*****************************************************/
    708          enum _result_pressed_enter_during_edition press_enter_in_pare_RS485(void)
    709          {
    710            enum _result_pressed_enter_during_edition result = RPEDE_NONE;
    711            switch (current_state_menu2.edition)
    712            {
    713            case ED_EDITION:
    714              {
    715                //Перевіряємо, чи дані рельно змінилися
    716                result = RPEDE_DATA_NOT_CHANGED;
    717                
    718                int32_t *p_value_edit = &settings_fix_edit.pare_bit_RS485;
    719                int32_t *p_value_cont = &settings_fix.pare_bit_RS485;
    720                if (*p_value_cont != *p_value_edit) 
    721                {
    722                  if (check_data_setpoint(*p_value_edit, VALUE_PARE_RS485_MIN, VALUE_PARE_RS485_MAX) == 1)
    723                  {
    724                    *p_value_cont = *p_value_edit;
    725                    
    726                    config_settings_modified |= MASKA_CHANGED_SETTINGS;
    727                    result = RPEDE_DATA_CHANGED_OK;
    728                  }
    729                  else result = RPEDE_DATA_CHANGED_OUT_OF_RANGE;
    730                }
    731          
    732                break;
    733              }
    734            }
    735            
    736            return result;
    737          }
    738          /*****************************************************/
    739          
    740          /*****************************************************/
    741          /*
    742          Натискування ESC у вікні налаштувань парності
    743          */
    744          /*****************************************************/
    745          void press_esc_in_pare_RS485(void)
    746          {
    747            settings_fix_edit.pare_bit_RS485 = settings_fix.pare_bit_RS485; 
    748          }
    749          /*****************************************************/
    750          
    751          /*****************************************************/
    752          //Зміна налаштувань парності
    753          /*****************************************************
    754          Вхідні параметри
    755          (1 << BIT_KEY_RIGHT)- натснуто кнопку праворуч
    756          (1 << BIT_KEY_LEFT) - атиснуто кнопку ліворуч
    757          
    758          Вхідні параметри
    759            Немає
    760          *****************************************************/
    761          void change_pare_RS485(unsigned int action)
    762          {
    763            //Вводимо число у відповідне поле
    764            if (
    765                ((action & (1 << BIT_KEY_LEFT )) != 0) ||
    766                ((action & (1 << BIT_KEY_RIGHT)) != 0)
    767               )   
    768            {
    769              int32_t value = settings_fix_edit.pare_bit_RS485;
    770              if ((action & (1 << BIT_KEY_RIGHT)) != 0) 
    771              {
    772                if ((++value) > VALUE_PARE_RS485_MAX)
    773                  value = VALUE_PARE_RS485_MIN;
    774              }
    775              else 
    776              {
    777                if ((--value) < VALUE_PARE_RS485_MIN)
    778                  value = VALUE_PARE_RS485_MAX;
    779              }
    780              settings_fix_edit.pare_bit_RS485 = value;
    781            }
    782          }
    783          /*****************************************************/
    784          
    785          /*****************************************************/
    786          //Формуємо екран відображення stop-bit для інтерфейсу
    787          /*****************************************************/
    788          void make_ekran_stopbits_RS485()
    789          {
    790            if (
    791                (current_state_menu2.edition == ED_WARNING_EDITION_BUSY) ||
    792                (current_state_menu2.edition == ED_WARNING_ENTER_ESC)
    793               )   
    794            {
    795              const uint8_t information_about_info[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
    796              {
    797                "Ред.не разрешено",
    798                "Ред.не дозволене",
    799                "Ed.isn't allowed",
    800                "Ред.не разрешено",
    801              };
    802          
    803              const uint8_t information_about_error[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
    804              {
    805                " Вых.за диапазон",
    806                " Вих.за діапазон",
    807                "  Out of Limits ",
    808                "Вых.за диапазон "
    809              };
    810          
    811              enum _edition_stats edition = current_state_menu2.edition;
    812              make_ekran_about_info(((edition == ED_WARNING_EDITION_BUSY) ? false : true), ((edition == ED_WARNING_EDITION_BUSY) ? information_about_info : information_about_error));
    813            }
    814            else
    815            {
    816              const unsigned char name_string[MAX_NAMBER_LANGUAGE][MAX_ROW_FOR_VIEW_STOP_BITS_RS485][MAX_COL_LCD + 1] = 
    817              {
    818                " Колич.стоп-бит ",
    819                "Кільк.стоп-біт  ",
    820                "   Stop Bits    ",
    821                " Колич.стоп-бит "
    822              };
    823              int index_language = index_language_in_array(select_struct_settings_fix()->language);
    824            
    825              unsigned int position_temp = current_state_menu2.index_position;
    826              //Множення на два величини position_temp потрібне для того, бо на одну позицію ми використовуємо два рядки (назва + значення)
    827              unsigned int index_in_ekran = ((position_temp << 1) >> POWER_MAX_ROW_LCD) << POWER_MAX_ROW_LCD;
    828            
    829              uint32_t value;
    830              if (current_state_menu2.edition == ED_VIEWING) value = settings_fix_prt.number_stop_bit_RS485;
    831              else if (current_state_menu2.edition == ED_CAN_BE_EDITED) value = settings_fix.number_stop_bit_RS485;
    832              else value = settings_fix_edit.number_stop_bit_RS485;
    833            
    834              for (size_t i = 0; i < MAX_ROW_LCD; i++)
    835              {
    836                unsigned int index_in_ekran_tmp = index_in_ekran >> 1;
    837                if (index_in_ekran_tmp < MAX_ROW_FOR_VIEW_STOP_BITS_RS485)
    838                {
    839                  if ((i & 0x1) == 0)
    840                  {
    841                    //У непарному номері рядку виводимо заголовок
    842                    for (size_t j = 0; j < MAX_COL_LCD; j++) working_ekran[i][j] = name_string[index_language][index_in_ekran_tmp][j];
    843                  }
    844                  else
    845                  {
    846                    if (value < MAX_NUMBER_STOP_BITS_RS485)
    847                    {
    848                      const unsigned char information[MAX_NAMBER_LANGUAGE][MAX_NUMBER_STOP_BITS_RS485][MAX_COL_LCD + 1] = 
    849                      {
    850                        {"      Один      ", "      Два       "},
    851                        {"      Один      ", "      Два       "},
    852                        {"      One       ", "      Two       "},
    853                        {"      Один      ", "      Два       "}
    854                      };
    855                      const unsigned int cursor_x[MAX_NAMBER_LANGUAGE][MAX_NUMBER_STOP_BITS_RS485] = 
    856                      {
    857                        {5, 5},
    858                        {5, 5},
    859                        {5, 5},
    860                        {5, 5}
    861                      };
    862          
    863                      for (unsigned int j = 0; j<MAX_COL_LCD; j++) working_ekran[i][j] = information[index_language][value][j];
    864                      if (position_temp == index_in_ekran_tmp)
    865                      {
    866                        current_state_menu2.position_cursor_x = cursor_x[index_language][value];
    867                      }
    868                    }
    869                    else
    870                    {
    871                      const uint8_t information_error[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
    872                      {
    873                        "     Ошибка     ",
    874                        "    Помилка     ",
    875                        "     Error      ",
    876                        "     Ошибка     "
    877                      };
    878                      const unsigned int cursor_x_error[MAX_NAMBER_LANGUAGE] = {4, 3, 4, 4};
    879          
    880                      for (size_t j = 0; j < MAX_COL_LCD; j++) working_ekran[i][j] = information_error[index_language][j];
    881                      if (position_temp == index_in_ekran_tmp)
    882                      {
    883                        current_state_menu2.position_cursor_x = cursor_x_error[index_language];
    884                      }
    885                    }
    886                  }
    887                }
    888                else
    889                  for (size_t j = 0; j < MAX_COL_LCD; j++) working_ekran[i][j] = ' ';
    890          
    891                index_in_ekran++;
    892              }
    893          
    894              //Відображення курору по вертикалі і курсор завжди має бути у полі із значенням устаки
    895              current_state_menu2.position_cursor_y = ((position_temp << 1) + 1) & (MAX_ROW_LCD - 1);
    896              //Курсор видимий
    897              current_state_menu2.cursor_on = 1;
    898              //Курсор не мигає
    899              if(current_state_menu2.edition <= ED_CAN_BE_EDITED) current_state_menu2.cursor_blinking_on = 0;
    900              else current_state_menu2.cursor_blinking_on = 1;
    901            }
    902          
    903            //Обновити повністю весь екран
    904            current_state_menu2.current_action = ACTION_WITH_CARRENT_EKRANE_FULL_UPDATE;
    905          }
    906          /*****************************************************/
    907          
    908          /*****************************************************/
    909          /*
    910          Натискування Enter у вікні відображення стоп-бітів
    911          */
    912          /*****************************************************/
    913          enum _result_pressed_enter_during_edition press_enter_in_stopbits_RS485(void)
    914          {
    915            enum _result_pressed_enter_during_edition result = RPEDE_NONE;
    916            switch (current_state_menu2.edition)
    917            {
    918            case ED_EDITION:
    919              {
    920                //Перевіряємо, чи дані рельно змінилися
    921                result = RPEDE_DATA_NOT_CHANGED;
    922                
    923                int32_t *p_value_edit = &settings_fix_edit.number_stop_bit_RS485;
    924                int32_t *p_value_cont = &settings_fix.number_stop_bit_RS485;
    925                if (*p_value_cont != *p_value_edit) 
    926                {
    927                  if (check_data_setpoint(*p_value_edit, VALUE_STOP_BITS_RS485_MIN, VALUE_STOP_BITS_RS485_MAX) == 1)
    928                  {
    929                    *p_value_cont = *p_value_edit;
    930                    
    931                    config_settings_modified |= MASKA_CHANGED_SETTINGS;
    932                    result = RPEDE_DATA_CHANGED_OK;
    933                  }
    934                  else result = RPEDE_DATA_CHANGED_OUT_OF_RANGE;
    935                }
    936          
    937                break;
    938              }
    939            }
    940            
    941            return result;
    942          }
    943          /*****************************************************/
    944          
    945          /*****************************************************/
    946          /*
    947          Натискування ESC у вікні налаштувань стоп-бітів
    948          */
    949          /*****************************************************/
    950          void press_esc_in_stopbits_RS485(void)
    951          {
    952            settings_fix_edit.number_stop_bit_RS485 = settings_fix.number_stop_bit_RS485; 
    953          }
    954          /*****************************************************/
    955          
    956          /*****************************************************/
    957          //Зміна налаштувань стоп-бітів
    958          /*****************************************************
    959          Вхідні параметри
    960          (1 << BIT_KEY_RIGHT)- натснуто кнопку праворуч
    961          (1 << BIT_KEY_LEFT) - атиснуто кнопку ліворуч
    962          
    963          Вхідні параметри
    964            Немає
    965          *****************************************************/
    966          void change_stopbits_RS485(unsigned int action)
    967          {
    968            //Вводимо число у відповідне поле
    969            if (
    970                ((action & (1 << BIT_KEY_LEFT )) != 0) ||
    971                ((action & (1 << BIT_KEY_RIGHT)) != 0)
    972               )   
    973            {
    974              int32_t value = settings_fix_edit.number_stop_bit_RS485;
    975              if ((action & (1 << BIT_KEY_RIGHT)) != 0) 
    976              {
    977                if ((++value) > VALUE_STOP_BITS_RS485_MAX)
    978                  value = VALUE_STOP_BITS_RS485_MIN;
    979              }
    980              else 
    981              {
    982                if ((--value) < VALUE_STOP_BITS_RS485_MIN)
    983                  value = VALUE_STOP_BITS_RS485_MAX;
    984              }
    985              settings_fix_edit.number_stop_bit_RS485 = value;
    986            }
    987          }
    988          /*****************************************************/
    989          
    990          /*****************************************************/
    991          //Формуємо екран відображення time-out наступного символу для інтерфейсу
    992          /*****************************************************/
    993          void make_ekran_timeout_RS485(void)
    994          {
    995            if (
    996                (current_state_menu2.edition == ED_WARNING_EDITION_BUSY) ||
    997                (current_state_menu2.edition == ED_WARNING_ENTER_ESC)
    998               )   
    999            {
   1000              const uint8_t information_about_info[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
   1001              {
   1002                "Ред.не разрешено",
   1003                "Ред.не дозволене",
   1004                "Ed.isn't allowed",
   1005                "Ред.не разрешено",
   1006              };
   1007          
   1008              const uint8_t information_about_error[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
   1009              {
   1010                " Вых.за диапазон",
   1011                " Вих.за діапазон",
   1012                "  Out of Limits ",
   1013                "Вых.за диапазон "
   1014              };
   1015          
   1016              enum _edition_stats edition = current_state_menu2.edition;
   1017              make_ekran_about_info(((edition == ED_WARNING_EDITION_BUSY) ? false : true), ((edition == ED_WARNING_EDITION_BUSY) ? information_about_info : information_about_error));
   1018            }
   1019            else
   1020            {
   1021              const uint8_t name_string[MAX_NAMBER_LANGUAGE][MAX_ROW_FOR_VIEW_TIMEOUT_RS485][MAX_COL_LCD + 1] = 
   1022              {
   1023                "  Конец приёма  ",
   1024                "Кінець приймання",
   1025                "End of Reception",
   1026                "  Конец приёма  "
   1027              };
   1028              const uint8_t symbols[MAX_NAMBER_LANGUAGE][5 + 1] = {"симв.", "симв.", "symb.", "симв."};
   1029              int index_language = index_language_in_array(select_struct_settings_fix()->language);
   1030            
   1031              unsigned int position_temp = current_state_menu2.index_position;
   1032              //Множення на два величини position_temp потрібне для того, бо на одну позицію ми використовуємо два рядки (назва + значення)
   1033              unsigned int index_in_ekran = ((position_temp << 1) >> POWER_MAX_ROW_LCD) << POWER_MAX_ROW_LCD;
   1034            
   1035              unsigned int first_symbol;
   1036              uint32_t vaga, value;
   1037              if (current_state_menu2.edition == ED_VIEWING) value = settings_fix_prt.time_out_1_RS485;
   1038              else if (current_state_menu2.edition == ED_CAN_BE_EDITED) value = settings_fix.time_out_1_RS485;
   1039              else value = settings_fix_edit.time_out_1_RS485;
   1040            
   1041              for (size_t i = 0; i < MAX_ROW_LCD; i++)
   1042              {
   1043                unsigned int index_in_ekran_tmp = index_in_ekran >> 1;
   1044                if (index_in_ekran_tmp < MAX_ROW_FOR_VIEW_TIMEOUT_RS485)
   1045                {
   1046                  if ((i & 0x1) == 0)
   1047                  {
   1048                    //У непарному номері рядку виводимо заголовок
   1049                    for (size_t j = 0; j < MAX_COL_LCD; j++) working_ekran[i][j] = name_string[index_language][index_in_ekran_tmp][j];
   1050          
   1051                    first_symbol = 0; //помічаємо, що ще ніодин значущий символ не виведений
   1052                    vaga = 100; //максимальний ваговий коефіцієнт для вилілення старшого розряду
   1053                  }
   1054                  else
   1055                  {
   1056                    //У парному номері рядку виводимо значення уставки
   1057                    for (size_t j = 0; j<MAX_COL_LCD; j++)
   1058                    {
   1059                      if (
   1060                          ((j < COL_TIMEOUT_RS485_BEGIN) ||  (j > COL_TIMEOUT_RS485_END )) &&
   1061                          (
   1062                           !((j >= (COL_TIMEOUT_RS485_END + 2)) && (j <= (COL_TIMEOUT_RS485_END + 6)))
   1063                          )    
   1064                         )working_ekran[i][j] = ' ';
   1065                      else if (j == COL_TIMEOUT_RS485_COMMA )working_ekran[i][j] = ',';
   1066                      else if ((j >= (COL_TIMEOUT_RS485_END + 2)) && (j <= (COL_TIMEOUT_RS485_END + 6)))
   1067                        working_ekran[i][j] = symbols[index_language][j - (COL_TIMEOUT_RS485_END + 2)];
   1068                      else
   1069                        calc_symbol_and_put_into_working_ekran((working_ekran[i] + j), &value, &vaga, &first_symbol, j, COL_TIMEOUT_RS485_COMMA, 0);
   1070                    }
   1071                  }
   1072                }
   1073                else
   1074                  for (size_t j = 0; j<MAX_COL_LCD; j++) working_ekran[i][j] = ' ';
   1075          
   1076                index_in_ekran++;
   1077              }
   1078          
   1079              //Відображення курору по вертикалі і курсор завжди має бути у полі із значенням устаки
   1080              current_state_menu2.position_cursor_y = ((position_temp<<1) + 1) & (MAX_ROW_LCD - 1);
   1081          
   1082              if (current_state_menu2.edition <= ED_CAN_BE_EDITED)
   1083              {
   1084                int last_position_cursor_x = COL_TIMEOUT_RS485_END;
   1085                current_state_menu2.position_cursor_x = COL_TIMEOUT_RS485_BEGIN;
   1086          
   1087                //Підтягуємо курсор до першого символу
   1088                while (
   1089                       ((working_ekran[current_state_menu2.position_cursor_y][current_state_menu2.position_cursor_x + 1]) == ' ') && 
   1090                       (current_state_menu2.position_cursor_x < (last_position_cursor_x -1))
   1091                       )
   1092                {
   1093                  current_state_menu2.position_cursor_x++;
   1094                }
   1095          
   1096                //Курсор ставимо так, щоб він був перед числом
   1097                if (
   1098                    ((working_ekran[current_state_menu2.position_cursor_y][current_state_menu2.position_cursor_x]) != ' ') && 
   1099                    (current_state_menu2.position_cursor_x > 0)
   1100                   )
   1101                {
   1102                  current_state_menu2.position_cursor_x--;
   1103                }
   1104              }
   1105              //Курсор видимий
   1106              current_state_menu2.cursor_on = 1;
   1107              //Курсор не мигає
   1108              if(current_state_menu2.edition <= ED_CAN_BE_EDITED) current_state_menu2.cursor_blinking_on = 0;
   1109              else current_state_menu2.cursor_blinking_on = 1;
   1110            }
   1111            //Обновити повністю весь екран
   1112            current_state_menu2.current_action = ACTION_WITH_CARRENT_EKRANE_FULL_UPDATE;
   1113          }
   1114          /*****************************************************/
   1115          
   1116          /*****************************************************/
   1117          /*
   1118          Натискування Enter у вікні відображення time-out наступного символу для інтерфейсу
   1119          */
   1120          /*****************************************************/
   1121          enum _result_pressed_enter_during_edition press_enter_in_timeout_RS485(void)
   1122          {
   1123            enum _result_pressed_enter_during_edition result = RPEDE_NONE;
   1124            switch (current_state_menu2.edition)
   1125            {
   1126            case ED_VIEWING:
   1127            case ED_CAN_BE_EDITED:
   1128              {
   1129                current_state_menu2.position_cursor_x = COL_TIMEOUT_RS485_BEGIN;
   1130              }
   1131            case ED_EDITION:
   1132              {
   1133                //Перевіряємо, чи дані рельно змінилися
   1134                result = RPEDE_DATA_NOT_CHANGED;
   1135                
   1136                uint32_t *p_value_edit = &settings_fix_edit.time_out_1_RS485;
   1137                uint32_t *p_value_cont = &settings_fix.time_out_1_RS485;
   1138          
   1139                if (*p_value_cont != *p_value_edit) 
   1140                {
   1141                  if (check_data_setpoint(*p_value_edit, VALUE_TIME_OUT_1_RS485_MIN, VALUE_TIME_OUT_1_RS485_MAX) == 1)
   1142                  {
   1143                    *p_value_cont = *p_value_edit;
   1144                    config_settings_modified |= MASKA_CHANGED_SETTINGS;
   1145                    result = RPEDE_DATA_CHANGED_OK;
   1146                  }
   1147                  else result = RPEDE_DATA_CHANGED_OUT_OF_RANGE;
   1148                }
   1149          
   1150                break;
   1151              }
   1152            }
   1153            
   1154            return result;
   1155          }
   1156          /*****************************************************/
   1157          
   1158          /*****************************************************/
   1159          /*
   1160          Натискування ESC у вікні відображення time-out наступного символу для інтерфейсу
   1161          */
   1162          /*****************************************************/
   1163          void press_esc_in_timeout_RS485(void)
   1164          {
   1165            settings_fix_edit.time_out_1_RS485 = settings_fix.time_out_1_RS485;
   1166          }
   1167          /*****************************************************/
   1168          
   1169          /*****************************************************/
   1170          //Зміна time-out наступного символу для інтерфейсу
   1171          /*****************************************************
   1172          Вхідні параметри
   1173          (1 << BIT_KEY_DOWN) - натснуто кнопку вниз
   1174          (1 << BIT_KEY_UP)   - атиснуто кнопку вверх
   1175          (1 << BIT_KEY_RIGHT)- натснуто кнопку праворуч
   1176          (1 << BIT_KEY_LEFT) - атиснуто кнопку ліворуч
   1177          
   1178          Вхідні параметри
   1179            Немає
   1180          *****************************************************/
   1181          void change_timeout_RS485(unsigned int action)
   1182          {
   1183            //Вводимо число у відповідне поле
   1184            if (action & ((1 << BIT_KEY_DOWN) | (1 << BIT_KEY_UP)))
   1185            {
   1186              settings_fix_edit.time_out_1_RS485 = edit_setpoint(((action & (1 << BIT_KEY_UP)) != 0), settings_fix_edit.time_out_1_RS485, 1, COL_TIMEOUT_RS485_COMMA, COL_TIMEOUT_RS485_END, 1);
   1187            }
   1188            else if (
   1189                     ((action & (1 << BIT_KEY_LEFT )) != 0) ||
   1190                     ((action & (1 << BIT_KEY_RIGHT)) != 0)
   1191                    )   
   1192            {
   1193              if (action & (1 << BIT_KEY_LEFT ))
   1194              {
   1195                current_state_menu2.position_cursor_x--;
   1196                if (current_state_menu2.position_cursor_x == COL_TIMEOUT_RS485_COMMA )current_state_menu2.position_cursor_x--;
   1197                if ((current_state_menu2.position_cursor_x < COL_TIMEOUT_RS485_BEGIN) ||
   1198                    (current_state_menu2.position_cursor_x > COL_TIMEOUT_RS485_END))
   1199                  current_state_menu2.position_cursor_x = COL_TIMEOUT_RS485_END;
   1200              }
   1201              else
   1202              {
   1203                current_state_menu2.position_cursor_x++;
   1204                if (current_state_menu2.position_cursor_x == COL_TIMEOUT_RS485_COMMA )current_state_menu2.position_cursor_x++;
   1205                if ((current_state_menu2.position_cursor_x < COL_TIMEOUT_RS485_BEGIN) ||
   1206                    (current_state_menu2.position_cursor_x > COL_TIMEOUT_RS485_END))
   1207                  current_state_menu2.position_cursor_x = COL_TIMEOUT_RS485_BEGIN;
   1208              }
   1209              
   1210            }
   1211          }
   1212          /*****************************************************/
   1213          
   1214          /*****************************************************/
   1215          //
   1216          /*****************************************************/
   1217          /*****************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   change_address
        16   -> edit_setpoint
       0   change_baud_RS485
       0   change_pare_RS485
       0   change_stopbits_RS485
      16   change_timeout_RS485
        16   -> edit_setpoint
     248   make_ekran_address
       248   -> __aeabi_memcpy4
       248   -> calc_int_symbol_and_put_into_working_ekran
       248   -> index_language_in_array
       248   -> make_ekran_about_info
       248   -> select_struct_settings_fix
     464   make_ekran_baud_RS485
       464   -> __aeabi_memcpy4
       464   -> index_language_in_array
       464   -> make_ekran_about_info
       464   -> select_struct_settings_fix
     224   make_ekran_choose_communication_parameters
       224   -> __aeabi_memcpy4
       224   -> index_language_in_array
       224   -> select_struct_settings_fix
     288   make_ekran_choose_setting_RS485
       288   -> __aeabi_memcpy4
       288   -> index_language_in_array
       288   -> select_struct_settings_fix
      16   make_ekran_name_of_cell
        16   -> index_language_in_array
        16   -> select_struct_settings_fix
     584   make_ekran_pare_RS485
       584   -> __aeabi_memcpy4
       584   -> index_language_in_array
       584   -> make_ekran_about_info
       584   -> select_struct_settings_fix
     488   make_ekran_stopbits_RS485
       488   -> __aeabi_memcpy4
       488   -> index_language_in_array
       488   -> make_ekran_about_info
       488   -> select_struct_settings_fix
     280   make_ekran_timeout_RS485
       280   -> __aeabi_memcpy4
       280   -> calc_symbol_and_put_into_working_ekran
       280   -> index_language_in_array
       280   -> make_ekran_about_info
       280   -> select_struct_settings_fix
      16   press_enter_in_address
        16   -> check_data_setpoint
      16   press_enter_in_baud_RS485
        16   -> check_data_setpoint
      16   press_enter_in_pare_RS485
        16   -> check_data_setpoint
      16   press_enter_in_stopbits_RS485
        16   -> check_data_setpoint
      16   press_enter_in_timeout_RS485
        16   -> check_data_setpoint
       0   press_esc_in_address
       0   press_esc_in_baud_RS485
       0   press_esc_in_pare_RS485
       0   press_esc_in_stopbits_RS485
       0   press_esc_in_timeout_RS485


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable18
       4  ??DataTable18_1
       4  ??DataTable18_2
       4  ??DataTable18_3
       4  ??DataTable18_4
       4  ??DataTable18_5
       4  ??DataTable18_6
       4  ??DataTable19
       4  ??DataTable21
       4  ??DataTable21_1
       4  ??DataTable22
       4  ??DataTable22_1
       4  ??DataTable22_10
       4  ??DataTable22_11
       4  ??DataTable22_12
       4  ??DataTable22_13
       4  ??DataTable22_14
       4  ??DataTable22_15
       4  ??DataTable22_16
       4  ??DataTable22_17
       4  ??DataTable22_18
       4  ??DataTable22_19
       4  ??DataTable22_2
       4  ??DataTable22_20
       4  ??DataTable22_21
       4  ??DataTable22_22
       4  ??DataTable22_23
       4  ??DataTable22_24
       4  ??DataTable22_25
       4  ??DataTable22_26
       4  ??DataTable22_27
       4  ??DataTable22_28
       4  ??DataTable22_29
       4  ??DataTable22_3
       4  ??DataTable22_30
       4  ??DataTable22_31
       4  ??DataTable22_32
       4  ??DataTable22_33
       4  ??DataTable22_34
       4  ??DataTable22_35
       4  ??DataTable22_36
       4  ??DataTable22_37
       4  ??DataTable22_4
       4  ??DataTable22_5
       4  ??DataTable22_6
       4  ??DataTable22_7
       4  ??DataTable22_8
       4  ??DataTable22_9
      28  ?_0
      16  ?_1
     272  ?_10
      68  ?_11
      68  ?_12
      68  ?_13
     120  ?_14
      68  ?_15
      68  ?_16
      68  ?_17
      68  ?_18
     204  ?_19
      64  ?_2
      68  ?_20
      68  ?_21
      68  ?_22
      68  ?_23
     136  ?_24
      68  ?_25
      68  ?_26
      68  ?_27
      68  ?_28
      24  ?_29
      16  ?_3
      32  ?_4
      16  ?_5
     204  ?_6
      68  ?_7
      68  ?_8
      68  ?_9
     156  change_address
      50  change_baud_RS485
      50  change_pare_RS485
      50  change_stopbits_RS485
     172  change_timeout_RS485
     550  make_ekran_address
     486  make_ekran_baud_RS485
     142  make_ekran_choose_communication_parameters
     144  make_ekran_choose_setting_RS485
     150  make_ekran_name_of_cell
     494  make_ekran_pare_RS485
     488  make_ekran_stopbits_RS485
     582  make_ekran_timeout_RS485
     102  press_enter_in_address
      86  press_enter_in_baud_RS485
      84  press_enter_in_pare_RS485
      84  press_enter_in_stopbits_RS485
      90  press_enter_in_timeout_RS485
      14  press_esc_in_address
      18  press_esc_in_baud_RS485
      18  press_esc_in_pare_RS485
      18  press_esc_in_stopbits_RS485
      14  press_esc_in_timeout_RS485

 
 2 356 bytes in section .rodata
 4 250 bytes in section .text
 
 4 250 bytes of CODE  memory
 2 356 bytes of CONST memory

Errors: none
Warnings: none
