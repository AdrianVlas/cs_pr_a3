###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       24/Mar/2017  12:54:58
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\menu_output_led.c
#    Command line =  
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\menu_output_led.c" -D USE_STDPERIPH_DRIVER -D STM32F2XX -D
#        USE_USB_OTG_FS -D KEYBOARD_VER_1 -D SYSTEM_VIEWER_ENABLE -lc
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List" --remarks -o
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --enable_multibytes --fpu=None
#        --dlib_config G:\PRG\IAR7_50_2\arm\INC\c\DLib_Config_Full.h -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\usb\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_OTG_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Core\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\"
#        -I "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\Config\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\OS\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\SEGGER\" -On --use_c++_inline
#        --require_prototypes -I G:\PRG\IAR7_50_2\arm\CMSIS\Include\ -D
#        ARM_MATH_CM3
#    List file    =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List\menu_output_led.lst
#    Object file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj\menu_output_led.o
#
###############################################################################

G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working files\src\menu_output_led.c
      1          #include "header.h"
      2          
      3          /*****************************************************/
      4          //Формуємо екран відображення вікна відображення налаштувань виходів/світлоіндикаторів
      5          /*****************************************************/
      6          void make_ekran_control_output_led(void)
      7          {
      8            if (
      9                (current_state_menu2.edition == ED_WARNING_EDITION_BUSY) ||
     10                (current_state_menu2.edition == ED_WARNING_ENTER_ESC)
     11               )   
     12            {
     13              const uint8_t information_about_info[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
     14              {
     15                "Ред.не разрешено",
     16                "Ред.не дозволене",
     17                "Ed.isn't allowed",
     18                "Ред.не разрешено",
     19              };
     20          
     21              const uint8_t information_about_error[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
     22              {
     23                " Вых.за диапазон",
     24                " Вих.за діапазон",
     25                "  Out of Limits ",
     26                "Вых.за диапазон "
     27              };
     28          
     29              enum _edition_stats edition = current_state_menu2.edition;
     30              make_ekran_about_info(((edition == ED_WARNING_EDITION_BUSY) ? false : true), ((edition == ED_WARNING_EDITION_BUSY) ? information_about_info : information_about_error));
     31            }
     32            else
     33            {
     34              const uint8_t name_string[MAX_NAMBER_LANGUAGE][MAX_INDEX_CTRL_OUTPUT_LED][MAX_COL_LCD + 1] = 
     35              {
     36                {
     37                  "  Норм./Триг.   ",
     38                  "   Пост./Имп.   ",
     39                  " Имп-Пр/Имп-Расш",
     40                  "   Частота 1    ",
     41                  "   Частота 2    "
     42                },
     43                {
     44                  "  Норм./Триґ.   ",
     45                  "   Пост./Імп.   ",
     46                  " Імп-Пр/Імп-Росш",
     47                  "   Частота 1    ",
     48                  "   Частота 2    "
     49                },
     50                {
     51                  "  Norm./Trig.   ",
     52                  "  Const./Imp.   ",
     53                  "  Imp-S/Imp-Ex  ",
     54                  "   Frequency 1  ",
     55                  "   Frequency 2  "
     56                },
     57                {
     58                  "   Имп./Триг.   ",
     59                  "   Норм./Имп.   ",
     60                  " Имп-Пр/Имп-Расш",
     61                  "   Частота 1    ",
     62                  "   Частота 2    "
     63                }
     64              };
     65              int index_language = index_language_in_array(select_struct_settings_fix()->language);
     66            
     67              unsigned int position_temp = current_state_menu2.index_position;
     68              //Множення на два величини position_temp потрібне для того, бо на одну позицію ми використовуємо два рядки (назва + значення)
     69              unsigned int index_in_ekran = ((position_temp << 1) >> POWER_MAX_ROW_LCD) << POWER_MAX_ROW_LCD;
     70          
     71              void *p_settings;
     72              if (current_state_menu2.edition == ED_VIEWING) 
     73              {
     74                if (current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL)
     75                {
     76                  p_settings = &((((__LN_OUTPUT*)spca_of_p_prt[ID_FB_OUTPUT - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection)->settings);
     77                }
     78                else
     79                {
     80                  p_settings = &((((__LN_LED*)spca_of_p_prt[ID_FB_LED - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection)->settings);
     81                }
     82              }
     83              else if (current_state_menu2.edition == ED_CAN_BE_EDITED) 
     84              {
     85                if (current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL)
     86                {
     87                  p_settings = (((__settings_for_OUTPUT*)sca_of_p[ID_FB_OUTPUT - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection);
     88                }
     89                else
     90                {
     91                  p_settings = (((__settings_for_LED*)sca_of_p[ID_FB_LED - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection);
     92                }
     93              }
     94              else 
     95              {
     96                if (current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL)
     97                {
     98                  p_settings = (((__settings_for_OUTPUT*)sca_of_p_edit[ID_FB_OUTPUT - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection);
     99                }
    100                else
    101                {
    102                  p_settings = (((__settings_for_LED*)sca_of_p_edit[ID_FB_LED - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection);
    103                }
    104              }
    105            
    106              for (size_t i = 0; i < MAX_ROW_LCD; i++)
    107              {
    108                unsigned int index_in_ekran_tmp = index_in_ekran >> 1;
    109              
    110                if (index_in_ekran_tmp < MAX_INDEX_CTRL_OUTPUT_LED)
    111                {
    112                  if ((i & 0x1) == 0)
    113                  {
    114                    //У непарному номері рядку виводимо заголовок
    115                    for (size_t j = 0; j < MAX_COL_LCD; j++) working_ekran[i][j] = name_string[index_language][index_in_ekran_tmp][j];
    116                  }
    117                  else
    118                  {
    119                    //У парному номері рядку виводимо значення
    120                    if (index_in_ekran_tmp == INDEX_CTRL_OUTPUT_LED_N_T)  
    121                    {
    122                      const uint8_t information[MAX_NAMBER_LANGUAGE][2][MAX_COL_LCD + 1] = 
    123                      {
    124                        {"   НОРМАЛЬНЫЙ   ", "   ТРИГГЕРНЫЙ   "},
    125                        {"   НОРМАЛЬНИЙ   ", "   ТРИҐЕРНИЙ    "},
    126                        {"     NORMAL     ", "    TRIGGER     "},
    127                        {"   НОРМАЛЬНЫЙ   ", "   ТРИГГЕРНЫЙ   "}
    128                      };
    129                      const unsigned int cursor_x[MAX_NAMBER_LANGUAGE][2] = 
    130                      {
    131                        {2, 2},
    132                        {2, 2},
    133                        {4, 3},
    134                        {2, 2}
    135                      };
    136                    
    137                      for (size_t j = 0; j < MAX_COL_LCD; j++) 
    138                      {
    139                        working_ekran[i][j] = information[index_language][(((current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL) ? ((__settings_for_OUTPUT*)p_settings)->control : ((__settings_for_LED*)p_settings)->control) >> INDEX_CTRL_OUTPUT_LED_N_T) & 0x1][j];
    140                      }
    141                      if (position_temp == index_in_ekran_tmp)
    142                      {
    143                        current_state_menu2.position_cursor_x = cursor_x[index_language][(((current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL) ? ((__settings_for_OUTPUT*)p_settings)->control : ((__settings_for_LED*)p_settings)->control) >> INDEX_CTRL_OUTPUT_LED_N_T) & 0x1];
    144                      }
    145                    }
    146                    else if (index_in_ekran_tmp == INDEX_CTRL_OUTPUT_LED_C_I)  
    147                    {
    148                      const uint8_t information[MAX_NAMBER_LANGUAGE][2][MAX_COL_LCD + 1] = 
    149                      {
    150                        {"   ПОСТОЯННЫЙ   ", "   ИМПУЛЬСНЫЙ   "},
    151                        {"   ПОСТІЙНИЙ    ", "   ІМПУЛЬСНИЙ   "},
    152                        {"    CONSTANT    ", "    IMPULSE     "},
    153                        {"   ПОСТОЯННЫЙ   ", "   ИМПУЛЬСНЫЙ   "},
    154                      };
    155                      const unsigned int cursor_x[MAX_NAMBER_LANGUAGE][2] = 
    156                      {
    157                        {2, 2},
    158                        {2, 2},
    159                        {3, 3},
    160                        {2, 2}
    161                      };
    162                    
    163                      for (size_t j = 0; j < MAX_COL_LCD; j++)
    164                      {
    165                        working_ekran[i][j] = information[index_language][(((current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL) ? ((__settings_for_OUTPUT*)p_settings)->control : ((__settings_for_LED*)p_settings)->control) >> INDEX_CTRL_OUTPUT_LED_C_I) & 0x1][j];
    166                      }
    167                      if (position_temp == index_in_ekran_tmp)
    168                      {
    169                        current_state_menu2.position_cursor_x = cursor_x[index_language][(((current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL) ? ((__settings_for_OUTPUT*)p_settings)->control : ((__settings_for_LED*)p_settings)->control) >> INDEX_CTRL_OUTPUT_LED_C_I) & 0x1];
    170                      }
    171                    }
    172                    else if (index_in_ekran_tmp == INDEX_CTRL_OUTPUT_LED_SI_EI)  
    173                    {
    174                      const uint8_t information[MAX_NAMBER_LANGUAGE][2][MAX_COL_LCD + 1] = 
    175                      {
    176                        {"  ИМП.ПРОСТОЙ   ", " ИМП.РАСШИРЕННЫЙ"},
    177                        {"  ІМП.ПРОСТИЙ   ", " ІМП.РОЗШИРЕНИЙ "},
    178                        {"   IMP.SIMPLE   ", "  IMP.EXPANDED  "},
    179                        {"  ИМП.ПРОСТОЙ   ", " ИМП.РАСШИРЕННЫЙ"},
    180                      };
    181                      const unsigned int cursor_x[MAX_NAMBER_LANGUAGE][2] = 
    182                      {
    183                        {1, 0},
    184                        {1, 0},
    185                        {2, 1},
    186                        {1, 0}
    187                      };
    188                    
    189                      for (size_t j = 0; j < MAX_COL_LCD; j++) 
    190                      {
    191                        working_ekran[i][j] = information[index_language][(((current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL) ? ((__settings_for_OUTPUT*)p_settings)->control : ((__settings_for_LED*)p_settings)->control) >> INDEX_CTRL_OUTPUT_LED_SI_EI) & 0x1][j];
    192                      }
    193                      if (position_temp == index_in_ekran_tmp)
    194                      {
    195                        current_state_menu2.position_cursor_x = cursor_x[index_language][(((current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL) ? ((__settings_for_OUTPUT*)p_settings)->control : ((__settings_for_LED*)p_settings)->control) >> INDEX_CTRL_OUTPUT_LED_SI_EI) & 0x1];
    196                      }
    197                    }
    198                    else if (
    199                             (index_in_ekran_tmp >= INDEX_CTRL_OUTPUT_LED_MEANDER1) &&
    200                             (index_in_ekran_tmp <= INDEX_CTRL_OUTPUT_LED_MEANDER2)
    201                            )   
    202                    {
    203                      unsigned int param_input;
    204                      if (index_in_ekran_tmp == INDEX_CTRL_OUTPUT_LED_MEANDER1)
    205                        param_input = (current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL) ? ((__settings_for_OUTPUT*)p_settings)->param[OUTPUT_MEANDER1] : ((__settings_for_LED*)p_settings)->param[LED_MEANDER1];
    206                      else
    207                        param_input = (current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL) ? ((__settings_for_OUTPUT*)p_settings)->param[OUTPUT_MEANDER2] : ((__settings_for_LED*)p_settings)->param[LED_MEANDER2];
    208          
    209                      if (param_input == 0)
    210                      {
    211                        const uint8_t information_error[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
    212                        {
    213                          "     Пусто      ",
    214                          "     Пусто      ",
    215                          "     Empty      ",
    216                          "     Пусто      "
    217                        };
    218                        const uint32_t cursor_x_error[MAX_NAMBER_LANGUAGE] = {4, 4, 4, 4};
    219          
    220                        for (size_t j = 0; j < MAX_COL_LCD; j++) working_ekran[i][j] = information_error[index_language][j];
    221                        if (position_temp == index_in_ekran_tmp)
    222                        {
    223                          current_state_menu2.position_cursor_x = cursor_x_error[index_language];
    224                        }
    225                      }
    226                      else
    227                      {
    228                        unsigned int id_input   = (param_input >> SFIFT_PARAM_ID ) & MASKA_PARAM_ID ;
    229                        unsigned int n_input    = (param_input >> SFIFT_PARAM_N  ) & MASKA_PARAM_N  ;
    230                        unsigned int out_input  = (param_input >> SFIFT_PARAM_OUT) & MASKA_PARAM_OUT;
    231                      
    232                        if ((id_input != ID_FB_MEANDER) || (out_input != (MEANDER_OUT + 1)))
    233                        {
    234                          const uint8_t information_error[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
    235                          {
    236                            "     Ошибка     ",
    237                            "    Помилка     ",
    238                            "     Error      ",
    239                            "     Ошибка     "
    240                          };
    241                          const uint32_t cursor_x_error[MAX_NAMBER_LANGUAGE] = {4, 3, 4, 4};
    242          
    243                          for (size_t j = 0; j < MAX_COL_LCD; j++) working_ekran[i][j] = information_error[index_language][j];
    244                          if (position_temp == index_in_ekran_tmp)
    245                          {
    246                            current_state_menu2.position_cursor_x = cursor_x_error[index_language];
    247                          }
    248                        }
    249                        else
    250                        {
    251                          const uint8_t value_name[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
    252                          {
    253                            {"ГПС             "},
    254                            {"ГПС             "},
    255                            {"MEANDER         "},
    256                            {"ГПС             "},
    257                          };
    258                          const unsigned int number_symbols_in_name[MAX_NAMBER_LANGUAGE] = {3, 3, 7, 3};
    259                          unsigned int number_symbols_in_name_tmp = number_symbols_in_name[index_language];
    260                    
    261                          unsigned int number_digit = max_number_digit_in_number(n_input);
    262                          unsigned int empty_before = (MAX_COL_LCD - number_symbols_in_name_tmp - number_digit) >> 1;
    263          
    264                          for (size_t j = 0; j < MAX_COL_LCD; j++)
    265                          {
    266                            if ((j < empty_before) || (j >= (empty_before + number_symbols_in_name_tmp + number_digit))) working_ekran[i][j] = ' ';
    267                            else if (j < (empty_before + number_symbols_in_name_tmp)) working_ekran[i][j] = value_name[index_language][j - empty_before];
    268                            else
    269                            {
    270                              /*
    271                              Заповнюємо значення зправа  на ліво
    272                              індекс = (empty_before + number_symbols_in_name_tmp) + number_digit - 1 - (j - (empty_before + number_symbols_in_name_tmp)) =
    273                              = (empty_before + number_symbols_in_name_tmp) + number_digit - 1 - j + (empty_before + number_symbols_in_name_tmp) =
    274                              = 2(empty_before + number_symbols_in_name_tmp) + number_digit - 1 - j =
    275                              */
    276                              working_ekran[i][2*(empty_before + number_symbols_in_name_tmp) + number_digit - 1 - j] = (n_input % 10) + 0x30;
    277                              n_input /= 10;
    278                            }
    279                          }
    280                          if (position_temp == index_in_ekran_tmp)
    281                          {
    282                            current_state_menu2.position_cursor_x = empty_before - 1;
    283                          }
    284                        }
    285                      }
    286                    }
    287                  }
    288                }
    289                else
    290                  for (size_t j = 0; j<MAX_COL_LCD; j++) working_ekran[i][j] = ' ';
    291          
    292                index_in_ekran++;
    293              }
    294          
    295              //Відображення курору по вертикалі і курсор завжди має бути у полі із значенням устаки
    296              current_state_menu2.position_cursor_y = ((position_temp << 1) + 1) & (MAX_ROW_LCD - 1);
    297              //Курсор видимий
    298              current_state_menu2.cursor_on = 1;
    299              //Курсор не мигає
    300              if(current_state_menu2.edition <= ED_CAN_BE_EDITED) current_state_menu2.cursor_blinking_on = 0;
    301              else current_state_menu2.cursor_blinking_on = 1;
    302              //Обновити повністю весь екран
    303            }
    304            current_state_menu2.current_action = ACTION_WITH_CARRENT_EKRANE_FULL_UPDATE;
    305          }
    306          /*****************************************************/
    307          
    308          /*****************************************************/
    309          /*
    310          Натискування Enter у вікні відображення налаштувань виходів/світлоіндикаторів
    311          */
    312          /*****************************************************/
    313          enum _result_pressed_enter_during_edition press_enter_in_control_output_led(void)
    314          {
    315            enum _result_pressed_enter_during_edition result = RPEDE_NONE;
    316            switch (current_state_menu2.edition)
    317            {
    318            case ED_EDITION:
    319              {
    320                //Перевіряємо, чи дані рельно змінилися
    321                result = RPEDE_DATA_NOT_CHANGED;
    322                
    323                void *p_settings_edit;
    324                void *p_settings_cont;
    325                if (current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL)
    326                {
    327                  p_settings_edit = (((__settings_for_OUTPUT*)sca_of_p_edit[ID_FB_OUTPUT - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection);
    328                  p_settings_cont = (((__settings_for_OUTPUT*)sca_of_p[ID_FB_OUTPUT - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection);
    329                }
    330                else
    331                {
    332                  p_settings_edit = (((__settings_for_LED*)sca_of_p_edit[ID_FB_LED - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection);
    333                  p_settings_cont = (((__settings_for_LED*)sca_of_p[ID_FB_LED - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection);
    334                }
    335          
    336                if (
    337                    (
    338                     ((current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL) ? ((__settings_for_OUTPUT*)p_settings_cont)->control : ((__settings_for_LED*)p_settings_cont)->control) != 
    339                     ((current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL) ? ((__settings_for_OUTPUT*)p_settings_edit)->control : ((__settings_for_LED*)p_settings_edit)->control)
    340                    )
    341                    ||
    342                    (
    343                     ((current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL) ? ((__settings_for_OUTPUT*)p_settings_cont)->param[OUTPUT_MEANDER1] : ((__settings_for_LED*)p_settings_cont)->param[LED_MEANDER1]) != 
    344                     ((current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL) ? ((__settings_for_OUTPUT*)p_settings_edit)->param[OUTPUT_MEANDER1] : ((__settings_for_LED*)p_settings_edit)->param[LED_MEANDER1])
    345                    ) 
    346                    ||
    347                    (
    348                     ((current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL) ? ((__settings_for_OUTPUT*)p_settings_cont)->param[OUTPUT_MEANDER2] : ((__settings_for_LED*)p_settings_cont)->param[LED_MEANDER2]) != 
    349                     ((current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL) ? ((__settings_for_OUTPUT*)p_settings_edit)->param[OUTPUT_MEANDER2] : ((__settings_for_LED*)p_settings_edit)->param[LED_MEANDER2])
    350                    ) 
    351                   )   
    352                {
    353                  if (
    354                      ((((current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL) ? ((__settings_for_OUTPUT*)p_settings_edit)->control : ((__settings_for_LED*)p_settings_edit)->control) & ((uint32_t)(~MASKA_CTRL_OUTPUT_LED_M2))) == 0) &&
    355                      (((((current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL) ? ((__settings_for_OUTPUT*)p_settings_edit)->param[OUTPUT_MEANDER1] : ((__settings_for_LED*)p_settings_edit)->param[LED_MEANDER1]) >> SFIFT_PARAM_N ) & MASKA_PARAM_N) <= current_config.n_meander) &&
    356                      (((((current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL) ? ((__settings_for_OUTPUT*)p_settings_edit)->param[OUTPUT_MEANDER2] : ((__settings_for_LED*)p_settings_edit)->param[LED_MEANDER2]) >> SFIFT_PARAM_N ) & MASKA_PARAM_N) <= current_config.n_meander)
    357                     )   
    358                  {
    359                    if (current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL)
    360                    {
    361                      ((__settings_for_OUTPUT*)p_settings_cont)->control = ((__settings_for_OUTPUT*)p_settings_edit)->control;
    362                      ((__settings_for_OUTPUT*)p_settings_cont)->param[OUTPUT_MEANDER1] = ((__settings_for_OUTPUT*)p_settings_edit)->param[OUTPUT_MEANDER1];
    363                      ((__settings_for_OUTPUT*)p_settings_cont)->param[OUTPUT_MEANDER2] = ((__settings_for_OUTPUT*)p_settings_edit)->param[OUTPUT_MEANDER2];
    364                    }
    365                    else
    366                    {
    367                      ((__settings_for_LED*)p_settings_cont)->control = ((__settings_for_LED*)p_settings_edit)->control;
    368                      ((__settings_for_LED*)p_settings_cont)->param[LED_MEANDER1] = ((__settings_for_LED*)p_settings_edit)->param[LED_MEANDER1];
    369                      ((__settings_for_LED*)p_settings_cont)->param[LED_MEANDER2] = ((__settings_for_LED*)p_settings_edit)->param[LED_MEANDER2];
    370                    }
    371          
    372                    
    373                    config_settings_modified |= MASKA_CHANGED_SETTINGS;
    374                    result = RPEDE_DATA_CHANGED_OK;
    375                  }
    376                  else result = RPEDE_DATA_CHANGED_OUT_OF_RANGE;
    377                }
    378          
    379                break;
    380              }
    381            }
    382            
    383            return result;
    384          }
    385          /*****************************************************/
    386          
    387          /*****************************************************/
    388          /*
    389          Натискування ESC у вікні налаштувань виходів/світлоіндикаторів
    390          */
    391          /*****************************************************/
    392          void press_esc_in_control_output_led(void)
    393          {
    394            if (current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL)
    395            {
    396              __settings_for_OUTPUT *p_settings_edit = (((__settings_for_OUTPUT*)sca_of_p_edit[ID_FB_OUTPUT - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection);
    397              __settings_for_OUTPUT *p_settings_cont = (((__settings_for_OUTPUT*)sca_of_p[ID_FB_OUTPUT - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection);
    398          
    399              p_settings_edit->control = p_settings_cont->control;
    400              p_settings_edit->param[OUTPUT_MEANDER1] = p_settings_cont->param[OUTPUT_MEANDER1];
    401              p_settings_edit->param[OUTPUT_MEANDER2] = p_settings_cont->param[OUTPUT_MEANDER2];
    402            }
    403            else
    404            {
    405              __settings_for_LED *p_settings_edit = (((__settings_for_LED*)sca_of_p_edit[ID_FB_LED - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection);
    406              __settings_for_LED *p_settings_cont = (((__settings_for_LED*)sca_of_p[ID_FB_LED - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection);
    407          
    408              p_settings_edit->control = p_settings_cont->control;
    409              p_settings_edit->param[LED_MEANDER1] = p_settings_cont->param[LED_MEANDER1];
    410              p_settings_edit->param[LED_MEANDER2] = p_settings_cont->param[LED_MEANDER2];
    411            }
    412          
    413          }
    414          /*****************************************************/
    415          
    416          /*****************************************************/
    417          //Зміна налаштувань бінарної інформації для виходів/світлоіндикаторів
    418          /*****************************************************
    419          Вхідні параметри
    420          (1 << BIT_KEY_RIGHT)- натснуто кнопку праворуч
    421          (1 << BIT_KEY_LEFT) - атиснуто кнопку ліворуч
    422          
    423          Вхідні параметри
    424            Немає
    425          *****************************************************/
    426          void change_control_output_led(unsigned int action)
    427          {
    428            //Вводимо число у відповідне поле
    429            void *p_settings_edit;
    430            if (current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL)
    431            {
    432              p_settings_edit = (((__settings_for_OUTPUT*)sca_of_p_edit[ID_FB_OUTPUT - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection);
    433            }
    434            else
    435            {
    436              p_settings_edit = (((__settings_for_LED*)sca_of_p_edit[ID_FB_LED - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection);
    437            }
    438          
    439            if (
    440                ((action & (1 << BIT_KEY_LEFT )) != 0) ||
    441                ((action & (1 << BIT_KEY_RIGHT)) != 0)
    442               )   
    443            {
    444              int16_t index_position = current_state_menu2.index_position;
    445              if (
    446                  (index_position == INDEX_CTRL_OUTPUT_LED_N_T) ||
    447                  (index_position == INDEX_CTRL_OUTPUT_LED_C_I) ||
    448                  (index_position == INDEX_CTRL_OUTPUT_LED_SI_EI)
    449                 )  
    450              {
    451                if (current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL)
    452                {
    453                  ((__settings_for_OUTPUT*)p_settings_edit)->control ^= (uint32_t)(1 << index_position);
    454                }
    455                else
    456                {
    457                  ((__settings_for_LED*)p_settings_edit)->control ^= (uint32_t)(1 << index_position);
    458                }
    459              }
    460              else 
    461              {
    462                int32_t n_meander = current_config.n_meander;
    463                if (n_meander > 0)
    464                {
    465                  uint32_t *param_input;
    466                  if (index_position == INDEX_CTRL_OUTPUT_LED_MEANDER1)
    467                  {
    468                    param_input = (current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL) ? &(((__settings_for_OUTPUT*)p_settings_edit)->param[OUTPUT_MEANDER1]) : &(((__settings_for_LED*)p_settings_edit)->param[LED_MEANDER1]);
    469                  }
    470                  else
    471                  {
    472                    param_input = (current_state_menu2.current_level == CTRL_OUTPUT_MENU2_LEVEL) ? &(((__settings_for_OUTPUT*)p_settings_edit)->param[OUTPUT_MEANDER2]) : &(((__settings_for_LED*)p_settings_edit)->param[LED_MEANDER2]);
    473                  }
    474                
    475                  int n_input = ((*param_input) >> SFIFT_PARAM_N  ) & MASKA_PARAM_N  ;
    476                  if ((action & (1 << BIT_KEY_RIGHT)) != 0) n_input++;
    477                  else n_input--;
    478                
    479                  if  (n_input < 1) n_input = n_meander;
    480                  else if (n_input > n_meander) n_input = 1;
    481                  *param_input = ((ID_FB_MEANDER & MASKA_PARAM_ID) << SFIFT_PARAM_ID) | ((n_input & MASKA_PARAM_N) << SFIFT_PARAM_N) | (((MEANDER_OUT + 1) & MASKA_PARAM_OUT) << SFIFT_PARAM_OUT);
    482                }
    483              }
    484            }
    485          }
    486          /*****************************************************/
    487          
    488          /*****************************************************/
    489          //
    490          /*****************************************************/
    491          /*****************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      12   change_control_output_led
     688   make_ekran_control_output_led
       688   -> __aeabi_memcpy4
       688   -> index_language_in_array
       688   -> make_ekran_about_info
       688   -> max_number_digit_in_number
       688   -> select_struct_settings_fix
       8   press_enter_in_control_output_led
       0   press_esc_in_control_output_led


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_13
       4  ??DataTable3_14
       4  ??DataTable3_15
       4  ??DataTable3_16
       4  ??DataTable3_17
       4  ??DataTable3_18
       4  ??DataTable3_19
       4  ??DataTable3_2
       4  ??DataTable3_20
       4  ??DataTable3_21
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
      32  ?_0
      32  ?_1
     136  ?_10
     136  ?_11
      68  ?_12
      68  ?_13
      68  ?_14
      32  ?_2
      16  ?_3
      16  ?_4
      16  ?_5
      68  ?_6
      68  ?_7
     340  ?_8
     136  ?_9
     212  change_control_output_led
    1294  make_ekran_control_output_led
     326  press_enter_in_control_output_led
      92  press_esc_in_control_output_led

 
 1 232 bytes in section .rodata
 2 012 bytes in section .text
 
 2 012 bytes of CODE  memory
 1 232 bytes of CONST memory

Errors: none
Warnings: none
