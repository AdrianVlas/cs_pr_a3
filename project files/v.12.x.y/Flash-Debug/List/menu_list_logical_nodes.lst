###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       24/Mar/2017  12:54:57
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\menu_list_logical_nodes.c
#    Command line =  
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\menu_list_logical_nodes.c" -D USE_STDPERIPH_DRIVER -D
#        STM32F2XX -D USE_USB_OTG_FS -D KEYBOARD_VER_1 -D SYSTEM_VIEWER_ENABLE
#        -lc "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List" --remarks -o
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --enable_multibytes --fpu=None
#        --dlib_config G:\PRG\IAR7_50_2\arm\INC\c\DLib_Config_Full.h -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\usb\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_OTG_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Core\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\"
#        -I "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\Config\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\OS\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\SEGGER\" -On --use_c++_inline
#        --require_prototypes -I G:\PRG\IAR7_50_2\arm\CMSIS\Include\ -D
#        ARM_MATH_CM3
#    List file    =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List\menu_list_logical_nodes.lst
#    Object file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj\menu_list_logical_nodes.o
#
###############################################################################

G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working files\src\menu_list_logical_nodes.c
      1          #include "header.h"
      2          
      3          /*****************************************************/
      4          //Формуємо екран відображення списку функціональних блоків певного типу
      5          /*****************************************************/
      6          void make_ekran_list_logical_nodes(void)
      7          {
      8            const uint8_t name_input[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
      9            {
     10              " Д.Вх.          ",
     11              " Д.Вх.          ",
     12              " DI             ",
     13              " Д.Вх.          "
     14            };
     15            const unsigned int first_index_number_input[MAX_NAMBER_LANGUAGE] = {6, 6, 3, 6};
     16            
     17            const uint8_t name_output[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
     18            {
     19              " В.Реле          ",
     20              " В.Реле          ",
     21              " DO              ",
     22              " В.Реле          "
     23            };
     24            const unsigned int first_index_number_output[MAX_NAMBER_LANGUAGE] = {7, 7, 3, 7};
     25            
     26            const uint8_t name_led[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
     27            {
     28              " Св.             ",
     29              " Св.             ",
     30              " LED             ",
     31              " Св.             "
     32            };
     33            const unsigned int first_index_number_led[MAX_NAMBER_LANGUAGE] = {4, 4, 4, 4};
     34          
     35            const uint8_t name_alarm[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
     36            {
     37              " СЗС            ",
     38              " СЗС            ",
     39              " Alarm          ",
     40              " СЗС            "
     41            };
     42            const unsigned int first_index_number_alarm[MAX_NAMBER_LANGUAGE] = {4, 4, 6, 4};
     43          
     44            const uint8_t name_group_alarm[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
     45            {
     46              " ШГС            ",
     47              " ШГС            ",
     48              " Gr.Alarm       ",
     49              " ШГС            "
     50            };
     51            const unsigned int first_index_number_group_alarm[MAX_NAMBER_LANGUAGE] = {4, 4, 9, 4};
     52          
     53            const uint8_t name_and[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
     54            {
     55              " И              ",
     56              " І              ",
     57              " AND            ",
     58              " И              "
     59            };
     60            const unsigned int first_index_number_and[MAX_NAMBER_LANGUAGE] = {2, 2, 4, 2};
     61          
     62            const uint8_t name_or[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
     63            {
     64              " ИЛИ            ",
     65              " АБО            ",
     66              " OR             ",
     67              " ИЛИ            "
     68            };
     69            const unsigned int first_index_number_or[MAX_NAMBER_LANGUAGE] = {4, 4, 3, 4};
     70          
     71            const uint8_t name_xor[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
     72            {
     73              " Искл.ИЛИ       ",
     74              " Викл.АБО       ",
     75              " XOR            ",
     76              " Искл.ИЛИ       "
     77            };
     78            const unsigned int first_index_number_xor[MAX_NAMBER_LANGUAGE] = {9, 9, 4, 9};
     79          
     80            const uint8_t name_not[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
     81            {
     82                " НЕ             ",
     83                " НЕ             ",
     84                " NOT            ",
     85                " НЕ             ",
     86            };
     87            const unsigned int first_index_number_not[MAX_NAMBER_LANGUAGE] = {3, 3, 4, 3};
     88          
     89            const uint8_t name_timer[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
     90            {
     91              " БФ-Таймер      ",
     92              " БФ-Таймер      ",
     93              " MF-Timer       ",
     94              " БФ-Таймер      "
     95            };
     96            const unsigned int first_index_number_timer[MAX_NAMBER_LANGUAGE] = {10, 10, 9, 10};
     97          
     98            const uint8_t name_trigger[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
     99            {
    100             " D-Триггер      ",
    101             " D-Триґер       ",
    102             " D-Trigger      ",
    103             " D-Триггер      "
    104            };
    105            const unsigned int first_index_number_trigger[MAX_NAMBER_LANGUAGE] = {10, 9, 10, 10};
    106          
    107            const uint8_t name_meander[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
    108            {
    109              " ГПС            ",
    110              " ГПС            ",
    111              " PSG            ",
    112              " ГПС            "
    113            };
    114            const unsigned int first_index_number_meander[MAX_NAMBER_LANGUAGE] = {4, 4, 4, 4};
    115          
    116            
    117            int index_language = index_language_in_array(select_struct_settings_fix()->language);
    118            
    119            const uint8_t *p_name;
    120            const unsigned int *p_first_index_number;
    121            if (current_state_menu2.current_level == PARAM_LIST_SELECTED_LOGICAL_NODES_MENU2_LEVEL)
    122            {
    123              const uint8_t (* const array_p_name[NUMBER_VAR_BLOCKS])[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
    124              {
    125                &name_input,
    126                &name_output,
    127                &name_led,
    128                &name_alarm,
    129                &name_group_alarm,
    130                &name_and,
    131                &name_or,
    132                &name_xor,
    133                &name_not,
    134                &name_timer,
    135                &name_trigger,
    136                &name_meander
    137              };
    138              const unsigned int (* const array_p_first_index_number[NUMBER_VAR_BLOCKS])[MAX_NAMBER_LANGUAGE] = 
    139              {
    140                &first_index_number_input,
    141                &first_index_number_output,
    142                &first_index_number_led,
    143                &first_index_number_alarm,
    144                &first_index_number_group_alarm,
    145                &first_index_number_and,
    146                &first_index_number_or,
    147                &first_index_number_xor,
    148                &first_index_number_not,
    149                &first_index_number_timer,
    150                &first_index_number_trigger,
    151                &first_index_number_meander
    152              };
    153              
    154              intptr_t index = position_in_current_level_menu2[previous_level_in_current_level_menu2[current_state_menu2.current_level]] - NUMBER_FIX_BLOCKS; 
    155              p_name = (*array_p_name[index])[index_language];
    156              p_first_index_number = &(*array_p_first_index_number[index])[index_language];
    157            }
    158            else
    159            {
    160              switch (current_state_menu2.current_level)
    161              {
    162              case LIST_INPUTS_MENU2_LEVEL:
    163                {
    164                  p_name = name_input[index_language];
    165                  p_first_index_number = &first_index_number_input[index_language];
    166                  break;
    167                }
    168              case LIST_OUTPUTS_MENU2_LEVEL:
    169                {
    170                  p_name = name_output[index_language];
    171                  p_first_index_number = &first_index_number_output[index_language];
    172                  break;
    173                }
    174              case LIST_LEDS_MENU2_LEVEL:
    175                {
    176                  p_name = name_led[index_language];
    177                  p_first_index_number = &first_index_number_led[index_language];
    178                  break;
    179                }
    180              case LIST_ALARMS_MENU2_LEVEL:
    181                {
    182                  p_name = name_alarm[index_language];
    183                  p_first_index_number = &first_index_number_alarm[index_language];
    184                  break;
    185                }
    186              case LIST_GROUP_ALARMS_MENU2_LEVEL:
    187                {
    188                  p_name = name_group_alarm[index_language];
    189                  p_first_index_number = &first_index_number_group_alarm[index_language];
    190                  break;
    191                }
    192              case LIST_TIMERS_MENU2_LEVEL:
    193                {
    194                  p_name = name_timer[index_language];
    195                  p_first_index_number = &first_index_number_timer[index_language];
    196                  break;
    197                }
    198              case LIST_MEANDERS_MENU2_LEVEL:
    199                {
    200                  p_name = name_meander[index_language];
    201                  p_first_index_number = &first_index_number_meander[index_language];
    202                  break;
    203                }
    204              default:
    205                {
    206                  //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
    207                  total_error_sw_fixed(85);
    208                }
    209              }
    210            }
    211          
    212            unsigned int position_temp = current_state_menu2.index_position;
    213            unsigned int index_in_ekran = (position_temp >> POWER_MAX_ROW_LCD) << POWER_MAX_ROW_LCD;
    214            unsigned int max_row = (current_state_menu2.p_max_row == NULL) ? current_state_menu2.max_row : *current_state_menu2.p_max_row;
    215          
    216            //Формуємо рядки  рядки у робочий екран
    217            for (size_t i = 0; i < MAX_ROW_LCD; i++)
    218            {
    219              //Наступні рядки треба перевірити, чи їх требе відображати у текучій конфігурації
    220              if (index_in_ekran < max_row)
    221              {
    222                unsigned int number = index_in_ekran + 1;
    223                unsigned int number_digit = max_number_digit_in_number(number);
    224          
    225                for (size_t j = 0; j < MAX_COL_LCD; j++)
    226                {
    227                  if ((j < *p_first_index_number) || (j >= (*p_first_index_number + number_digit)))
    228                  {
    229                    working_ekran[i][j] = p_name[j];
    230                  }
    231                  else
    232                  {
    233                    /*
    234                    Заповнюємо значення зправа  на ліво
    235                    індекс = *p_first_index_number + number_digit - 1 - (j - *p_first_index_number) =
    236                    = *p_first_index_number + number_digit - 1 - j + *p_first_index_number =
    237                    = 2x(*p_first_index_number) + number_digit - 1 - j =
    238                    */
    239                    working_ekran[i][2*(*p_first_index_number) + number_digit - 1 - j] = (number % 10) + 0x30;
    240                    number /= 10;
    241                  }
    242                }
    243              }
    244              else
    245              {
    246                for (size_t j = 0; j < MAX_COL_LCD; j++) working_ekran[i][j] = ' ';
    247              }
    248          
    249              index_in_ekran++;
    250            }
    251          
    252            //Курсор по горизонталі відображається на першій позиції
    253            current_state_menu2.position_cursor_x = 0;
    254            //Відображення курору по вертикалі
    255            current_state_menu2.position_cursor_y = position_temp & (MAX_ROW_LCD - 1);
    256            //Курсор видимий
    257            current_state_menu2.cursor_on = 1;
    258            //Курсор не мигає
    259            current_state_menu2.cursor_blinking_on = 0;
    260            //Обновити повністю весь екран
    261            current_state_menu2.current_action = ACTION_WITH_CARRENT_EKRANE_FULL_UPDATE;
    262          }
    263          /*****************************************************/
    264          
    265          /*****************************************************/
    266          //
    267          /*****************************************************/
    268          /*****************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
    1144   make_ekran_list_logical_nodes
      1144   -> __aeabi_memcpy4
      1144   -> index_language_in_array
      1144   -> max_number_digit_in_number
      1144   -> select_struct_settings_fix
      1144   -> total_error_sw_fixed


   Section sizes:

   Bytes  Function/Label
   -----  --------------
      16  ?_0
      16  ?_1
      16  ?_10
      16  ?_11
      68  ?_12
      68  ?_13
      68  ?_14
      68  ?_15
      68  ?_16
      68  ?_17
      68  ?_18
      68  ?_19
      16  ?_2
      68  ?_20
      68  ?_21
      68  ?_22
      68  ?_23
      16  ?_3
      16  ?_4
      16  ?_5
      16  ?_6
      16  ?_7
      16  ?_8
      16  ?_9
     920  make_ekran_list_logical_nodes

 
 1 008 bytes in section .rodata
   920 bytes in section .text
 
   920 bytes of CODE  memory
 1 008 bytes of CONST memory

Errors: none
Warnings: none
