###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       24/Mar/2017  12:54:59
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\modbus.c
#    Command line =  
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\modbus.c" -D USE_STDPERIPH_DRIVER -D STM32F2XX -D
#        USE_USB_OTG_FS -D KEYBOARD_VER_1 -D SYSTEM_VIEWER_ENABLE -lc
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List" --remarks -o
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --enable_multibytes --fpu=None
#        --dlib_config G:\PRG\IAR7_50_2\arm\INC\c\DLib_Config_Full.h -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\usb\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_OTG_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Core\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\"
#        -I "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\Config\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\OS\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\SEGGER\" -On --use_c++_inline
#        --require_prototypes -I G:\PRG\IAR7_50_2\arm\CMSIS\Include\ -D
#        ARM_MATH_CM3
#    List file    =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List\modbus.lst
#    Object file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj\modbus.o
#
###############################################################################

G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working files\src\modbus.c
      1          #include "header.h"
      2          
      3          /***********************************************************************************/
      4          //Додавання числа до CRC суми
      5          /***********************************************************************************/
      6          inline unsigned short int  AddCRC(unsigned char inpbyte, unsigned short int oldCRC)
      7          {
      8            unsigned short int v,temp;
      9            int i;
     10            unsigned char bt,m;
     11          
     12            bt = inpbyte;
     13            v  = oldCRC;
     14          
     15            for (i=0; i<8;i++)
     16              {
     17                temp = v;
     18                v = v >> 1;
     19                m = bt >> i;
     20                if (((temp ^m) & 1)== 1) v = v ^ 0xa001;
     21              }
     22            return v;
     23          }
     24          /***********************************************************************************/
     25          
     26          /***********************************************************************************/
     27          //Функція відповіді по протоколу Modbus-RTU на помилку
     28          /***********************************************************************************/
     29          inline void Error_modbus(unsigned int address, unsigned int function, unsigned int error, unsigned char *output_data)
     30            {
     31             unsigned short CRC_sum;
     32          
     33             *output_data       = address & 0xff;
     34             *(output_data + 1) = 0x80 | (function & 0xff);
     35             *(output_data + 2) = error & 0xff;
     36          
     37             CRC_sum = 0xffff;
     38             for (int index = 0; index < 3; index++) CRC_sum = AddCRC((*(output_data + index)) ,CRC_sum);
     39             *(output_data + 3)  = CRC_sum & 0xff;
     40             *(output_data + 4)  = CRC_sum >> 8;
     41             
     42            }
     43          /***********************************************************************************/
     44          
     45          /***********************************************************************************/
     46          /*
     47          Переформатування ранжування виходів
     48          який передається системою захистів у формат для "унверсальної карти пам'яті"
     49          */
     50          /***********************************************************************************/
     51          /***********************************************************************************/
     52          
     53          /***********************************************************************************/
     54          //Виконання попередньо введене ранжування
     55          /***********************************************************************************/
     56          void set_previous_ranguvannja(void)
     57          {
     58          //  //Спочатку скидаємо можливі функції, які нам треба було скинути, а потім виставляємо ті, які треба виставити
     59          //  for (unsigned int i = 0; i < number_32bit_in_target; i++)
     60          //  {
     61          //    *(point_to_edited_rang + i) &= ~clear_array_rang[i];
     62          //    *(point_to_edited_rang + i) |=    set_array_rang[i];
     63          //  }
     64          //  
     65          //  //Повертаємо допоміжні змінні у висхідний стан
     66          //  for (unsigned int i = 0; i < N_BIG; i++)
     67          //  {
     68          //    clear_array_rang[i] = 0;
     69          //    set_array_rang[i]   = 0;
     70          //  }
     71            
     72            point_to_edited_rang = NULL;
     73          }
     74          /***********************************************************************************/
     75          
     76          /***********************************************************************************/
     77          
     78          /***********************************************************************************/
     79          //Читання даних
     80          /***********************************************************************************/
     81          inline unsigned int Get_data(unsigned char *data, unsigned int address_data, unsigned int type_interface)
     82          {
     83            unsigned int error = 0, temp_value = 0;
     84            
     85            if(address_data <= M_ADDRESS_LAST_RO_BLOCK_1)
     86            {
     87              //Ідентифікація пристою
     88              switch (address_data)
     89              {
     90              case MA_SERIAL_NUMBER:
     91                {
     92                  temp_value = serial_number_dev;
     93                  break;
     94                }
     95              case MA_NAME_CHAR_1_2:
     96                {
     97                  temp_value = ('i' << 8) + 'K';
     98                  break;
     99                }
    100              case MA_NAME_CHAR_3_4:
    101                {
    102                  temp_value = ('v' << 8) + 'e';
    103                  break;
    104                }
    105              case MA_NAME_CHAR_5_6:
    106                {
    107                  temp_value = ('r' << 8) + 'p';
    108                  break;
    109                }
    110              case MA_NAME_CHAR_7_8:
    111                {
    112                  temp_value = ('b' << 8) + 'i';
    113                  break;
    114                }
    115              case MA_NAME_CHAR_9_10:
    116                {
    117                  temp_value = ('r' << 8) + 'o';
    118                  break;
    119                }
    120              case MA_NAME_CHAR_11_12:
    121                {
    122                  temp_value = ('R' << 8) + 'M';
    123                  break;
    124                }
    125              case MA_NAME_CHAR_13_14:
    126                {
    127                  temp_value = ('S' << 8) + 'Z';
    128                  break;
    129                }
    130              case MA_NAME_CHAR_15_16:
    131                {
    132                  temp_value = ('5' << 8) + '0';
    133                  break;
    134                }
    135              case MA_NAME_CHAR_17_18:
    136                {
    137                  temp_value = ('_' << 8) + 'L';
    138                  break;
    139                }
    140              case MA_VERSION_SW:
    141                {
    142                  temp_value = (VERSIA_PZ << 8) + MODYFIKACIA_VERSII_PZ;
    143                  break;
    144                }
    145              case MA_DATA_COMP_1:
    146                {
    147                  temp_value = (YEAR_VER << 8) + MONTH_VER;
    148                  break;
    149                }
    150              case MA_DATA_COMP_2:
    151                {
    152                  temp_value = (DAY_VER << 8);
    153                  break;
    154                }
    155              case MA_TIME_COMP:
    156                {
    157                  temp_value = (HOUR_VER << 8) + MINUTE_VER;
    158                  break;
    159                }
    160              case MA_VERSION_GMM:
    161                {
    162                  temp_value = (VERSIA_GMM << 8) + MODYFIKACIA_VERSII_GMM;
    163                  break;
    164                }
    165              case MA_ZBIRKA_SW:
    166                {
    167                  temp_value = ZBIRKA_VERSII_PZ;
    168                  break;
    169                }
    170              default:
    171                {
    172                  //На поля які у даній конфігурації немає відповідаємо нулями
    173                  temp_value = 0;
    174                  break;
    175                }
    176              }
    177            }
    178            else if ((address_data >= M_ADDRESS_FIRST_USER_REGISTER_DATA) && (address_data <= M_ADDRESS_LAST_USER_REGISTER_DATA))
    179            {
    180              unsigned int address_data_tmp = settings_fix_prt.user_register[address_data - M_ADDRESS_FIRST_USER_REGISTER_DATA];
    181          
    182              //Щоб не відбулося зациклювання регістрів користувача на регістри користувача робимо цю перевірку
    183              if ( !((address_data_tmp >= M_ADDRESS_FIRST_USER_REGISTER_DATA) && (address_data_tmp <= M_ADDRESS_LAST_USER_REGISTER_DATA)) )
    184              {
    185                unsigned char local_temp_value[2];
    186                unsigned local_error = Get_data(local_temp_value, address_data_tmp, type_interface);
    187          
    188                if (local_error == 0) temp_value = local_temp_value[1] | (local_temp_value[0] << 8);
    189                else error = local_error;
    190              }
    191              else error = ERROR_SLAVE_DEVICE_FAILURE;
    192            }
    193            else if (address_data == MA_OUTPUTS)
    194            {
    195            }
    196            else if (address_data == MA_INPUTS)
    197            {
    198              temp_value = state_inputs & ((1 << NUMBER_INPUTS) - 1);
    199            }
    200            else if (address_data == MA_LEDS)
    201            {
    202            }
    203          //  else if (
    204          //           (address_data >= M_ADDRESS_FIRST_CURRENT_AF ) && (address_data <= M_ADDRESS_LAST_CURRENT_AF) ||
    205          //           (address_data >= M_ADDRESS_FIRST_GENERAL_AF ) && (address_data <= M_ADDRESS_LAST_GENERAL_AF)
    206          //          )
    207          //  {
    208          //#define SIZE_OUTPUT_ARRAY       (M_ADDRESS_LAST_GENERAL_AF - M_ADDRESS_FIRST_GENERAL_AF + 1)
    209          //    
    210          //    //Блок текучих активних функцій або загальних функцій
    211          //    unsigned int input_array[N_BIG], base_address;
    212          //    unsigned short int output_array[SIZE_OUTPUT_ARRAY];
    213          //    
    214          //    //Спочатку очищаємо весь вихідний масив
    215          //    for (unsigned int i = 0; i< SIZE_OUTPUT_ARRAY; i++ ) output_array[i] = 0;
    216          //#undef SIZE_OUTPUT_ARRAY
    217          //
    218          //    //Копіюємо вхідну інформацію
    219          //    if ((address_data >= M_ADDRESS_FIRST_CURRENT_AF ) && (address_data <= M_ADDRESS_LAST_CURRENT_AF))
    220          //    {
    221          //      for (unsigned int i = 0; i < N_BIG; i++) input_array[i] = active_functions[i];
    222          //      
    223          //      unsigned int password_set_tmp;
    224          //      if (type_interface == USB_RECUEST) password_set_tmp = password_set_USB;
    225          //      else if (type_interface == RS485_RECUEST) password_set_tmp = password_set_RS485;
    226          //        
    227          //      if (password_set_tmp != 0) 
    228          //      {
    229          //        output_array[(BIT_MA_PASSWORD_SET - BIT_MA_CURRENT_AF_BASE) >> 4] |= 
    230          //          (0x1 << ((BIT_MA_PASSWORD_SET - BIT_MA_CURRENT_AF_BASE) & 0xf));
    231          //      }
    232          //        
    233          //      base_address = M_ADDRESS_FIRST_CURRENT_AF;
    234          //    }
    235          //    else
    236          //    {
    237          //      if (type_interface == USB_RECUEST)
    238          //      {
    239          ////        for (unsigned int i = 0; i < N_BIG; i++) input_array[i] = trigger_functions_USB[i];
    240          //      }
    241          //      else if (type_interface == RS485_RECUEST)
    242          //      {
    243          ////        for (unsigned int i = 0; i < N_BIG; i++) input_array[i] = trigger_functions_RS485[i];
    244          //      }
    245          //      else
    246          //      {
    247          //          //Теоретично цього ніколи не мало б бути
    248          //          total_error_sw_fixed(48);
    249          //      }
    250          //      base_address = M_ADDRESS_FIRST_GENERAL_AF;
    251          //    }
    252          //    
    253          //    //Конвертуємо отриманий результат в порядок "універсальної карти пам'яті"
    254          ////    convert_order_list_function_to_gmm(input_array, output_array);
    255          //    /*****************************************************/
    256          //    
    257          //    temp_value  = output_array[address_data - base_address];
    258          //  }
    259          //  else if ((address_data >= M_ADDRESS_FIRST_MEASUREMENTS_1) && (address_data <= M_ADDRESS_LAST_MEASUREMENTS_1))
    260          //  {
    261          //    //Митєві вимірювання розраховані фетодом перетворення Фур'є
    262          //    switch (address_data)
    263          //    {
    264          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_MEASUREMENT_UA_1):
    265          //      {
    266          //        temp_value = measurement_low[IM_UA1] >> 3;
    267          //
    268          //        break;
    269          //      }
    270          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_MEASUREMENT_UB_1):
    271          //      {
    272          //        temp_value = measurement_low[IM_UB1] >> 3;
    273          //
    274          //        break;
    275          //      }
    276          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_MEASUREMENT_UC_1):
    277          //      {
    278          //        temp_value = measurement_low[IM_UC1] >> 3;
    279          //
    280          //        break;
    281          //      }
    282          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_MEASUREMENT_UAB_1):
    283          //      {
    284          //        temp_value = measurement_low[IM_UAB1] >> 3;
    285          //        break;
    286          //      }
    287          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_MEASUREMENT_UBC_1):
    288          //      {
    289          //        temp_value = measurement_low[IM_UBC1] >> 3;
    290          //        break;
    291          //      }
    292          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_MEASUREMENT_UCA_1):
    293          //      {
    294          //        temp_value = measurement_low[IM_UCA1] >> 3;
    295          //        break;
    296          //      }
    297          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_MEASUREMENT_UA_2):
    298          //      {
    299          //        temp_value = measurement_low[IM_UA1] >> 3;
    300          //
    301          //        break;
    302          //      }
    303          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_MEASUREMENT_UB_2):
    304          //      {
    305          //        temp_value = measurement_low[IM_UB1] >> 3;
    306          //
    307          //        break;
    308          //      }
    309          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_MEASUREMENT_UC_2):
    310          //      {
    311          //        temp_value = measurement_low[IM_UC1] >> 3;
    312          //
    313          //        break;
    314          //      }
    315          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_MEASUREMENT_UAB_2):
    316          //      {
    317          //        temp_value = measurement_low[IM_UAB2] >> 3;
    318          //        break;
    319          //      }
    320          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_MEASUREMENT_UBC_2):
    321          //      {
    322          //        temp_value = measurement_low[IM_UBC2] >> 3;
    323          //        break;
    324          //      }
    325          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_MEASUREMENT_UCA_2):
    326          //      {
    327          //        temp_value = measurement_low[IM_UCA2] >> 3;
    328          //        break;
    329          //      }
    330          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_MEASUREMENT_IA_1):
    331          //      {
    332          //        temp_value = measurement_low[IM_IA] >> 2;
    333          //        break;
    334          //      }
    335          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_MEASUREMENT_IB_1):
    336          //      {
    337          //        temp_value = measurement_low[IM_IB] >> 2;
    338          //        break;
    339          //      }
    340          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_MEASUREMENT_IC_1):
    341          //      {
    342          //        temp_value = measurement_low[IM_IC] >> 2;
    343          //        break;
    344          //      }
    345          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_MEASUREMENT_I1):
    346          //      {
    347          //        temp_value = measurement_low[IM_I1] >> 2;
    348          //        break;
    349          //      }
    350          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_MEASUREMENT_I2):
    351          //      {
    352          //        temp_value = measurement_low[IM_I2] >> 2;
    353          //        break;
    354          //      }
    355          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_ACTIVE_POWER):
    356          //      {
    357          //        temp_value = P/50;
    358          //        break;
    359          //      }
    360          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_REACTIVE_POWER):
    361          //      {
    362          //        temp_value = Q/50;
    363          //        break;
    364          //      }
    365          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_FULL_POWER):
    366          //      {
    367          //        temp_value = S/50;
    368          //        break;
    369          //      }
    370          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_COS_PHI):
    371          //      {
    372          //        if (S != 0)
    373          //          temp_value = cos_phi_x1000;
    374          //        else
    375          //          temp_value = 0x0;
    376          //          
    377          //        break;
    378          //      }
    379          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_FREQUENCY_1):
    380          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_FREQUENCY_2):
    381          //      {
    382          //        int int_frequency;
    383          //        if (address_data == (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_FREQUENCY_1))int_frequency = (int)(frequency_val_1*100);
    384          //        else int_frequency = (int)(frequency_val_2*100);
    385          //        
    386          //        if (int_frequency > 0 /*це число означає - частота не визначена*/)
    387          //          temp_value = int_frequency;
    388          //        else
    389          //        {
    390          //          if (int_frequency == (-1*100))
    391          //            temp_value = (unsigned int)(-1);
    392          //          else if (int_frequency == (-2*100))
    393          //            temp_value = (unsigned int)(-2);
    394          //          else if (int_frequency == (-3*100))
    395          //            temp_value = (unsigned int)(-3);
    396          //          else
    397          //            temp_value = (unsigned int)(-4);
    398          //        }
    399          //        break;
    400          //      }
    401          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_BASE_CANAL_FOR_ANGLE):
    402          //      {
    403          //        switch (base_index_for_angle)
    404          //        {
    405          //        case (-1):
    406          //          {
    407          //            temp_value = BASE_CANAL_NONE;
    408          //            break;
    409          //          }
    410          //        case FULL_ORT_Ua1:
    411          //          {
    412          //            temp_value = BASE_CANAL_UA_TN1;
    413          //            break;
    414          //          }
    415          //        case FULL_ORT_Ub1:
    416          //          {
    417          //            temp_value = BASE_CANAL_UB_TN1;
    418          //            break;
    419          //          }
    420          //        case FULL_ORT_Uc1:
    421          //          {
    422          //            temp_value = BASE_CANAL_UC_TN1;
    423          //            break;
    424          //          }
    425          //        case FULL_ORT_Ua2:
    426          //          {
    427          //            temp_value = BASE_CANAL_UA_TN2;
    428          //            break;
    429          //          }
    430          //        case FULL_ORT_Ub2:
    431          //          {
    432          //            temp_value = BASE_CANAL_UB_TN2;
    433          //            break;
    434          //          }
    435          //        case FULL_ORT_Uc2:
    436          //          {
    437          //            temp_value = BASE_CANAL_UC_TN2;
    438          //            break;
    439          //          }
    440          //        case FULL_ORT_Uab1:
    441          //          {
    442          //            temp_value = BASE_CANAL_UAB_TN1;
    443          //            break;
    444          //          }
    445          //        case FULL_ORT_Ubc1:
    446          //          {
    447          //            temp_value = BASE_CANAL_UBC_TN1;
    448          //            break;
    449          //          }
    450          //        case FULL_ORT_Uca1:
    451          //          {
    452          //            temp_value = BASE_CANAL_UCA_TN1;
    453          //            break;
    454          //          }
    455          //        case FULL_ORT_Uab2:
    456          //          {
    457          //            temp_value = BASE_CANAL_UAB_TN2;
    458          //            break;
    459          //          }
    460          //        case FULL_ORT_Ubc2:
    461          //          {
    462          //            temp_value = BASE_CANAL_UBC_TN2;
    463          //            break;
    464          //          }
    465          //        case FULL_ORT_Uca2:
    466          //          {
    467          //            temp_value = BASE_CANAL_UCA_TN2;
    468          //            break;
    469          //          }
    470          //        default:
    471          //          {
    472          //            //Теоретично цього ніколи не мало б бути
    473          //            total_error_sw_fixed(72);
    474          //          }
    475          //        }
    476          //
    477          //        break;
    478          //      }
    479          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_ANGLE_UA_1):
    480          //      {
    481          //        temp_value = (unsigned int)phi_angle[FULL_ORT_Ua1];
    482          //        break;
    483          //      }
    484          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_ANGLE_UB_1):
    485          //      {
    486          //        temp_value = (unsigned int)phi_angle[FULL_ORT_Ub1];
    487          //        break;
    488          //      }
    489          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_ANGLE_UC_1):
    490          //      {
    491          //        temp_value = (unsigned int)phi_angle[FULL_ORT_Uc1];
    492          //        break;
    493          //      }
    494          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_ANGLE_UAB_1):
    495          //      {
    496          //        temp_value = (unsigned int)phi_angle[FULL_ORT_Uab1];
    497          //        break;
    498          //      }
    499          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_ANGLE_UBC_1):
    500          //      {
    501          //        temp_value = (unsigned int)phi_angle[FULL_ORT_Ubc1];
    502          //        break;
    503          //      }
    504          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_ANGLE_UCA_1):
    505          //      {
    506          //        temp_value = (unsigned int)phi_angle[FULL_ORT_Uca1];
    507          //        break;
    508          //      }
    509          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_ANGLE_UA_2):
    510          //      {
    511          //        temp_value = (unsigned int)phi_angle[FULL_ORT_Ua2];
    512          //        break;
    513          //      }
    514          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_ANGLE_UB_2):
    515          //      {
    516          //        temp_value = (unsigned int)phi_angle[FULL_ORT_Ub2];
    517          //        break;
    518          //      }
    519          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_ANGLE_UC_2):
    520          //      {
    521          //        temp_value = (unsigned int)phi_angle[FULL_ORT_Uc2];
    522          //        break;
    523          //      }
    524          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_ANGLE_UAB_2):
    525          //      {
    526          //        temp_value = (unsigned int)phi_angle[FULL_ORT_Uab2];
    527          //        break;
    528          //      }
    529          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_ANGLE_UBC_2):
    530          //      {
    531          //        temp_value = (unsigned int)phi_angle[FULL_ORT_Ubc2];
    532          //        break;
    533          //      }
    534          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_ANGLE_UCA_2):
    535          //      {
    536          //        temp_value = (unsigned int)phi_angle[FULL_ORT_Uca2];
    537          //        break;
    538          //      }
    539          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_ANGLE_IA_1):
    540          //      {
    541          //        temp_value = (unsigned int)phi_angle[FULL_ORT_Ia];
    542          //        break;
    543          //      }
    544          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_ANGLE_IB_1):
    545          //      {
    546          //        temp_value = (unsigned int)phi_angle[FULL_ORT_Ib];
    547          //        break;
    548          //      }
    549          //    case (M_ADDRESS_FIRST_MEASUREMENTS_1 + OFFSET_ANGLE_IC_1):
    550          //      {
    551          //        temp_value = (unsigned int)phi_angle[FULL_ORT_Ic];
    552          //        break;
    553          //      }
    554          //    default:
    555          //      {
    556          //        temp_value = 0;
    557          //        break;
    558          //      }
    559          //    }
    560          //  }
    561          //  else if ((address_data >= M_ADDRESS_FIRST_MEASUREMENTS_DR) && (address_data <= M_ADDRESS_LAST_MEASUREMENTS_DR))
    562          //  {
    563          //    //Вимірювання, які зафіксовані під час роботи дискретного реєстратора
    564          //    if ((type_interface != USB_RECUEST) && (type_interface != RS485_RECUEST))
    565          //    {
    566          //      //Теоретично такого бути не мало б ніколи
    567          //      error = ERROR_SLAVE_DEVICE_FAILURE;
    568          //    }
    569          //    else if (
    570          //             ((type_interface == USB_RECUEST  ) && (number_record_of_dr_for_USB   == 0xffff)) ||
    571          //             ((type_interface == RS485_RECUEST) && (number_record_of_dr_for_RS485 == 0xffff))
    572          //            )
    573          //    {
    574          //      //Не подано попередньокоманди вичитування відповідного запису дискретного реєстратора
    575          //      error = ERROR_ILLEGAL_DATA_ADDRESS;
    576          //    }
    577          //    else if (
    578          //             ((clean_rejestrators & CLEAN_DR) != 0) ||
    579          //             (
    580          //              ((type_interface == USB_RECUEST  ) && ((control_tasks_dataflash & TASK_MAMORY_READ_DATAFLASH_FOR_DR_USB  ) != 0)) ||
    581          //              ((type_interface == RS485_RECUEST) && ((control_tasks_dataflash & TASK_MAMORY_READ_DATAFLASH_FOR_DR_RS485) != 0))
    582          //             ) 
    583          //            )
    584          //    {
    585          //      //Зараз іде зчитування для інтерфейсу запису дискретного реєстратора, або очистка його, тому ця операція є тимчасово недоступною
    586          //      error = ERROR_SLAVE_DEVICE_BUSY;
    587          //    }
    588          //    else
    589          //    {
    590          //      //Можна читати дані
    591          //      int number_block, offset;
    592          //      unsigned char *point_to_buffer;
    593          //      number_block = (address_data - M_ADDRESS_FIRST_MEASUREMENTS_DR) / MEASUREMENTS_DR_WIDTH;
    594          //      offset = (address_data - M_ADDRESS_FIRST_MEASUREMENTS_DR) - number_block*MEASUREMENTS_DR_WIDTH;
    595          //      if (type_interface == USB_RECUEST) point_to_buffer = buffer_for_USB_read_record_dr;
    596          //      else point_to_buffer = buffer_for_RS485_read_record_dr;
    597          //      
    598          //      if (
    599          //          number_block < (
    600          //                          (*(point_to_buffer + FIRST_INDEX_NUMBER_MAX_PHASE_DR  )) + 
    601          //                          (*(point_to_buffer + FIRST_INDEX_NUMBER_MIN_U_DR      )) + 
    602          //                          (*(point_to_buffer + FIRST_INDEX_NUMBER_MAX_U_DR      )) + 
    603          //                          (*(point_to_buffer + FIRST_INDEX_NUMBER_MAX_ZOP_DR    ))
    604          //                         )
    605          //         )
    606          //      {  
    607          //        unsigned int value, index;
    608          //        
    609          //        switch (offset)
    610          //        {
    611          //        case DR_OFFSET_MEASUREMENT_IA_1:
    612          //          {
    613          //            index = FIRST_INDEX_FIRST_BLOCK_DR + (number_block*SIZE_ARRAY_FIX_MAX_MEASUREMENTS + 0)*sizeof(unsigned int);
    614          //            value = *((unsigned int *)(point_to_buffer + index));
    615          //            
    616          //            temp_value = value >> 2;
    617          //            break;
    618          //          }
    619          //        case DR_OFFSET_MEASUREMENT_IB_1:
    620          //          {
    621          //            index = FIRST_INDEX_FIRST_BLOCK_DR + (number_block*SIZE_ARRAY_FIX_MAX_MEASUREMENTS + 1)*sizeof(unsigned int);
    622          //            value = *((unsigned int *)(point_to_buffer + index));
    623          //            
    624          //            temp_value = value >> 2;
    625          //            break;
    626          //          }
    627          //        case DR_OFFSET_MEASUREMENT_IC_1:
    628          //          {
    629          //            index = FIRST_INDEX_FIRST_BLOCK_DR + (number_block*SIZE_ARRAY_FIX_MAX_MEASUREMENTS + 2)*sizeof(unsigned int);
    630          //            value = *((unsigned int *)(point_to_buffer + index));
    631          //            
    632          //            temp_value = value >> 2;
    633          //            break;
    634          //          }
    635          //        case DR_OFFSET_MEASUREMENT_I1:
    636          //          {
    637          //            index = FIRST_INDEX_FIRST_BLOCK_DR + (number_block*SIZE_ARRAY_FIX_MAX_MEASUREMENTS + 4)*sizeof(unsigned int);
    638          //            value = *((unsigned int *)(point_to_buffer + index));
    639          //            
    640          //            temp_value = value >> 2;
    641          //            break;
    642          //          }
    643          //        case DR_OFFSET_MEASUREMENT_I2:
    644          //          {
    645          //            index = FIRST_INDEX_FIRST_BLOCK_DR + (number_block*SIZE_ARRAY_FIX_MAX_MEASUREMENTS + 3)*sizeof(unsigned int);
    646          //            value = *((unsigned int *)(point_to_buffer + index));
    647          //            
    648          //            temp_value = value >> 2;
    649          //            break;
    650          //          }
    651          //        case DR_OFFSET_MEASUREMENT_UAB_1:
    652          //          {
    653          //            index = FIRST_INDEX_FIRST_BLOCK_DR + (number_block*SIZE_ARRAY_FIX_MAX_MEASUREMENTS + 11)*sizeof(unsigned int);
    654          //            value = *((unsigned int *)(point_to_buffer + index));
    655          //            
    656          //            temp_value = value >> 3;
    657          //            break;
    658          //          }
    659          //        case DR_OFFSET_MEASUREMENT_UBC_1:
    660          //          {
    661          //            index = FIRST_INDEX_FIRST_BLOCK_DR + (number_block*SIZE_ARRAY_FIX_MAX_MEASUREMENTS + 12)*sizeof(unsigned int);
    662          //            value = *((unsigned int *)(point_to_buffer + index));
    663          //            
    664          //            temp_value = value >> 3;
    665          //            break;
    666          //          }
    667          //        case DR_OFFSET_MEASUREMENT_UCA_1:
    668          //          {
    669          //            index = FIRST_INDEX_FIRST_BLOCK_DR + (number_block*SIZE_ARRAY_FIX_MAX_MEASUREMENTS + 13)*sizeof(unsigned int);
    670          //            value = *((unsigned int *)(point_to_buffer + index));
    671          //            
    672          //            temp_value = value >> 3;
    673          //            break;
    674          //          }
    675          //        case DR_OFFSET_MEASUREMENT_UA_1:
    676          //          {
    677          //            index = FIRST_INDEX_FIRST_BLOCK_DR + (number_block*SIZE_ARRAY_FIX_MAX_MEASUREMENTS + 5)*sizeof(unsigned int);
    678          //            value = *((unsigned int *)(point_to_buffer + index));
    679          //            
    680          //            temp_value = value >> 3;
    681          //            break;
    682          //          }
    683          //        case DR_OFFSET_MEASUREMENT_UB_1:
    684          //          {
    685          //            index = FIRST_INDEX_FIRST_BLOCK_DR + (number_block*SIZE_ARRAY_FIX_MAX_MEASUREMENTS + 6)*sizeof(unsigned int);
    686          //            value = *((unsigned int *)(point_to_buffer + index));
    687          //            
    688          //            temp_value = value >> 3;
    689          //            break;
    690          //          }
    691          //        case DR_OFFSET_MEASUREMENT_UC_1:
    692          //          {
    693          //            index = FIRST_INDEX_FIRST_BLOCK_DR + (number_block*SIZE_ARRAY_FIX_MAX_MEASUREMENTS + 7)*sizeof(unsigned int);
    694          //            value = *((unsigned int *)(point_to_buffer + index));
    695          //            
    696          //            temp_value = value >> 3;
    697          //            break;
    698          //          }
    699          //        case DR_OFFSET_MEASUREMENT_UAB_2:
    700          //          {
    701          //            index = FIRST_INDEX_FIRST_BLOCK_DR + (number_block*SIZE_ARRAY_FIX_MAX_MEASUREMENTS + 14)*sizeof(unsigned int);
    702          //            value = *((unsigned int *)(point_to_buffer + index));
    703          //            
    704          //            temp_value = value >> 3;
    705          //            break;
    706          //          }
    707          //        case DR_OFFSET_MEASUREMENT_UBC_2:
    708          //          {
    709          //            index = FIRST_INDEX_FIRST_BLOCK_DR + (number_block*SIZE_ARRAY_FIX_MAX_MEASUREMENTS + 15)*sizeof(unsigned int);
    710          //            value = *((unsigned int *)(point_to_buffer + index));
    711          //            
    712          //            temp_value = value >> 3;
    713          //            break;
    714          //          }
    715          //        case DR_OFFSET_MEASUREMENT_UCA_2:
    716          //          {
    717          //            index = FIRST_INDEX_FIRST_BLOCK_DR + (number_block*SIZE_ARRAY_FIX_MAX_MEASUREMENTS + 16)*sizeof(unsigned int);
    718          //            value = *((unsigned int *)(point_to_buffer + index));
    719          //            
    720          //            temp_value = value >> 3;
    721          //            break;
    722          //          }
    723          //        case DR_OFFSET_MEASUREMENT_UA_2:
    724          //          {
    725          //            index = FIRST_INDEX_FIRST_BLOCK_DR + (number_block*SIZE_ARRAY_FIX_MAX_MEASUREMENTS + 8)*sizeof(unsigned int);
    726          //            value = *((unsigned int *)(point_to_buffer + index));
    727          //            
    728          //            temp_value = value >> 3;
    729          //            break;
    730          //          }
    731          //        case DR_OFFSET_MEASUREMENT_UB_2:
    732          //          {
    733          //            index = FIRST_INDEX_FIRST_BLOCK_DR + (number_block*SIZE_ARRAY_FIX_MAX_MEASUREMENTS + 9)*sizeof(unsigned int);
    734          //            value = *((unsigned int *)(point_to_buffer + index));
    735          //            
    736          //            temp_value = value >> 3;
    737          //            break;
    738          //          }
    739          //        case DR_OFFSET_MEASUREMENT_UC_2:
    740          //          {
    741          //            index = FIRST_INDEX_FIRST_BLOCK_DR + (number_block*SIZE_ARRAY_FIX_MAX_MEASUREMENTS + 10)*sizeof(unsigned int);
    742          //            value = *((unsigned int *)(point_to_buffer + index));
    743          //            
    744          //            temp_value = value >> 3;
    745          //            break;
    746          //          }
    747          //        case DR_OFFSET_FREQUENCY_1:
    748          //          {
    749          //            index = FIRST_INDEX_FIRST_BLOCK_DR + (number_block*SIZE_ARRAY_FIX_MAX_MEASUREMENTS + 17)*sizeof(unsigned int);
    750          //            value = *((unsigned int *)(point_to_buffer + index));
    751          //            
    752          //            temp_value = value / 10;
    753          //            break;
    754          //          }
    755          //        case DR_OFFSET_FREQUENCY_2:
    756          //          {
    757          //            index = FIRST_INDEX_FIRST_BLOCK_DR + (number_block*SIZE_ARRAY_FIX_MAX_MEASUREMENTS + 18)*sizeof(unsigned int);
    758          //            value = *((unsigned int *)(point_to_buffer + index));
    759          //            
    760          //            temp_value = value / 10;
    761          //            break;
    762          //          }
    763          //        case DR_OFFSET_LABEL_TIME_LSW:
    764          //        case DR_OFFSET_LABEL_TIME_MSW:
    765          //        case DR_OFFSET_LABEL_PROTECT:
    766          //          {
    767          //            index = FIRST_INDEX_FIRST_BLOCK_DR + (number_block*SIZE_ARRAY_FIX_MAX_MEASUREMENTS + 19)*sizeof(unsigned int);
    768          //            
    769          //            if (offset == DR_OFFSET_LABEL_TIME_LSW)
    770          //            {
    771          //              temp_value = (*(point_to_buffer + index + 0)) | ((*(point_to_buffer + index + 1)) << 8 );
    772          //            }
    773          //            else if (offset ==DR_OFFSET_LABEL_TIME_MSW)
    774          //            {
    775          //              temp_value =  *(point_to_buffer + index + 2);
    776          //            }
    777          //            else
    778          //            {
    779          //              value = *(point_to_buffer + index + 3);
    780          //              switch (value)
    781          //              {
    782          //              case IDENTIFIER_BIT_ARRAY_MAX_CURRENT_PHASE:
    783          //                {
    784          //                  temp_value = BLOCK_PROTECTION_MTZ;
    785          //                  break;
    786          //                }
    787          //              case IDENTIFIER_BIT_ARRAY_MIN_VOLTAGE:
    788          //                {
    789          //                  temp_value = BLOCK_PROTECTION_UMIN;
    790          //                  break;
    791          //                }
    792          //              case IDENTIFIER_BIT_ARRAY_MAX_VOLTAGE:
    793          //                {
    794          //                  temp_value = BLOCK_PROTECTION_UMAX;
    795          //                  break;
    796          //                }
    797          //              case IDENTIFIER_BIT_ARRAY_MAX_CURRENT_ZOP:
    798          //                {
    799          //                  temp_value = BLOCK_PROTECTION_ZOP;
    800          //                  break;
    801          //                }
    802          //              default:
    803          //                {
    804          //                  //Якщо немає помилок, то сюди б програма не мала заходити
    805          //                  temp_value = 0;
    806          //                  break;
    807          //                }
    808          //                  
    809          //              }
    810          //            }
    811          //            
    812          //            break;
    813          //          }
    814          //        default:
    815          //          {
    816          //            temp_value = 0;
    817          //            break;
    818          //          }
    819          //        }
    820          //      }
    821          //      else
    822          //      {
    823          //        if ((offset == DR_OFFSET_LABEL_TIME_LSW) || (offset == DR_OFFSET_LABEL_TIME_MSW)) temp_value = 0xffff;
    824          //        else temp_value = 0;
    825          //      }
    826          //    }
    827          //  }
    828            else if ((address_data >= M_ADDRESS_FIRST_USER_REGISTER) && (address_data <= M_ADDRESS_LAST_USER_REGISTER))
    829            {
    830              temp_value = settings_fix_prt.user_register[address_data - M_ADDRESS_FIRST_USER_REGISTER];
    831            }
    832            else if ((address_data >= M_ADDRESS_CONTROL_BASE) && (address_data <= M_ADDRESS_CONTROL_LAST))
    833            {
    834              switch (address_data)
    835              {
    836              case M_ADDRESS_CONTROL_EL:
    837                {
    838                  temp_value = 1 << (BIT_MA_CONFIGURATION_EL - BIT_MA_CONTROL_EL_BASE);
    839                  break;
    840                }
    841              default:
    842                {
    843                  temp_value = 0;
    844                  break;
    845                }
    846              }
    847            }
    848            else if ((address_data >= M_ADDRESS_FIRST_SETPOINTS_PART1) && (address_data <= M_ADDRESS_LAST_SETPOINTS_PART1))
    849            {
    850              switch (address_data)
    851              {
    852              default:
    853                {
    854                  temp_value = 0;
    855                  break;
    856                }
    857              }
    858            }
    859            else if (
    860                     ((address_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G1)) && (address_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G1)))/* ||
    861                     ((address_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G2)) && (address_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G2))) ||
    862                     ((address_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G3)) && (address_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G3))) ||
    863                     ((address_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G4)) && (address_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G4)))*/
    864                    )
    865            {
    866              //Уставки, витримки, які мають декілька груп уставок
    867               unsigned int /*num_gr, */address_data_tmp = address_data;
    868               if ((address_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G1)) && (address_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G1)))
    869               {
    870          //       num_gr = 0;
    871                 address_data_tmp -= SHIFT_G1;
    872               }
    873          //     else if ((address_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G2)) && (address_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G2)))
    874          //     {
    875          //       num_gr = 1;
    876          //       address_data_tmp -= SHIFT_G2;
    877          //     }
    878          //     else if ((address_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G3)) && (address_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G3)))
    879          //     {
    880          //       num_gr = 2;
    881          //       address_data_tmp -= SHIFT_G3;
    882          //     }
    883          //     else
    884          //     {
    885          //       num_gr = 3;
    886          //       address_data_tmp -= SHIFT_G4;
    887          //     }
    888                  
    889              switch (address_data_tmp)
    890              {
    891              default:
    892                {
    893                  temp_value = 0;
    894                  break;
    895                }
    896              }
    897            }
    898            else if ((address_data >= M_ADDRESS_FIRST_SETPOINTS_CONTINUE) && (address_data <= M_ADDRESS_LAST_SETPOINTS_CONTINUE))
    899            {
    900              //Уставки і витримки (ролдовження), настройки
    901              switch (address_data)
    902              {
    903              case MA_UVV_TYPE_SIGNAL_INPUT:
    904                {
    905          //        temp_value = current_settings_interfaces.type_of_input_signal & ((1 << NUMBER_INPUTS) - 1);
    906                  break;
    907                }
    908              case MA_TYPE_DF:
    909                {
    910          //        temp_value = current_settings_interfaces.type_df & ((1 << NUMBER_DEFINED_FUNCTIONS) - 1);
    911                  break;
    912                }
    913              case MA_DOPUSK_DV_1:
    914              case MA_DOPUSK_DV_2:
    915              case MA_DOPUSK_DV_3:
    916              case MA_DOPUSK_DV_4:
    917              case MA_DOPUSK_DV_5:
    918              case MA_DOPUSK_DV_6:
    919              case MA_DOPUSK_DV_7:
    920              case MA_DOPUSK_DV_8:
    921              case MA_DOPUSK_DV_9:
    922              case MA_DOPUSK_DV_10:
    923                {
    924          //        temp_value = current_settings_interfaces.dopusk_dv[address_data - MA_DOPUSK_DV_1];
    925                  break;
    926                }
    927              case MA_DF_PAUSE_1:
    928              case MA_DF_PAUSE_2:
    929              case MA_DF_PAUSE_3:
    930              case MA_DF_PAUSE_4:
    931              case MA_DF_PAUSE_5:
    932              case MA_DF_PAUSE_6:
    933              case MA_DF_PAUSE_7:
    934              case MA_DF_PAUSE_8:
    935                {
    936          //        temp_value = current_settings_interfaces.timeout_pause_df[address_data - MA_DF_PAUSE_1]/10;
    937                  break;
    938                }
    939              case MA_DF_WORK_1:
    940              case MA_DF_WORK_2:
    941              case MA_DF_WORK_3:
    942              case MA_DF_WORK_4:
    943              case MA_DF_WORK_5:
    944              case MA_DF_WORK_6:
    945              case MA_DF_WORK_7:
    946              case MA_DF_WORK_8:
    947                {
    948          //        temp_value = current_settings_interfaces.timeout_work_df[address_data - MA_DF_WORK_1]/10;
    949                  break;
    950                }
    951              case MA_TO_DEACTIVATION_PASSWORD_INTERFACE:
    952                {
    953                    if (type_interface == USB_RECUEST)
    954                    {
    955                      temp_value = settings_fix_prt.timeout_deactivation_password_interface_USB;
    956                    }
    957                    else if (type_interface == RS485_RECUEST)
    958                    {
    959                      temp_value = settings_fix_prt.timeout_deactivation_password_interface_RS485;
    960                    }
    961                    else error = ERROR_SLAVE_DEVICE_FAILURE;
    962                
    963                    break;
    964                }
    965              case MA_TO_IDLE_NEW_SETTINGS:
    966                {
    967                    temp_value = settings_fix_prt.timeout_idle_new_settings;
    968                
    969                    break;
    970                }
    971              case MA_LANGUAGE_MENU:
    972                {
    973                  temp_value = settings_fix_prt.language;
    974                  break;
    975                }
    976              case MA_SPEED_RS485_1:
    977                {
    978                  temp_value = settings_fix_prt.baud_RS485;
    979                  break;
    980                }
    981              case MA_STOP_BITS_RS485_1:
    982                {
    983                  temp_value = settings_fix_prt.number_stop_bit_RS485 + 1;
    984                  break;
    985                }
    986              case MA_PARE_RS485_1:
    987                {
    988                  temp_value = settings_fix_prt.pare_bit_RS485;
    989                  break;
    990                }
    991              case MA_TIMEOUT_RS485_1:
    992                {
    993                  temp_value = settings_fix_prt.time_out_1_RS485;
    994                  break;
    995                }
    996              case MA_LOGICAL_ADDRESS:
    997                {
    998                  temp_value = settings_fix_prt.address;
    999                  break;
   1000                }
   1001              case MA_NAME_OF_CELL_CHARS_01_02:
   1002              case MA_NAME_OF_CELL_CHARS_03_04:
   1003              case MA_NAME_OF_CELL_CHARS_05_06:
   1004              case MA_NAME_OF_CELL_CHARS_07_08:
   1005              case MA_NAME_OF_CELL_CHARS_09_10:
   1006              case MA_NAME_OF_CELL_CHARS_11_12:
   1007              case MA_NAME_OF_CELL_CHARS_13_14:
   1008              case MA_NAME_OF_CELL_CHARS_15_16:
   1009                {
   1010                  unsigned int two_char_index = (address_data - MA_NAME_OF_CELL_CHARS_01_02) << 1;
   1011                  temp_value = settings_fix_prt.name_of_cell[two_char_index] | (settings_fix_prt.name_of_cell[two_char_index + 1] << 8);
   1012                  break;
   1013                }
   1014              default:
   1015                {
   1016                  temp_value = 0;
   1017                  break;
   1018                }
   1019              }
   1020            }
   1021            else if ((address_data >= M_ADDRESS_FIRST_TIME_AND_DATA) && (address_data <= M_ADDRESS_LAST_TIME_AND_DATA))
   1022            {
   1023              unsigned char *label_to_time_array;
   1024              
   1025              if (copying_time == 0) label_to_time_array = time;
   1026              else label_to_time_array = time_copy;
   1027              
   1028              switch (address_data)
   1029              {
   1030              case MA_YEAR:
   1031                {
   1032                  temp_value = *(label_to_time_array + 6);
   1033                  break;
   1034                }
   1035              case MA_MONTH:
   1036                {
   1037                  temp_value = *(label_to_time_array + 5);
   1038                  break;
   1039                }
   1040              case MA_DAY:
   1041                {
   1042                  temp_value = *(label_to_time_array + 4);
   1043                  break;
   1044                }
   1045              case MA_HOUR:
   1046                {
   1047                  temp_value = *(label_to_time_array + 3);
   1048                  break;
   1049                }
   1050              case MA_MINUTE:
   1051                {
   1052                  temp_value = *(label_to_time_array + 2);
   1053                  break;
   1054                }
   1055              case MA_SECOND:
   1056                {
   1057                  temp_value = *(label_to_time_array + 1);
   1058                  break;
   1059                }
   1060              case MA_MILISECOND:
   1061                {
   1062                  temp_value = *(label_to_time_array + 0);
   1063                  break;
   1064                }
   1065              default:
   1066                {
   1067                  temp_value = 0;
   1068                  break;
   1069                }
   1070              }
   1071            }
   1072            else if (address_data == MA_TOTAL_NUMBER_RECORDS_PR_ERR)
   1073            {
   1074              temp_value = info_rejestrator_pr_err.number_records;
   1075            }
   1076            else if (address_data == MA_CURRENT_NUMBER_RECORD_PR_ERR)
   1077            {
   1078              if (type_interface == USB_RECUEST) temp_value = number_record_of_pr_err_into_USB;
   1079              else if (type_interface == RS485_RECUEST) temp_value = number_record_of_pr_err_into_RS485;
   1080              else
   1081              {
   1082                //Теоретично такого бути не мало б ніколи
   1083                error = ERROR_SLAVE_DEVICE_FAILURE;
   1084              }
   1085            }
   1086            else if ((address_data >= MA_FIRST_ADR_PR_ERR_WINDOW) && (address_data <= MA_LASR_ADR_PR_ERR_WINDOW))
   1087            {
   1088              if ((type_interface != USB_RECUEST) && (type_interface != RS485_RECUEST))
   1089              {
   1090                //Теоретично такого бути не мало б ніколи
   1091                error = ERROR_SLAVE_DEVICE_FAILURE;
   1092              }
   1093              else if (
   1094                       ((type_interface == USB_RECUEST  ) && (number_record_of_pr_err_into_USB   == 0xffff)) ||
   1095                       ((type_interface == RS485_RECUEST) && (number_record_of_pr_err_into_RS485 == 0xffff))
   1096                      )
   1097              {
   1098                //Не подано попередньокоманди вичитування відповідного запису реєстратора програмних подій
   1099                error = ERROR_ILLEGAL_DATA_ADDRESS;
   1100              }
   1101              else if (
   1102                       ((clean_rejestrators & CLEAN_PR_ERR) != 0) ||
   1103                       (
   1104                        ((type_interface == USB_RECUEST  ) && ((control_tasks_dataflash & TASK_MAMORY_READ_DATAFLASH_FOR_PR_ERR_USB  ) != 0)) ||
   1105                        ((type_interface == RS485_RECUEST) && ((control_tasks_dataflash & TASK_MAMORY_READ_DATAFLASH_FOR_PR_ERR_RS485) != 0))
   1106                       ) 
   1107                      )
   1108              {
   1109                //Зараз іде зчитування для інтерфейсу запису реєстратора програмних подій, або очистка його, тому ця операція є тимчасово недоступною
   1110                error = ERROR_SLAVE_DEVICE_BUSY;
   1111              }
   1112              else if (
   1113                       (
   1114                        (type_interface == USB_RECUEST)
   1115                        && 
   1116                        (
   1117                         (number_record_of_pr_err_into_USB >= info_rejestrator_pr_err.number_records) ||
   1118                         (number_record_of_pr_err_into_USB >= MAX_NUMBER_RECORDS_INTO_PR_ERR        ) /*Хоч теоретично ця умова має перекриватися завжди першою умовою*/ 
   1119                        )   
   1120                       )
   1121                       ||   
   1122                       (
   1123                        (type_interface == RS485_RECUEST)
   1124                        && 
   1125                        (
   1126                         (number_record_of_pr_err_into_RS485 >= info_rejestrator_pr_err.number_records) ||
   1127                         (number_record_of_pr_err_into_RS485 >= MAX_NUMBER_RECORDS_INTO_PR_ERR        ) /*Хоч теоретично ця умова має перекриватися завжди першою умовою*/ 
   1128                        )   
   1129                       )
   1130                      )    
   1131              {
   1132                //Зафіксовано невизначену помилку
   1133                error = ERROR_SLAVE_DEVICE_FAILURE;
   1134                
   1135               //Помічаємо, що номер запису не вибраний
   1136                if (type_interface == USB_RECUEST) number_record_of_pr_err_into_USB = 0xffff;
   1137                else if (type_interface == RS485_RECUEST) number_record_of_pr_err_into_RS485 = 0xffff;
   1138              }
   1139              else
   1140              {
   1141                unsigned char *point_to_buffer;
   1142                if (type_interface == USB_RECUEST) point_to_buffer = buffer_for_USB_read_record_pr_err;
   1143                else point_to_buffer = buffer_for_RS485_read_record_pr_err;
   1144          
   1145                if ( (*(point_to_buffer + 0)) != LABEL_START_RECORD_PR_ERR)
   1146                {
   1147                  //зафіксовано недостовірні дані
   1148                  error = ERROR_SLAVE_DEVICE_FAILURE;
   1149                }
   1150                else
   1151                {
   1152                  unsigned int temp_address = address_data - MA_FIRST_ADR_PR_ERR_WINDOW;
   1153                  switch (temp_address)
   1154                  {
   1155                  case 0:
   1156                    {
   1157                      temp_value = ((*(point_to_buffer + 7))  << 8) | (*(point_to_buffer + 6));
   1158                      break;
   1159                    }
   1160                  case 1:
   1161                    {
   1162                      temp_value =  (*(point_to_buffer + 5))  << 8;
   1163                      break;
   1164                    }
   1165                  case 2:
   1166                    {
   1167                      temp_value = ((*(point_to_buffer + 4))  << 8) | (*(point_to_buffer + 3));
   1168                      break;
   1169                    }
   1170                  case 3:
   1171                    {
   1172                      temp_value = ((*(point_to_buffer + 2))  << 8) | (*(point_to_buffer + 1));
   1173                      break;
   1174                    }
   1175                  case 4:
   1176                    {
   1177                      temp_value = ((*(point_to_buffer + 10))  << 8) | (*(point_to_buffer + 9));
   1178                      break;
   1179                    }
   1180                  case 5:
   1181                    {
   1182                      temp_value = ((*(point_to_buffer + 12))  << 8) | (*(point_to_buffer + 11));
   1183                      break;
   1184                    }
   1185                  case 6:
   1186                    {
   1187                      temp_value = ((*(point_to_buffer + 14))  << 8) | (*(point_to_buffer + 13));
   1188                      break;
   1189                    }
   1190                  case 7:
   1191                    {
   1192                      temp_value = ((*(point_to_buffer + 16))  << 8) | (*(point_to_buffer + 15));
   1193                      break;
   1194                    }
   1195                  case 8:
   1196                    {
   1197                      temp_value = ((*(point_to_buffer + 18))  << 8) | (*(point_to_buffer + 17));
   1198                      break;
   1199                    }
   1200                  case 9:
   1201                    {
   1202                      temp_value = ((*(point_to_buffer + 20))  << 8) | (*(point_to_buffer + 19));
   1203                      break;
   1204                    }
   1205                  case 10:
   1206                    {
   1207                      temp_value = ((*(point_to_buffer + 22))  << 8) | (*(point_to_buffer + 21));
   1208                      break;
   1209                    }
   1210                  case 11:
   1211                    {
   1212                      temp_value = ((*(point_to_buffer + 24))  << 8) | (*(point_to_buffer + 23));
   1213                      break;
   1214                    }
   1215                  case 12:
   1216                    {
   1217                      temp_value = ((*(point_to_buffer + 26))  << 8) | (*(point_to_buffer + 25));
   1218                      break;
   1219                    }
   1220                  case 13:
   1221                    {
   1222                      temp_value = ((*(point_to_buffer + 28))  << 8) | (*(point_to_buffer + 27));
   1223                      break;
   1224                    }
   1225                  case 14:
   1226                    {
   1227                      temp_value = ((*(point_to_buffer + 30))  << 8) | (*(point_to_buffer + 29));
   1228                      break;
   1229                    }
   1230                  default:
   1231                    {
   1232                      //Якщо немає помилок, то сюди б програма не мала заходити
   1233                      temp_value = 0;
   1234                      break;
   1235                    }
   1236                  }
   1237                }
   1238              }
   1239            }
   1240            else if (address_data == MA_POSSIBILITY_USTUVANNJA)
   1241            {
   1242              //Повідомлення про те, чи можна проводити операцю юстування
   1243              /*
   1244               0 - операція юстування є забороненою
   1245               1 - операція юстування є дозволеною
   1246              */
   1247              if (password_ustuvannja == 0x1978) temp_value = 1;
   1248              else temp_value = 0;
   1249            }
   1250            else if ((address_data >= MA_ADDRESS_FIRST_USTUVANNJA ) && (address_data <= MA_ADDRESS_LAST_USTUVANNJA))
   1251            {
   1252              temp_value = ustuvannja[address_data - MA_ADDRESS_FIRST_USTUVANNJA ];
   1253            }
   1254          //  else if ((address_data >= MA_ADDRESS_FIRST_PHI_USTUVANNJA ) && (address_data <= MA_ADDRESS_LAST_PHI_USTUVANNJA))
   1255          //  {
   1256          //    temp_value = phi_ustuvannja[address_data - MA_ADDRESS_FIRST_PHI_USTUVANNJA ];
   1257          //  }
   1258          //  else if (address_data == MA_NUMBER_ITERATION_EL)
   1259          //  {
   1260          //    temp_value = settings_fix_prt.number_iteration_el;
   1261          //  }
   1262            else if (address_data == MA_LSW_GLOBAL_RESURS_MIN)
   1263            {
   1264              temp_value = resurs_global_min & 0xffff;
   1265            }
   1266            else if (address_data == MA_MSW_GLOBAL_RESURS_MIN)
   1267            {
   1268              temp_value = resurs_global_min >> 16;
   1269            }
   1270            else if (address_data == MA_LSW_GLOBAL_RESURS_MAX)
   1271            {
   1272              temp_value = resurs_global_max & 0xffff;
   1273            }
   1274            else if (address_data == MA_MSW_GLOBAL_RESURS_MAX)
   1275            {
   1276              temp_value = resurs_global_max >> 16;
   1277            }
   1278            else if (address_data == MA_LSW_GLOBAL_RESURS)
   1279            {
   1280              temp_value = resurs_global & 0xffff;
   1281            }
   1282            else if (address_data == MA_MSW_GLOBAL_RESURS)
   1283            {
   1284              temp_value = resurs_global >> 16;
   1285            }
   1286            else if (address_data == MA_LSW_ADR_MEMORY_TO_WRITE)
   1287            {
   1288              temp_value = registers_address_write & 0xffff;
   1289            }
   1290            else if (address_data == MA_MSW_ADR_MEMORY_TO_WRITE)
   1291            {
   1292              temp_value = registers_address_write >> 16;
   1293            }
   1294            else if (address_data == MA_NB_REG_FROM_MEM_READ)
   1295            {
   1296              temp_value = number_registers_read;
   1297            }
   1298            else if (address_data == MA_LSW_ADR_MEMORY_TO_READ)
   1299            {
   1300              temp_value = registers_address_read & 0xffff;
   1301            }
   1302            else if (address_data == MA_MSW_ADR_MEMORY_TO_READ)
   1303            {
   1304              temp_value = registers_address_read >> 16;
   1305            }
   1306            else if((address_data >= M_ADDRESS_FIRST_READ_DAMP_MEM) && (address_data < M_ADDRESS_LAST_READ_DAMP_MEM))
   1307            {
   1308              temp_value = registers_values [address_data - M_ADDRESS_FIRST_READ_DAMP_MEM];
   1309            }
   1310            else if ((address_data >= M_ADDRESS_FIRST_TMP_MEASURMENTS) && (address_data < M_ADDRESS_LAST_TMP_MEASURMENTS))
   1311            {
   1312              if((address_data & 0x1) == 0)
   1313              {
   1314                temp_value = measurement_low[(address_data - M_ADDRESS_FIRST_TMP_MEASURMENTS)>>1] >> 16;
   1315              }
   1316              else
   1317              {
   1318                temp_value = measurement_low[(address_data - M_ADDRESS_FIRST_TMP_MEASURMENTS)>>1] & 0xffff;
   1319              }
   1320            }
   1321            else if((address_data >= M_ADDRESS_FIRST_DIG_OSCILOGRAPH)&& (address_data < M_ADDRESS_LAST_DIG_OSCILOGRAPH))
   1322            {
   1323              if(action_is_continued == true) error = ERROR_SLAVE_DEVICE_BUSY;
   1324              else
   1325              {
   1326                int temp_value_32bit = current_data_transmit[(part_transmit_carrent_data<<3) + ((address_data - M_ADDRESS_FIRST_DIG_OSCILOGRAPH) >> 1)];
   1327                if ( ((address_data - M_ADDRESS_FIRST_DIG_OSCILOGRAPH) & 0x1)  == 0)
   1328                {
   1329                  //Старше слово
   1330                  temp_value = (((unsigned int)temp_value_32bit) >> 16) & 0xffff;
   1331                }
   1332                else
   1333                {
   1334                  //Молодше слово
   1335                  temp_value = (((unsigned int)temp_value_32bit)      ) & 0xffff;
   1336                }
   1337              }
   1338            }
   1339            else
   1340            {
   1341              error = ERROR_ILLEGAL_DATA_ADDRESS;
   1342            }
   1343            
   1344            //Вставляємо у масив потрібні дані і вертаємо результат виконання функції (тип помилки. якщо вона зафіксована)
   1345            if (error == 0)
   1346            {
   1347              *data      = (temp_value >> 8) & 0xff;
   1348              *(data +1) =  temp_value       & 0xff;
   1349            }
   1350            
   1351            return error;
   1352          }
   1353          /***********************************************************************************/
   1354          
   1355          /***********************************************************************************/
   1356          //Запис даних
   1357          /***********************************************************************************/
   1358          inline unsigned int Set_data(unsigned short int data, unsigned int address_data, unsigned int method_setting, /*unsigned int to_be_continue, */unsigned int type_interface)
   1359          {
   1360            unsigned int error = 0, temp_value;
   1361            
   1362            __SETTINGS_FIX *target_label;
   1363            if (method_setting == SET_DATA_IMMEDITATE) target_label = &settings_fix;
   1364            else target_label = &settings_fix_edit;
   1365          
   1366            password_changed = false;
   1367            if (address_data == MA_PASSWORD_INTERFACE)
   1368            {
   1369              //Встановлення/зняття паролю доступу
   1370              if (type_interface == USB_RECUEST)
   1371              {
   1372                if (password_set_USB != 0)
   1373                {
   1374                  if ((data == settings_fix.password_interface_USB) || (data == 0x1978)) password_set_USB = 0;
   1375                  else error = ERROR_ILLEGAL_DATA_VALUE;
   1376                }
   1377                else if (password_set_USB == 0)
   1378                {
   1379                  if ((data != 0) && (data == settings_fix.password_interface_USB)) password_set_USB = 1;
   1380                  else 
   1381                  {
   1382                    target_label->password_interface_USB = data;
   1383                    password_changed = true;
   1384                  }
   1385                }
   1386              }
   1387              else if (type_interface == RS485_RECUEST)
   1388              {
   1389                if (password_set_RS485 != 0)
   1390                {
   1391                  if ((data == settings_fix.password_interface_RS485) || (data == 0x1978)) password_set_RS485 = 0;
   1392                  else error = ERROR_ILLEGAL_DATA_VALUE;
   1393                }
   1394                else if (password_set_RS485 == 0)
   1395                {
   1396                  if ((data != 0) && (data == settings_fix.password_interface_RS485)) password_set_RS485 = 1;
   1397                  else 
   1398                  {
   1399                    target_label->password_interface_RS485 = data;
   1400                    password_changed = true;
   1401                  }
   1402                }
   1403              }
   1404              else error = ERROR_SLAVE_DEVICE_FAILURE;
   1405            }
   1406            else if ((address_data >= M_ADDRESS_FIRST_USER_REGISTER) && (address_data <= M_ADDRESS_LAST_USER_REGISTER))
   1407            {
   1408              //Ранжування регістрів користувача
   1409              
   1410              if ( !((data >= M_ADDRESS_FIRST_USER_REGISTER_DATA) && (data <= M_ADDRESS_LAST_USER_REGISTER_DATA)) )
   1411              {
   1412                //Записуємо ранжування регістрів користувача
   1413                target_label->user_register[address_data - M_ADDRESS_FIRST_USER_REGISTER] = data;
   1414              }
   1415              else error = ERROR_ILLEGAL_DATA_VALUE;
   1416            }
   1417            else if ((address_data >= M_ADDRESS_CONTROL_BASE) && (address_data <= M_ADDRESS_CONTROL_LAST))
   1418            {
   1419              switch (address_data)
   1420              {
   1421              case M_ADDRESS_CONTROL_EL:
   1422                {
   1423                  //Для ЦС розширену логіку не можна вимикати
   1424                  if (((data >> (BIT_MA_CONFIGURATION_EL  - BIT_MA_CONTROL_EL_BASE)) & 0x1) == 0) error = ERROR_ILLEGAL_DATA_VALUE;
   1425          
   1426                  break;
   1427                }
   1428              default: break;
   1429              }
   1430            }
   1431            else if ((address_data >= M_ADDRESS_FIRST_SETPOINTS_PART1) && (address_data <= M_ADDRESS_LAST_SETPOINTS_PART1))
   1432            {
   1433              switch (address_data)
   1434              {
   1435              default: break;
   1436              }
   1437            }
   1438            else if (
   1439                     ((address_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G1)) && (address_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G1)))/* ||
   1440                     ((address_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G2)) && (address_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G2))) ||
   1441                     ((address_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G3)) && (address_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G3))) ||
   1442                     ((address_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G4)) && (address_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G4)))*/
   1443                    )   
   1444            {
   1445              //Уставки, витримки, які мають декілька груп уставок
   1446               unsigned int /*num_gr, */address_data_tmp = address_data;
   1447               if ((address_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G1)) && (address_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G1)))
   1448               {
   1449          //       num_gr = 0;
   1450                 address_data_tmp -= SHIFT_G1;
   1451               }
   1452          //     else if ((address_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G2)) && (address_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G2)))
   1453          //     {
   1454          //       num_gr = 1;
   1455          //       address_data_tmp -= SHIFT_G2;
   1456          //     }
   1457          //     else if ((address_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G3)) && (address_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G3)))
   1458          //     {
   1459          //       num_gr = 2;
   1460          //       address_data_tmp -= SHIFT_G3;
   1461          //     }
   1462          //     else
   1463          //     {
   1464          //       num_gr = 3;
   1465          //       address_data_tmp -= SHIFT_G4;
   1466          //     }
   1467               
   1468              switch (address_data_tmp)
   1469              {
   1470              default: break;
   1471              }
   1472            }
   1473            else if ((address_data >= M_ADDRESS_FIRST_SETPOINTS_CONTINUE) && (address_data <= M_ADDRESS_LAST_SETPOINTS_CONTINUE))
   1474            {
   1475              //Уставки і витримки (продовження), налаштування
   1476              switch (address_data)
   1477              {
   1478              case MA_UVV_TYPE_SIGNAL_INPUT:
   1479                {
   1480          //        if (data <= ((1 << NUMBER_INPUTS) - 1)) 
   1481          //        {
   1482          //          target_label->type_of_input_signal = data;
   1483          //          
   1484          //          //Коректуємо допуск входів
   1485          //          for(unsigned int i = 0; i < NUMBER_INPUTS; i++)
   1486          //          {
   1487          //            if ((target_label->type_of_input_signal & (1 << i)) !=0)
   1488          //            {
   1489          //              if ((target_label->dopusk_dv[i] % 10) != 0)
   1490          //              {
   1491          //                target_label->dopusk_dv[i] = (target_label->dopusk_dv[i] / 10)*10;
   1492          //              }
   1493          //
   1494          //              if (target_label->dopusk_dv[i] < KOEF_DOPUSK_DV_ZMIN_MIN)
   1495          //                target_label->dopusk_dv[i] = KOEF_DOPUSK_DV_ZMIN_MIN;
   1496          //            }
   1497          //          }
   1498          //        }
   1499          //        else
   1500          //          error = ERROR_ILLEGAL_DATA_VALUE;
   1501          
   1502                  break;
   1503                }
   1504              case MA_TYPE_DF:
   1505                {
   1506          //        if (data <= ((1 << NUMBER_DEFINED_FUNCTIONS) - 1)) 
   1507          //          target_label->type_df = data;
   1508          //        else
   1509          //          error = ERROR_ILLEGAL_DATA_VALUE;
   1510          
   1511                  break;
   1512                }
   1513              case MA_DOPUSK_DV_1:
   1514              case MA_DOPUSK_DV_2:
   1515              case MA_DOPUSK_DV_3:
   1516              case MA_DOPUSK_DV_4:
   1517              case MA_DOPUSK_DV_5:
   1518              case MA_DOPUSK_DV_6:
   1519              case MA_DOPUSK_DV_7:
   1520              case MA_DOPUSK_DV_8:
   1521              case MA_DOPUSK_DV_9:
   1522              case MA_DOPUSK_DV_10:
   1523                {
   1524                  if (data <= KOEF_DOPUSK_DV_MAX)
   1525                  {
   1526                    //Додатково перевіряємо нижню межу у випадку і крок, коли тип сигналу є змінний сигнал
   1527          //          if (
   1528          //              ((target_label->type_of_input_signal & (1 << (address_data - MA_DOPUSK_DV_1))) == 0) ||
   1529          //              (
   1530          //               ((target_label->type_of_input_signal & (1 << (address_data - MA_DOPUSK_DV_1))) != 0) &&
   1531          //               ( data >= KOEF_DOPUSK_DV_ZMIN_MIN)                                                   &&
   1532          //               ((data % 10) == 0)  
   1533          //              )
   1534          //             )
   1535          //          {
   1536          //            target_label->dopusk_dv[address_data - MA_DOPUSK_DV_1] = data;
   1537          //          }
   1538          //          else
   1539          //            error = ERROR_ILLEGAL_DATA_VALUE;
   1540                  }
   1541                  else
   1542                    error = ERROR_ILLEGAL_DATA_VALUE;
   1543          
   1544                  break;
   1545                }
   1546              case MA_DF_PAUSE_1:
   1547              case MA_DF_PAUSE_2:
   1548              case MA_DF_PAUSE_3:
   1549              case MA_DF_PAUSE_4:
   1550              case MA_DF_PAUSE_5:
   1551              case MA_DF_PAUSE_6:
   1552              case MA_DF_PAUSE_7:
   1553              case MA_DF_PAUSE_8:
   1554                {
   1555                  temp_value = data*10;
   1556                  
   1557          //#if (TIMEOUT_TIMER_PAUSE_MIN != 0)          
   1558          //        if ((temp_value >= TIMEOUT_TIMER_PAUSE_MIN) && (temp_value <= TIMEOUT_TIMER_PAUSE_MAX))
   1559          //#else
   1560          //        if (temp_value <= TIMEOUT_TIMER_PAUSE_MAX)
   1561          //#endif            
   1562          //        {
   1563          //          target_label->timeout_pause_df[address_data - MA_DF_PAUSE_1] = temp_value;
   1564          //        }
   1565          //        else
   1566          //          error = ERROR_ILLEGAL_DATA_VALUE;
   1567          
   1568                  break;
   1569                }
   1570              case MA_DF_WORK_1:
   1571              case MA_DF_WORK_2:
   1572              case MA_DF_WORK_3:
   1573              case MA_DF_WORK_4:
   1574              case MA_DF_WORK_5:
   1575              case MA_DF_WORK_6:
   1576              case MA_DF_WORK_7:
   1577              case MA_DF_WORK_8:
   1578                {
   1579          //        temp_value = data*10;
   1580          //        
   1581          //#if (TIMEOUT_TIMER_WORK_MIN != 0)          
   1582          //        if ((temp_value >= TIMEOUT_TIMER_WORK_MIN) && (temp_value <= TIMEOUT_TIMER_WORK_MAX))
   1583          //#else
   1584          //        if (temp_value <= TIMEOUT_TIMER_WORK_MAX)
   1585          //#endif            
   1586          //        {
   1587          //          target_label->timeout_work_df[address_data - MA_DF_WORK_1] = temp_value;
   1588          //        }
   1589          //        else
   1590          //          error = ERROR_ILLEGAL_DATA_VALUE;
   1591          
   1592                  break;
   1593                }
   1594              case MA_TO_DEACTIVATION_PASSWORD_INTERFACE:
   1595                {
   1596                  //Встановлення часу протягом якого, якщо немає звертання до інтерфейсу, то встановлюється пароль
   1597                  temp_value = data;
   1598                  
   1599                  if(
   1600          #if (TIMEOUT_DEACTIVATION_PASSWORD_MIN != 0)          
   1601                     ((temp_value >= TIMEOUT_DEACTIVATION_PASSWORD_MIN) && (temp_value <= TIMEOUT_DEACTIVATION_PASSWORD_MAX)) ||
   1602          #else
   1603                     (temp_value <= TIMEOUT_DEACTIVATION_PASSWORD_MAX) ||
   1604          #endif   
   1605                     (temp_value == TIMEOUT_DEACTIVATION_PASSWORD_OFF)
   1606                    )   
   1607                  {
   1608                    unsigned int *point_to_timeout_deactivation_password_interface;
   1609                    if (type_interface == USB_RECUEST)
   1610                    {
   1611                      point_to_timeout_deactivation_password_interface = &target_label->timeout_deactivation_password_interface_USB;
   1612                    }
   1613                    else if (type_interface == RS485_RECUEST)
   1614                    {
   1615                      point_to_timeout_deactivation_password_interface = &target_label->timeout_deactivation_password_interface_RS485;
   1616                    }
   1617                    else error = ERROR_SLAVE_DEVICE_FAILURE;
   1618                
   1619                    if (error == 0) *point_to_timeout_deactivation_password_interface = temp_value;
   1620                  }
   1621                  else
   1622                    error = ERROR_ILLEGAL_DATA_VALUE;
   1623          
   1624                  break;
   1625                }
   1626              case MA_TO_IDLE_NEW_SETTINGS:
   1627                {
   1628                  //Встановлення часу протягом якого, якщо немає нових змін налаштувнь, то попередні зміни налаштувань деактивуються
   1629                  temp_value = data;
   1630                  
   1631          #if (TIMEOUT_DEACTIVATION_PASSWORD_MIN != 0)          
   1632                  if ((temp_value >= TIMEOUT_NEW_SETTINGS_MIN) && (temp_value <= TIMEOUT_NEW_SETTINGS_MAX))
   1633          #else
   1634                  if (temp_value <= TIMEOUT_NEW_SETTINGS_MAX)
   1635          #endif   
   1636                    target_label->timeout_idle_new_settings = temp_value;
   1637                  else
   1638                    error = ERROR_ILLEGAL_DATA_VALUE;
   1639          
   1640                  break;
   1641                }
   1642              case MA_LANGUAGE_MENU:
   1643                {
   1644                  temp_value = data;
   1645                  
   1646          #if (VALUE_SETTING_LANGUAGE_MIN != 0)          
   1647                  if ((temp_value >= VALUE_SETTING_LANGUAGE_MIN) && (temp_value <= VALUE_SETTING_LANGUAGE_MAX))
   1648          #else
   1649                  if (temp_value <= VALUE_SETTING_LANGUAGE_MAX)
   1650          #endif            
   1651                    target_label->language = temp_value;
   1652                  else
   1653                    error = ERROR_ILLEGAL_DATA_VALUE;
   1654          
   1655                  break;
   1656                }
   1657              case MA_SPEED_RS485_1:
   1658                {
   1659                  temp_value = data;
   1660                  
   1661          #if (VALUE_BAUD_RS485_MIN != 0)          
   1662                  if ((temp_value >= VALUE_BAUD_RS485_MIN) && (temp_value <= VALUE_BAUD_RS485_MAX))
   1663          #else
   1664                  if (temp_value <= VALUE_BAUD_RS485_MAX)
   1665          #endif            
   1666                    target_label->baud_RS485 = temp_value;
   1667                  else
   1668                    error = ERROR_ILLEGAL_DATA_VALUE;
   1669          
   1670                  break;
   1671                }
   1672              case MA_STOP_BITS_RS485_1:
   1673                {
   1674                  temp_value = data - 1;
   1675                  
   1676          #if (VALUE_STOP_BITS_RS485_MIN != 0)          
   1677                  if ((temp_value >= VALUE_STOP_BITS_RS485_MIN) && (temp_value <= VALUE_STOP_BITS_RS485_MAX))
   1678          #else
   1679                  if (temp_value <= VALUE_STOP_BITS_RS485_MAX)
   1680          #endif            
   1681                    target_label->number_stop_bit_RS485 = temp_value;
   1682                  else
   1683                    error = ERROR_ILLEGAL_DATA_VALUE;
   1684          
   1685                  break;
   1686                }
   1687              case MA_PARE_RS485_1:
   1688                {
   1689                  temp_value = data;
   1690                  
   1691          #if (VALUE_PARE_RS485_MIN != 0)          
   1692                  if ((temp_value >= VALUE_PARE_RS485_MIN) && (temp_value <= VALUE_PARE_RS485_MAX))
   1693          #else
   1694                  if (temp_value <= VALUE_PARE_RS485_MAX)
   1695          #endif            
   1696                    target_label->pare_bit_RS485 = temp_value;
   1697                  else
   1698                    error = ERROR_ILLEGAL_DATA_VALUE;
   1699          
   1700                  break;
   1701                }
   1702              case MA_TIMEOUT_RS485_1:
   1703                {
   1704                  temp_value = data;
   1705                  
   1706          #if (VALUE_TIME_OUT_1_RS485_MIN != 0)          
   1707                  if ((temp_value >= VALUE_TIME_OUT_1_RS485_MIN) && (temp_value <= VALUE_TIME_OUT_1_RS485_MAX))
   1708          #else
   1709                  if (temp_value <= VALUE_TIME_OUT_1_RS485_MAX)
   1710          #endif            
   1711                    target_label->time_out_1_RS485 = temp_value;
   1712                  else
   1713                    error = ERROR_ILLEGAL_DATA_VALUE;
   1714          
   1715                  break;
   1716                }
   1717              case MA_LOGICAL_ADDRESS:
   1718                {
   1719                  temp_value = data;
   1720              
   1721                  if ((temp_value >= KOEF_ADDRESS_MIN) && (temp_value <= KOEF_ADDRESS_MAX))
   1722                    target_label->address = temp_value;
   1723                  else
   1724                    error = ERROR_ILLEGAL_DATA_VALUE;
   1725          
   1726                  break;
   1727                }
   1728              case MA_NAME_OF_CELL_CHARS_01_02:
   1729              case MA_NAME_OF_CELL_CHARS_03_04:
   1730              case MA_NAME_OF_CELL_CHARS_05_06:
   1731              case MA_NAME_OF_CELL_CHARS_07_08:
   1732              case MA_NAME_OF_CELL_CHARS_09_10:
   1733              case MA_NAME_OF_CELL_CHARS_11_12:
   1734              case MA_NAME_OF_CELL_CHARS_13_14:
   1735              case MA_NAME_OF_CELL_CHARS_15_16:
   1736                {
   1737                  
   1738                  unsigned int two_char_index = (address_data - MA_NAME_OF_CELL_CHARS_01_02) << 1;
   1739                  unsigned int byte_1 = (data & 0xff), byte_2 = (data >> 8) & 0xff;
   1740                  
   1741                  if (
   1742                      (
   1743                       (byte_1 >= 0x20) && (byte_1 <= 0x7e) || /*латинські символи і цифри*/
   1744                       (byte_1 >= 0xc0) && (byte_1 <= 0xff) || /*кириличні російські символи*/
   1745                       (byte_1 == 0xa8)                     || /*російський символ 'Ё'*/  
   1746                       (byte_1 == 0xb8)                     || /*російський символ 'ё'*/  
   1747                       (
   1748                        (target_label->language == LANGUAGE_UA) &&
   1749                        (
   1750                         (byte_1 == 0xaf)                     || /*український символ 'Ї'*/  
   1751                         (byte_1 == 0xbf)                     || /*український символ 'ї'*/  
   1752                         (byte_1 == 0xa5)                     || /*український символ 'Ґ'*/  
   1753                         (byte_1 == 0xb4)                     || /*український символ 'ґ'*/  
   1754                         (byte_1 == 0xaa)                     || /*український символ 'Є'*/  
   1755                         (byte_1 == 0xba)                        /*український символ 'є'*/  
   1756                        ) 
   1757                       ) 
   1758                      )
   1759                      &&  
   1760                      (
   1761                       (byte_2 >= 0x20) && (byte_2 <= 0x7e) || /*латинські символи і цифри*/
   1762                       (byte_2 >= 0xc0) && (byte_2 <= 0xff) || /*кириличні російські символи*/
   1763                       (byte_2 == 0xa8)                     || /*російський символ 'Ё'*/  
   1764                       (byte_2 == 0xb8)                     ||   /*російський символ 'ё'*/  
   1765                       (
   1766                        (target_label->language == LANGUAGE_UA) &&
   1767                        (
   1768                         (byte_2 == 0xaf)                     || /*український символ 'Ї'*/  
   1769                         (byte_2 == 0xbf)                     || /*український символ 'ї'*/  
   1770                         (byte_2 == 0xa5)                     || /*український символ 'Ґ'*/  
   1771                         (byte_2 == 0xb4)                     || /*український символ 'ґ'*/  
   1772                         (byte_2 == 0xaa)                     || /*український символ 'Є'*/  
   1773                         (byte_2 == 0xba)                        /*український символ 'є'*/  
   1774                        ) 
   1775                       )   
   1776                      )
   1777                     )
   1778                  {
   1779                    target_label->name_of_cell[two_char_index    ] = byte_1;
   1780                    target_label->name_of_cell[two_char_index + 1] = byte_2;
   1781                  }
   1782                  else
   1783                    error = ERROR_ILLEGAL_DATA_VALUE;
   1784                  
   1785                  break;
   1786                }
   1787              default: break;
   1788              }
   1789            }
   1790            else if ((address_data >= M_ADDRESS_FIRST_TIME_AND_DATA) && (address_data <= M_ADDRESS_LAST_TIME_AND_DATA))
   1791            {
   1792              temp_value = data & 0xff;
   1793              unsigned int tetrad_low = (temp_value & 0xf), tetrad_high = (temp_value >> 4);
   1794              
   1795              //Неправильне число, наприлкад, може бути. коли вводиться не 0x10, а 10 = 0xA і це сило 0xA буде вводитися в якийся регістр RTC
   1796              if((tetrad_low <= 0x9) && (tetrad_high <= 0x9))
   1797              {
   1798                switch (address_data)
   1799                {
   1800                case MA_YEAR:
   1801                  {
   1802                    time_edit[6] = temp_value;
   1803                    break;
   1804                  }
   1805                case MA_MONTH:
   1806                  {
   1807                    time_edit[5] = temp_value;
   1808                    break;
   1809                  }
   1810                case MA_DAY:
   1811                  {
   1812                    time_edit[4] = temp_value;
   1813                    break;
   1814                  }
   1815                case MA_HOUR:
   1816                  {
   1817                    time_edit[3] = temp_value;
   1818                    break;
   1819                  }
   1820                case MA_MINUTE:
   1821                  {
   1822                    time_edit[2] = temp_value;
   1823                    break;
   1824                  }
   1825                case MA_SECOND:
   1826                  {
   1827                    time_edit[1] = temp_value;
   1828                    break;
   1829                  }
   1830                case MA_MILISECOND:
   1831                  {
   1832                    time_edit[0] = temp_value;
   1833                    break;
   1834                  }
   1835                default: break;
   1836                }
   1837              }
   1838              else
   1839                error = ERROR_ILLEGAL_DATA_VALUE;
   1840            }
   1841            else if (address_data == MA_CLEAR_NUMBER_RECORD_PR_ERR)
   1842            {
   1843              if (
   1844                  /*
   1845                  (current_ekran.current_level == EKRAN_TITLES_PR_ERR_REGISTRATOR )
   1846                  ||  
   1847                  (current_ekran.current_level == EKRAN_DATA_LADEL_PR_ERR         )
   1848                  ||  
   1849                  (current_ekran.current_level == EKRAN_CHANGES_DIAGNOSTICS_PR_ERR)
   1850                  ||
   1851                  */
   1852                  (
   1853                   (control_tasks_dataflash & (
   1854                                               TASK_WRITE_PR_ERR_RECORDS_INTO_DATAFLASH    |
   1855                                               TASK_MAMORY_READ_DATAFLASH_FOR_PR_ERR_USB   |
   1856                                               TASK_MAMORY_READ_DATAFLASH_FOR_PR_ERR_RS485 |
   1857                                               TASK_MAMORY_READ_DATAFLASH_FOR_PR_ERR_MENU
   1858                                              )
   1859                   ) != 0
   1860                  )
   1861                  ||
   1862                  ((clean_rejestrators & CLEAN_PR_ERR) != 0)  
   1863                 ) 
   1864              {
   1865                //Зараз іде зчитування для інтерфейсу запису реєстратора програмних подій, або відкрите вікно відображення запису, тому ця операція є тимчасово недоступною
   1866                error = ERROR_SLAVE_DEVICE_BUSY;
   1867              }
   1868              else
   1869              {
   1870                //Помічаємо, що треба очистити реєстратор програмних подій
   1871                clean_rejestrators |= CLEAN_PR_ERR;
   1872              }
   1873            }
   1874            else if (address_data == MA_CURRENT_NUMBER_RECORD_PR_ERR)
   1875            {
   1876              if ((type_interface != USB_RECUEST) && (type_interface != RS485_RECUEST))
   1877              {
   1878                //Теоретично такого бути не мало б ніколи
   1879                error = ERROR_SLAVE_DEVICE_FAILURE;
   1880              }
   1881              else if (
   1882                       ((clean_rejestrators & CLEAN_PR_ERR) != 0) ||
   1883                       (
   1884                        ((type_interface == USB_RECUEST  ) && ((control_tasks_dataflash & TASK_MAMORY_READ_DATAFLASH_FOR_PR_ERR_USB  ) != 0)) ||
   1885                        ((type_interface == RS485_RECUEST) && ((control_tasks_dataflash & TASK_MAMORY_READ_DATAFLASH_FOR_PR_ERR_RS485) != 0))
   1886                       ) 
   1887                      )
   1888              {
   1889                /*
   1890                Зараз іде зчитування для інтерфейсу запису реєстратора програмних подій, 
   1891                або очистка його, тому ця операція є тимчасово недоступною
   1892                */
   1893                error = ERROR_SLAVE_DEVICE_BUSY;
   1894              }
   1895              else if (
   1896                       (data < info_rejestrator_pr_err.number_records) &&
   1897                       (data < MAX_NUMBER_RECORDS_INTO_PR_ERR        ) /*Хоч теоретично ця умова має перекриватися завжди першою умовою*/
   1898                      )
   1899              {
   1900                if (type_interface == USB_RECUEST)
   1901                {
   1902                  //Встановлюємо номер запису реєстратора програмних подій для читання через інтерфейс USB
   1903                  number_record_of_pr_err_into_USB = data;
   1904                  //Подаємо команду читання реєстратора програмних подій для  інтерфейсу USB
   1905          
   1906                  //Подаємо команду зчитати дані у бувер пам'яті для USB
   1907                  control_tasks_dataflash |= TASK_MAMORY_READ_DATAFLASH_FOR_PR_ERR_USB;
   1908                }
   1909                else if (type_interface == RS485_RECUEST)
   1910                {
   1911                  //Встановлюємо номер запису реєстратора програмних подій для читання через інтерфейс RS-485
   1912                  number_record_of_pr_err_into_RS485 = data;
   1913                  //Подаємо команду читання реєстратора програмних подій для  інтерфейсу RS-485
   1914          
   1915                  //Подаємо команду зчитати дані у бувер пам'яті для RS-485
   1916                  control_tasks_dataflash |= TASK_MAMORY_READ_DATAFLASH_FOR_PR_ERR_RS485;
   1917                }
   1918                else
   1919                {
   1920                  //Теоретично такого бути не мало б ніколи
   1921                  error = ERROR_SLAVE_DEVICE_FAILURE;
   1922                }
   1923              }
   1924              else
   1925                error = ERROR_ILLEGAL_DATA_VALUE;
   1926            }
   1927            else if (address_data == MA_SET_SERIAL_NUMBER)
   1928            {
   1929              if (password_ustuvannja == 0x1978)
   1930              {
   1931                //Ввід серійного номеру
   1932                if (method_setting == SET_DATA_IMMEDITATE)
   1933                  serial_number_dev = data;
   1934                else
   1935                  edit_serial_number_dev = data;
   1936              }
   1937              else 
   1938              {
   1939                /*У разі повідомлення про помилку тип помилки ставиться такий ніби така адреса взагалі є недоступною, щоб зменшити ймовірність несанкціонованого запису юстування*/
   1940                error = ERROR_ILLEGAL_DATA_ADDRESS;
   1941              }    
   1942            }
   1943            else if (address_data == MA_POSSIBILITY_USTUVANNJA)
   1944            {
   1945              if (password_ustuvannja != 0x1978)
   1946              {
   1947                //Встановлення паролю-дозволу юстування можливе тільки коли записується число 0x1978
   1948                if (data == 0x1978) password_ustuvannja = 0x1978;
   1949                else
   1950                {
   1951                  /*У разі повідомлення про помилку тип помилки ставиться такий ніби така адреса взагалі є недоступною, щоб зменшити ймовірність несанкціонованого запису юстування*/
   1952                  error = ERROR_ILLEGAL_DATA_ADDRESS;
   1953                }
   1954              }
   1955              else
   1956              {
   1957                //Записування будь-якого числа (крім числа, яке розблоковує юстування) приводить до заборони подальшого юстування
   1958                if (data != 0x1978) password_ustuvannja = 0;
   1959              }
   1960            }
   1961            else if ((address_data >= MA_ADDRESS_FIRST_USTUVANNJA ) && (address_data <= MA_ADDRESS_LAST_USTUVANNJA))
   1962            {
   1963              //Ючтування
   1964              if (password_ustuvannja == 0x1978)
   1965              {
   1966                if (method_setting == SET_DATA_IMMEDITATE)
   1967                  ustuvannja[address_data - MA_ADDRESS_FIRST_USTUVANNJA  ]  = data;
   1968                else
   1969                  edit_ustuvannja[address_data - MA_ADDRESS_FIRST_USTUVANNJA  ]  = data;
   1970              }
   1971              else 
   1972              {
   1973                /*У разі повідомлення про помилку тип помилки ставиться такий ніби така адреса взагалі є недоступною, щоб зменшити ймовірність несанкціонованого запису юстування*/
   1974                error = ERROR_ILLEGAL_DATA_ADDRESS;
   1975              }
   1976            }
   1977          //  else if ((address_data >= MA_ADDRESS_FIRST_PHI_USTUVANNJA ) && (address_data <= MA_ADDRESS_LAST_PHI_USTUVANNJA))
   1978          //  {
   1979          //    //Фазове ючтування
   1980          //    if (password_ustuvannja == 0x1978)
   1981          //    {
   1982          //      unsigned int index = address_data - MA_ADDRESS_FIRST_PHI_USTUVANNJA; 
   1983          //      int phi_tmp = (short int)data;
   1984          //      float phi_radian_tmp = PI*((float)phi_tmp)/1800.0f; /*Оскільки кут встановлюється з точнітю до десятих цілим числом, то для того, щоб отримати правильно радіани - треба поділити не на 180 а на 1800= 180х10 */
   1985          //      if (method_setting == SET_DATA_IMMEDITATE)
   1986          //      {
   1987          //        phi_ustuvannja[index] = phi_tmp;
   1988          //        phi_ustuvannja_sin_cos[2*index    ] = arm_sin_f32(phi_radian_tmp);
   1989          //        phi_ustuvannja_sin_cos[2*index + 1] = arm_cos_f32(phi_radian_tmp);
   1990          //      }
   1991          //      else
   1992          //      {
   1993          //        phi_edit_ustuvannja[index] = phi_tmp;
   1994          //        phi_edit_ustuvannja_sin_cos[2*index    ] = arm_sin_f32(phi_radian_tmp);
   1995          //        phi_edit_ustuvannja_sin_cos[2*index + 1] = arm_cos_f32(phi_radian_tmp);
   1996          //      }
   1997          //    }
   1998          //    else 
   1999          //    {
   2000          //      /*У разі повідомлення про помилку тип помилки ставиться такий ніби така адреса взагалі є недоступною, щоб зменшити ймовірність несанкціонованого запису юстування*/
   2001          //      error = ERROR_ILLEGAL_DATA_ADDRESS;
   2002          //    }
   2003          //  }
   2004          //  else if (address_data == MA_NUMBER_ITERATION_EL)
   2005          //  {
   2006          //    temp_value = data;
   2007          //    
   2008          //    if ((temp_value >= NUMBER_ITERATION_EL_MIN) && (temp_value <= NUMBER_ITERATION_EL_MAX))
   2009          //      target_label->number_iteration_el = temp_value;
   2010          //    else
   2011          //      error = ERROR_ILLEGAL_DATA_VALUE;
   2012          //  }
   2013            else if (address_data == MA_LSW_ADR_MEMORY_TO_WRITE)
   2014            {
   2015              registers_address_write = (registers_address_write & 0xffff0000) + (data);
   2016            }
   2017            else if (address_data == MA_MSW_ADR_MEMORY_TO_WRITE)
   2018            {
   2019             registers_address_write = (registers_address_write & 0xffff) + (data << 16);
   2020            }
   2021            else if (address_data == MA_LSW_DATA_MEMORY_TO_WRITE)
   2022            {
   2023              unsigned int *label;
   2024          
   2025              data_write_to_memory = (data_write_to_memory & 0xffff0000) + (data);
   2026              label = (unsigned int *)(registers_address_write);
   2027              *label = data_write_to_memory;
   2028            }
   2029            else if (address_data == MA_MSW_DATA_MEMORY_TO_WRITE)
   2030            {
   2031              data_write_to_memory = data << 16;
   2032            }
   2033            else if (address_data == MA_NB_REG_FROM_MEM_READ)
   2034            {
   2035              number_registers_read = data;
   2036            }
   2037            else if (address_data == MA_LSW_ADR_MEMORY_TO_READ)
   2038            {
   2039              unsigned int index;
   2040              unsigned short int *label;
   2041          
   2042              registers_address_read = (registers_address_read & 0xffff0000) + (data);
   2043              label = (unsigned short int *)(registers_address_read);
   2044          	  
   2045              for (index = 0; index<number_registers_read; index++)
   2046              {	
   2047                registers_values[index] = *(label++);
   2048              }
   2049            }
   2050            else if (address_data == MA_MSW_ADR_MEMORY_TO_READ)
   2051            {
   2052              registers_address_read = (registers_address_read & 0xffff) + (data << 16);
   2053            }
   2054            else if (address_data == MA_PART_RECEIVE_DIG_OSCILOGRAPH)
   2055            {
   2056              part_transmit_carrent_data = data;
   2057              if(part_transmit_carrent_data == 0)
   2058              {
   2059                action_is_continued = true;
   2060                command_to_receive_current_data = true;
   2061              }
   2062            }
   2063            else if (address_data == MA_DEFAULT_SETTINGS)
   2064            {
   2065              if (data != CMD_WORD_SET_DEFAULT_SETTINGS)
   2066              {
   2067                //Для встановлення мінімальної конфігурації має бути прописано по певній адресі визначене число - інакше повідомляємо, що такої адреси взагалі не існує (примітивний метод маскування від несанкціонованого дослідження карти пам'яті)
   2068                error = ERROR_ILLEGAL_DATA_ADDRESS;
   2069              }
   2070              else
   2071              {
   2072                //Скидаємо настройки у "мінімальні заводські значення"
   2073          //      min_settings(target_label);
   2074              }
   2075            }
   2076            else if (address_data == MA_TEST_WATCHDOGS)
   2077            {
   2078              if (data != CMD_TEST_EXTERNAL_WATCHDOG)
   2079              {
   2080                //Для тестування watchdog треба вказати конкретне число виду тестування - інакше повідомляємо, що такої адреси взагалі не існує (примітивний метод маскування від несанкціонованого дослідження карти пам'яті)
   2081                error = ERROR_ILLEGAL_DATA_ADDRESS;
   2082              }
   2083              else
   2084              {
   2085                //Передаємо команду на виконання
   2086                test_watchdogs = data;
   2087              }
   2088            }
   2089            else if (address_data == MA_CMD_RESET_RESURS_MIN_MAX)
   2090            {
   2091              //Скидаємо лічильники для ресурсу
   2092              restart_resurs_count = 0xff;/*Ненульове значення перезапускає лічильники*/
   2093            }
   2094            else error = ERROR_ILLEGAL_DATA_ADDRESS;
   2095          
   2096            return error;
   2097          }
   2098          /***********************************************************************************/
   2099          
   2100          /***********************************************************************************/
   2101          //Читання файлу
   2102          /***********************************************************************************/
   2103          //inline unsigned int Get_data_file(unsigned char* input_data, unsigned char* output_data, unsigned int* total_number_answer, unsigned int type_interface)
   2104          //{
   2105          //  unsigned int error = 0;
   2106          //  if( *(input_data + 0) == 0x6)
   2107          //  {
   2108          //    unsigned int number_file, number_record, length;
   2109          //    number_file   = ((*(input_data + 1)) << 8) + (*(input_data + 2));
   2110          //    number_record = ((*(input_data + 3)) << 8) + (*(input_data + 4));
   2111          //    length        = ((*(input_data + 5)) << 8) + (*(input_data + 6));
   2112          //    
   2113          //    unsigned int number_answer_local = (length << 1) + 1;
   2114          //    
   2115          //    *total_number_answer += (number_answer_local + 1); 
   2116          //
   2117          //    if ((type_interface != USB_RECUEST) && (type_interface != RS485_RECUEST))
   2118          //    {
   2119          //      //Теоретично такого бути не мало б ніколи
   2120          //      error = ERROR_SLAVE_DEVICE_FAILURE;
   2121          //    }
   2122          //    else if (
   2123          //             (number_file == 0)
   2124          //             ||  
   2125          //             (
   2126          //              (number_file >= 5) && 
   2127          //              (number_file <= 6) && 
   2128          //              (
   2129          //               ((type_interface == USB_RECUEST  ) && (number_record_of_dr_for_USB   == 0xffff)) ||
   2130          //               ((type_interface == RS485_RECUEST) && (number_record_of_dr_for_RS485 == 0xffff))
   2131          //              )   
   2132          //             )
   2133          //             ||  
   2134          //             (number_file > 6)
   2135          //            )
   2136          //    {
   2137          //      //Невірний номер файлу, або не подано команди вичитування відповідного запису
   2138          //      error = ERROR_ILLEGAL_DATA_ADDRESS;
   2139          //    }
   2140          //    else if (
   2141          //             (number_file >= 5) &&
   2142          //             (number_file <= 6) && 
   2143          //             (
   2144          //              (
   2145          //               ((type_interface == USB_RECUEST  ) && ((control_tasks_dataflash & TASK_MAMORY_READ_DATAFLASH_FOR_DR_USB  ) != 0)) ||
   2146          //               ((type_interface == RS485_RECUEST) && ((control_tasks_dataflash & TASK_MAMORY_READ_DATAFLASH_FOR_DR_RS485) != 0))
   2147          //              ) 
   2148          //              ||  
   2149          //              ((clean_rejestrators & CLEAN_DR) != 0)
   2150          //             )  
   2151          //            )   
   2152          //    {
   2153          //      //Зараз іде зчитування для інтерфейсу запису дискретного реєстратора, тому ця операція є тимчасово недоступною
   2154          //      error = ERROR_SLAVE_DEVICE_BUSY;
   2155          //    }
   2156          //    else if ((*total_number_answer + 5) < 255)
   2157          //    {
   2158          //      *(output_data + 0 ) = number_answer_local;
   2159          //      *(output_data + 1 ) = 0x6;
   2160          //      //Дальше ідуть дані файлу відповіді
   2161          //
   2162          //      int temp_data;
   2163          //      switch (number_file)
   2164          //      {
   2165          //      case 5:
   2166          //        {
   2167          //          //*************************************
   2168          //          //Заголовок для дискретного реєстратора
   2169          //          //*************************************
   2170          //          unsigned char *point_to_buffer;
   2171          //          if (type_interface == USB_RECUEST) point_to_buffer = buffer_for_USB_read_record_dr;
   2172          //          else point_to_buffer = buffer_for_RS485_read_record_dr;
   2173          //
   2174          //          switch (number_record)
   2175          //          {
   2176          //          case 0:
   2177          //            {
   2178          //              if (length <= 10)
   2179          //              {
   2180          //                unsigned int i = 0;
   2181          //                while (i < length)
   2182          //                {
   2183          //                  if (i < 8)
   2184          //                  {
   2185          //                    unsigned int index_cell;
   2186          //                    
   2187          //                    index_cell =  (i - 0)<<1;
   2188          //                    temp_data  = (*(point_to_buffer + FIRST_INDEX_NAME_OF_CELL_DR + index_cell)) | ((*(point_to_buffer + FIRST_INDEX_NAME_OF_CELL_DR + index_cell + 1))<<8);
   2189          //                  }
   2190          //                  else if (i == 8)
   2191          //                  {
   2192          //                    //Серійний номер пристрою завжди один і той самий (встановлюється на заводі-виготовнику), тому я його не включив для запису у DataFlash у складі заголовку аналогового реєстратора
   2193          //                    temp_data = serial_number_dev & 0xffff;
   2194          //                  }
   2195          //                  else
   2196          //                  {
   2197          //                    temp_data = 1999;
   2198          //                  }
   2199          //                  *(output_data + 2 + 2*i) = (temp_data >> 8) & 0xff;
   2200          //                  *(output_data + 3 + 2*i) = temp_data & 0xff;
   2201          //                  i++;
   2202          //                }
   2203          //              }
   2204          //              else error = ERROR_ILLEGAL_DATA_ADDRESS;
   2205          //              break;
   2206          //            }
   2207          //          case 1:
   2208          //            {
   2209          //              if (length <= 3)
   2210          //              {
   2211          //                unsigned int i = 0;
   2212          //                while (i < length)
   2213          //                {
   2214          //                  if (i == 0)
   2215          //                  {
   2216          //                    temp_data  = 0 + NUMBER_TOTAL_SIGNAL_FOR_RANG;
   2217          //                  }
   2218          //                  else if (i == 1)
   2219          //                  {
   2220          //                    temp_data = 0;
   2221          //                  }
   2222          //                  else
   2223          //                  {
   2224          //                    temp_data = NUMBER_TOTAL_SIGNAL_FOR_RANG;
   2225          //                  }
   2226          //                  *(output_data + 2 + 2*i) = (temp_data >> 8) & 0xff;
   2227          //                  *(output_data + 3 + 2*i) = temp_data & 0xff;
   2228          //                  i++;
   2229          //                }
   2230          //              }
   2231          //              else error = ERROR_ILLEGAL_DATA_ADDRESS;
   2232          //              break;
   2233          //            }
   2234          //          case 2:
   2235          //          case 3:
   2236          //          case 4:
   2237          //          case 5:
   2238          //          case 6:
   2239          //          case 7:
   2240          //          case 8:
   2241          //          case 9:
   2242          //          case 10:
   2243          //          case 11:
   2244          //          case 12:
   2245          //          case 13:
   2246          //          case 14:
   2247          //          case 15:
   2248          //          case 16:
   2249          //          case 17:
   2250          //          case 18:
   2251          //          case 19:
   2252          //          case 20:
   2253          //          case 21:
   2254          //          case 22:
   2255          //          case 23:
   2256          //          case 24:
   2257          //          case 25:
   2258          //          case 26:
   2259          //          case 27:
   2260          //          case 28:
   2261          //          case 29:
   2262          //          case 30:
   2263          //          case 31:
   2264          //          case 32:
   2265          //          case 33:
   2266          //          case 34:
   2267          //          case 35:
   2268          //          case 36:
   2269          //          case 37:
   2270          //          case 38:
   2271          //          case 39:
   2272          //          case 40:
   2273          //          case 41:
   2274          //          case 42:
   2275          //          case 43:
   2276          //          case 44:
   2277          //          case 45:
   2278          //          case 46:
   2279          //          case 47:
   2280          //          case 48:
   2281          //          case 49:
   2282          //          case 50:
   2283          //          case 51:
   2284          //          case 52:
   2285          //          case 53:
   2286          //          case 54:
   2287          //          case 55:
   2288          //          case 56:
   2289          //          case 57:
   2290          //          case 58:
   2291          //          case 59:
   2292          //          case 60:
   2293          //          case 61:
   2294          //          case 62:
   2295          //          case 63:
   2296          //          case 64:
   2297          //          case 65:
   2298          //          case 66:
   2299          //          case 67:
   2300          //          case 68:
   2301          //          case 69:
   2302          //          case 70:
   2303          //          case 71:
   2304          //          case 72:
   2305          //          case 73:
   2306          //          case 74:
   2307          //          case 75:
   2308          //          case 76:
   2309          //          case 77:
   2310          //          case 78:
   2311          //          case 79:
   2312          //          case 80:
   2313          //          case 81:
   2314          //          case 82:
   2315          //          case 83:
   2316          //          case 84:
   2317          //          case 85:
   2318          //          case 86:
   2319          //          case 87:
   2320          //          case 88:
   2321          //          case 89:
   2322          //          case 90:
   2323          //          case 91:
   2324          //          case 92:
   2325          //          case 93:
   2326          //          case 94:
   2327          //            {
   2328          //              if (length <= 19)
   2329          //              {
   2330          //                unsigned int i = 0;
   2331          //                while (i < length)
   2332          //                {
   2333          //                  if (i == 0)
   2334          //                  {
   2335          //                    //Номер каналу
   2336          //                    temp_data = (number_record - 2) + 1;
   2337          //                  }
   2338          //                  else if ( i < 9)
   2339          //                  {
   2340          //                    //Ідентитифікатор каналу - 16 ASCII символів
   2341          //                    const char idetyficator[MAX_NAMBER_LANGUAGE][NUMBER_TOTAL_SIGNAL_FOR_RANG][16] =
   2342          //                    {
   2343          //                      {NAME_RANG_RU},
   2344          //                      {NAME_RANG_UA},
   2345          //                      {NAME_RANG_EN},
   2346          //                      {NAME_RANG_KZ},
   2347          //                    };
   2348          //                    int index_language = index_language_in_array(settings_fix.language);
   2349          //                    unsigned int index_cell;
   2350          //                    
   2351          //                    index_cell =  (i - 1)<<1;
   2352          //                    temp_data  = idetyficator[index_language][number_record - 2][index_cell] | (idetyficator[index_language][number_record - 2][index_cell+1]<<8);
   2353          //                  }
   2354          //                  else if ( i == 9)
   2355          //                  {
   2356          //                    //Фаза каналу - 2 ASCII символів - нічого не передаємо
   2357          //                    temp_data  = (' '<<8) | ' ';
   2358          //                  }
   2359          //                  else if ( i < 18)
   2360          //                  {
   2361          //                    //Спостережний елемент в колі - 16 ASCII символів- нічого не передаємо
   2362          //                    temp_data  = (' '<<8) | ' ';
   2363          //                  }
   2364          //                  else if ( i == 18)
   2365          //                  {
   2366          //                    //Нормальний стан
   2367          //                    temp_data  = 0;
   2368          //                  }
   2369          //                  *(output_data + 2 + 2*i) = (temp_data >> 8) & 0xff;
   2370          //                  *(output_data + 3 + 2*i) = temp_data & 0xff;
   2371          //                  i++;
   2372          //                }
   2373          //              }
   2374          //              else error = ERROR_ILLEGAL_DATA_ADDRESS;
   2375          //              break;
   2376          //            }
   2377          //          case ( 2 + NUMBER_TOTAL_SIGNAL_FOR_RANG):
   2378          //          case ( 3 + NUMBER_TOTAL_SIGNAL_FOR_RANG):
   2379          //            {
   2380          //              if (length <= 1)
   2381          //              {
   2382          //                
   2383          //                if (number_record == ( 2 + NUMBER_TOTAL_SIGNAL_FOR_RANG))
   2384          //                {
   2385          //                  temp_data  = MAIN_FREQUENCY*100; //Чатота лінії
   2386          //                }
   2387          //                else
   2388          //                {
   2389          //                  temp_data  = 0; //Кількість частот дискретизації
   2390          //                }
   2391          //                *(output_data + 2 ) = (temp_data >> 8) & 0xff;
   2392          //                *(output_data + 3 ) = temp_data & 0xff;
   2393          //              }
   2394          //              else error = ERROR_ILLEGAL_DATA_ADDRESS;
   2395          //              break;
   2396          //            }
   2397          //          case ( 4 + NUMBER_TOTAL_SIGNAL_FOR_RANG):
   2398          //            {
   2399          //              if (length <= 2)
   2400          //              {
   2401          //                unsigned int i = 0;
   2402          //                while (i < length)
   2403          //                {
   2404          //                  if (i == 0) temp_data  = 0; //Частота виборки
   2405          //                  else
   2406          //                  {
   2407          //                      temp_data = *(point_to_buffer + FIRST_INDEX_NUMBER_ITEMS_DR); //кількість запичсів у дискретному реєстраторі співпадає з номером останньої виборки (я так вважаю)
   2408          //                  }
   2409          //                  
   2410          //                  *(output_data + 2 + 2*i) = (temp_data >> 8) & 0xff;
   2411          //                  *(output_data + 3 + 2*i) = temp_data & 0xff;
   2412          //                  i++;
   2413          //                }
   2414          //              }
   2415          //              else error = ERROR_ILLEGAL_DATA_ADDRESS;
   2416          //              break;
   2417          //            }
   2418          //          case ( 5 + NUMBER_TOTAL_SIGNAL_FOR_RANG):
   2419          //          case ( 6 + NUMBER_TOTAL_SIGNAL_FOR_RANG):
   2420          //            {
   2421          //              
   2422          //              if (length <= 7)
   2423          //              {
   2424          //                //Конвертуємо формат BCD у int
   2425          //                unsigned int time_avar_digital[7];
   2426          //
   2427          //                //Конвертуємо формат BCD у int
   2428          //                for (unsigned int i = 0; i < 7; i++)
   2429          //                {
   2430          //                  unsigned int val = *(point_to_buffer + FIRST_INDEX_DATA_TIME_DR + i), val_l, val_m;
   2431          //                  val_l = val & 0xf;
   2432          //                  val_m = (val >> 4) & 0xf;
   2433          //                  time_avar_digital[i] = val_m*10 + val_l;
   2434          //                }
   2435          //                  
   2436          //                unsigned int i = 0;
   2437          //                while (i < length)
   2438          //                {
   2439          //                  if (i < 3)
   2440          //                  {
   2441          //                    temp_data = time_avar_digital[4 + i];
   2442          //                    if (i == 2)temp_data += 2000; //Бо формат має бути чотиризначним числом
   2443          //                  }
   2444          //                  else if (i < 5 ) temp_data = time_avar_digital[3 - (i - 3)];
   2445          //                  else if (i == 5) temp_data = time_avar_digital[1]*100 + time_avar_digital[0];
   2446          //                  else temp_data = 0;/*Значення мілісекунд - зараз у нашій системі не фіксується*/
   2447          //
   2448          //                  *(output_data + 2 + 2*i) = (temp_data >> 8) & 0xff;
   2449          //                  *(output_data + 3 + 2*i) = temp_data & 0xff;
   2450          //                  i++;
   2451          //                }
   2452          //              }
   2453          //              else error = ERROR_ILLEGAL_DATA_ADDRESS;
   2454          //              break;
   2455          //            }
   2456          //          case ( 7 + NUMBER_TOTAL_SIGNAL_FOR_RANG):
   2457          //          case ( 8 + NUMBER_TOTAL_SIGNAL_FOR_RANG):
   2458          //            {
   2459          //              if (length <= 1)
   2460          //              {
   2461          //                
   2462          //                if (number_record == ( 7 + NUMBER_TOTAL_SIGNAL_FOR_RANG))
   2463          //                {
   2464          //                  temp_data  = 'B'; //дані - це вінарні числа
   2465          //                }
   2466          //                else temp_data  = 1000; //Множник, на який множиться часова мітка з файлу даних, щоб отримати мікросекунди
   2467          //                *(output_data + 2 ) = (temp_data >> 8) & 0xff;
   2468          //                *(output_data + 3 ) = temp_data & 0xff;
   2469          //              }
   2470          //              else error = ERROR_ILLEGAL_DATA_ADDRESS;
   2471          //              break;
   2472          //            }
   2473          //          default:
   2474          //            {
   2475          //              error = ERROR_ILLEGAL_DATA_ADDRESS;
   2476          //              break;
   2477          //            }
   2478          //          }
   2479          //          //*************************************
   2480          //          break;
   2481          //        }
   2482          //      case 6:
   2483          //        {
   2484          //          //*************************************
   2485          //          //Дані 1 для дискретного реєстратора
   2486          //          //*************************************
   2487          //          unsigned char *point_to_buffer;
   2488          //          if (type_interface == USB_RECUEST) point_to_buffer = buffer_for_USB_read_record_dr;
   2489          //          else point_to_buffer = buffer_for_RS485_read_record_dr;
   2490          //
   2491          //          if (number_record < (*(point_to_buffer + FIRST_INDEX_NUMBER_ITEMS_DR)))
   2492          //          {
   2493          //            unsigned int max_number_two_bytes = (NUMBER_TOTAL_SIGNAL_FOR_RANG >> 4);
   2494          //            if ((max_number_two_bytes << 4) != NUMBER_TOTAL_SIGNAL_FOR_RANG)
   2495          //              max_number_two_bytes++;
   2496          //              
   2497          //            if (length <= (3 + max_number_two_bytes))
   2498          //            {
   2499          //              unsigned int i = 0;
   2500          //              while (i < length)
   2501          //              {
   2502          //                if (i == 0) temp_data = number_record + 1;
   2503          //                else
   2504          //                {
   2505          //                  unsigned int offset = FIRST_INDEX_FIRST_DATA_DR + (number_record + 1)*29; //бо найперший запис містить попереднє значення (до фіксації запуску роботи дискретного реєстратора)
   2506          //                  if (i == 1)
   2507          //                  {
   2508          //                    temp_data =  (*(point_to_buffer + offset + 0)) + ((*(point_to_buffer + offset + 1)) << 8 );
   2509          //                  }
   2510          //                  else if (i == 2)
   2511          //                  {
   2512          //                    temp_data =  *(point_to_buffer + offset + 2);
   2513          //                  }
   2514          //                  else
   2515          //                  {
   2516          //                    temp_data = (*(point_to_buffer + offset + 3 + (i - 3)*2)) + ((*(point_to_buffer + offset + 4 + (i - 3)*2)) << 8);
   2517          //                  }
   2518          //                }
   2519          //                *(output_data + 2 + 2*i) = (temp_data >> 8) & 0xff;
   2520          //                *(output_data + 3 + 2*i) = temp_data & 0xff;
   2521          //                i++;
   2522          //              }
   2523          //            }
   2524          //            else error = ERROR_ILLEGAL_DATA_ADDRESS;
   2525          //          }
   2526          //          else error = ERROR_ILLEGAL_DATA_ADDRESS;
   2527          //          //*************************************
   2528          //          break;
   2529          //        }
   2530          //      default:
   2531          //        {
   2532          //          //Теоретично, суди програма ніколи не мала заходити
   2533          //          error = ERROR_ILLEGAL_DATA_ADDRESS;
   2534          //          break;
   2535          //        }
   2536          //      }
   2537          //    }
   2538          //    else error = ERROR_ILLEGAL_DATA_ADDRESS;
   2539          //  }
   2540          //  else error = ERROR_ILLEGAL_DATA_ADDRESS;
   2541          //  return error;  
   2542          //}
   2543          /***********************************************************************************/
   2544          
   2545          /***********************************************************************************/
   2546          //Подача команди нва передачу даних через інтерфейс RS-485
   2547          /***********************************************************************************/
   2548          inline void start_transmint_data_via_RS_485(unsigned int count)
   2549          {
   2550            //Перевіряємо, чи можна передавати дані
   2551            unsigned int current_time_tim4 = TIM4->CNT;
   2552            unsigned int delta_time;
   2553          
   2554            //Вираховуємо час, протягом якого підготовлювалася відповідь
   2555            if (
   2556                (current_time_tim4 > time_last_receive_byte) ||
   2557                (
   2558                 (current_time_tim4 == time_last_receive_byte) &&
   2559                 (mark_current_tick_RS_485 != 0)  
   2560                ) 
   2561               )   
   2562              delta_time = current_time_tim4 - time_last_receive_byte;
   2563            else 
   2564              delta_time = current_time_tim4 + 0xffff - time_last_receive_byte;
   2565          
   2566            if (max_reaction_time_rs_485 < delta_time) max_reaction_time_rs_485 = delta_time;
   2567            
   2568            if (delta_time < MAX_TIMEOUT_PACKET)
   2569            {
   2570              //Можна відповідати на запит
   2571          
   2572              //Переводимо мікросхкму на передачу
   2573              GPIO_485DE->BSRRL = GPIO_PIN_485DE;
   2574          
   2575              //Скидаємо біт, що символізує, що опстанній байт переданий
   2576              USART_ClearFlag(USART_RS485, USART_FLAG_TC);
   2577          
   2578              //Дозволяємо генерацію переривання, коли  буде передано всі даних по DMA1 через канал DMA1_ChannelRS485_TX
   2579              DMA_StreamRS485_Tx->CR |= DMA_IT_TC;
   2580          
   2581              //Зупиняємо потік DMA якщо він запущений
   2582              if ((DMA_StreamRS485_Tx->CR & (uint32_t)DMA_SxCR_EN) !=0) DMA_StreamRS485_Tx->CR &= ~(uint32_t)DMA_SxCR_EN;
   2583              DMA_StreamRS485_Tx->NDTR = count;
   2584              //Дозволяємо передачу через DMA
   2585              if ((USART_RS485->CR3 & USART_DMAReq_Tx) == 0) USART_RS485->CR3 |= USART_DMAReq_Tx;
   2586          
   2587              //Очищаємо прапореці, що сигналізує про завершення передачі даних для DMA1 по потоку RS-485_TX
   2588              DMA_ClearFlag(DMA_StreamRS485_Tx, DMA_FLAG_TCRS485_Tx | DMA_FLAG_HTRS485_Tx | DMA_FLAG_TEIRS485_Tx | DMA_FLAG_DMEIRS485_Tx | DMA_FLAG_FEIRS485_Tx);
   2589              //Запускаємо передачу
   2590              DMA_StreamRS485_Tx->CR |= (uint32_t)DMA_SxCR_EN;
   2591            }
   2592            else
   2593            {
   2594              //На запит відповідати не можна, бо відповідь готувался більший час ніж відведений час формування відповіді - Треба приступити до нового моніыторингу лінії RS-485
   2595              restart_monitoring_RS485();
   2596            }
   2597          }
   2598          /***********************************************************************************/
   2599          
   2600          /***********************************************************************************/
   2601          //Програма обробки запиту по протоколу MODBUS-RTU
   2602          /***********************************************************************************/
   2603          void modbus_rountines(unsigned int type_interface)
   2604          {
   2605           unsigned char *received_buffer, *transmited_buffer;
   2606           int volatile *received_count;
   2607           int *transmited_count;
   2608           unsigned int error = 0;
   2609            
   2610            if(type_interface == USB_RECUEST)
   2611            {
   2612              received_buffer = usb_received;
   2613              transmited_buffer = usb_transmiting;
   2614              received_count = &usb_received_count;
   2615              transmited_count = &usb_transmiting_count;
   2616            }
   2617            else if (type_interface == RS485_RECUEST)
   2618            {
   2619              received_buffer = RxBuffer_RS485;
   2620              transmited_buffer = TxBuffer_RS485;
   2621              received_count = &RxBuffer_RS485_count;
   2622              transmited_count = &TxBuffer_RS485_count;
   2623            }
   2624            else
   2625            {
   2626              //Теоретично цього ніколи не мало б бути
   2627              total_error_sw_fixed(45);
   2628            }
   2629             
   2630            //Перевірка адреси запитуваного приладу
   2631            unsigned int global_requect;
   2632            if(
   2633               (*received_count >= 3)  
   2634               &&
   2635               (
   2636                ((global_requect = (*received_buffer == BROADCAST_ADDRESS_MODBUS_RTU)) != 0) ||
   2637                (*received_buffer == settings_fix.address)
   2638               )
   2639              )   
   2640            {
   2641              unsigned short int CRC_sum;
   2642              
   2643              //Перевірка контрольної суми
   2644              CRC_sum = 0xffff;
   2645              for (int index = 0; index < (*received_count-2); index++) CRC_sum = AddCRC(*(received_buffer + index),CRC_sum);
   2646          
   2647              unsigned int func_modbus = *(received_buffer+1);
   2648              if (
   2649                  ((CRC_sum & 0xff) == *(received_buffer+*received_count-2)) &&
   2650                  ((CRC_sum >> 8  ) == *(received_buffer+*received_count-1)) &&
   2651                  (
   2652                   (global_requect == 0) ||
   2653                   (func_modbus == 6 ) ||
   2654                   (func_modbus == 16)
   2655                  )
   2656                 )
   2657              {
   2658                //Подаємо команду на скинення лічильника очікування нового запиту з вказаного інтерфейсу
   2659                restart_timeout_interface |= (1 << type_interface);
   2660                
   2661                //Обробка даних
   2662                switch (func_modbus)
   2663                {
   2664                case 1:
   2665                case 2:
   2666                  {
   2667                    unsigned int add_data, number;
   2668                    unsigned int number_byte_transmit, number_word_transmit, number_word_read;
   2669                    unsigned int offset;
   2670          
   2671                    add_data = (*(received_buffer + 2))<<8 | (*(received_buffer + 3));
   2672                    number   = (*(received_buffer + 4))<<8 | (*(received_buffer + 5));
   2673                    
   2674                    number_byte_transmit = number >> 3;
   2675                    if((number_byte_transmit<<3) < number) number_byte_transmit++; //Оскільки нам треба заокруглювати до більшого числа при діленні на 8 (зсув на три розряди вліво)
   2676          
   2677                    //Визначаємо кількість інформаційних слів (2 байти) у відповіді
   2678                    if ((number_byte_transmit & 0x1) == 0)
   2679                    {
   2680                      //Парна кількість байт, а значить ділення на 2 дасть точну кількість слів
   2681                      number_word_transmit = number_byte_transmit >> 1;
   2682                    }
   2683                    else
   2684                    {
   2685                      //Непарна кількість байт, а значить перед діленням на 2 треба ще додати один байт, щоб отримати кількість слів для зчитування
   2686                      number_word_transmit = (number_byte_transmit + 1) >> 1;
   2687                    }
   2688                             
   2689                    if(
   2690                       (number != 0                   ) &&
   2691                       (number_byte_transmit < (255-5)) &&
   2692                       (
   2693          #if (BIT_MA_OUTPUTS_LAST + 1) < BIT_MA_INPUTS_LAST
   2694                        ((add_data >= BIT_MA_OUTPUTS_BASE   ) && ((add_data + number - 1) <= BIT_MA_OUTPUTS_LAST   )) ||
   2695                        ((add_data >= BIT_MA_INPUTS_BASE    ) && ((add_data + number - 1) <= BIT_MA_INPUTS_LAST    )) ||
   2696          #else
   2697                        ((add_data >= BIT_MA_OUTPUTS_BASE   ) && ((add_data + number - 1) <= BIT_MA_INPUTS_LAST    )) ||
   2698          #endif
   2699                        ((add_data >= BIT_MA_LEDS_BASE      ) && ((add_data + number - 1) <= BIT_MA_LEDS_LAST      )) ||
   2700                        ((add_data >= BIT_MA_CONTROL_BASE   ) && ((add_data + number - 1) <= BIT_MA_CONTROL_LAST   )) ||
   2701          #if (BIT_MA_CURRENT_AF_LAST + 1) < BIT_MA_GENERAL_AF_BASE
   2702                        ((add_data >= BIT_MA_CURRENT_AF_BASE) && ((add_data + number - 1) <= BIT_MA_CURRENT_AF_LAST)) ||
   2703                        ((add_data >= BIT_MA_GENERAL_AF_BASE) && ((add_data + number - 1) <= BIT_MA_GENERAL_AF_LAST)) 
   2704          #else
   2705                        ((add_data >= BIT_MA_CURRENT_AF_BASE) && ((add_data + number - 1) <= BIT_MA_GENERAL_AF_LAST)) 
   2706          #endif
   2707                       )
   2708                      )
   2709                    {
   2710                      unsigned int first_address_of_word_for_function_3_or_4;
   2711          
   2712                      //Формуємо початок відповіді
   2713                      *transmited_buffer = *(received_buffer);
   2714                      *(transmited_buffer + 1) = *(received_buffer + 1);
   2715                      *(transmited_buffer + 2) = number_byte_transmit;
   2716          
   2717          #if (BIT_MA_OUTPUTS_LAST + 1) < BIT_MA_INPUTS_LAST            
   2718                      if((add_data >= BIT_MA_OUTPUTS_BASE   ) && ((add_data + number - 1) <= BIT_MA_OUTPUTS_LAST   ))
   2719                      {
   2720                        //Стан виходів
   2721                        offset = add_data - BIT_MA_OUTPUTS_BASE;
   2722                        first_address_of_word_for_function_3_or_4 = MA_OUTPUTS;
   2723                      }
   2724                      else if((add_data >= BIT_MA_INPUTS_BASE    ) && ((add_data + number - 1) <= BIT_MA_INPUTS_LAST    ))
   2725                      {
   2726                        //Стан входів
   2727                        offset = add_data - BIT_MA_INPUTS_BASE;
   2728                        first_address_of_word_for_function_3_or_4 = MA_INPUTS;
   2729                      }
   2730          #else
   2731                      if((add_data >= BIT_MA_OUTPUTS_BASE   ) && ((add_data + number - 1) <= BIT_MA_INPUTS_LAST   ))
   2732                      {
   2733                        //Стан виходів + входів
   2734                        offset = add_data - BIT_MA_OUTPUTS_BASE;
   2735                        first_address_of_word_for_function_3_or_4 = MA_OUTPUTS;
   2736                      }
   2737          #endif
   2738                      else if((add_data >= BIT_MA_LEDS_BASE      ) && ((add_data + number - 1) <= BIT_MA_LEDS_LAST      ))
   2739                      {
   2740                        //Стан світлоіндикаторів
   2741                        offset = add_data - BIT_MA_LEDS_BASE;
   2742                        first_address_of_word_for_function_3_or_4 = MA_LEDS;
   2743                      }
   2744                      else if((add_data >= BIT_MA_CONTROL_BASE   ) && ((add_data + number - 1) <= BIT_MA_CONTROL_LAST   ))
   2745                      {
   2746                        //Стан функцій захистів
   2747                        offset = add_data - BIT_MA_CONTROL_BASE;
   2748                        first_address_of_word_for_function_3_or_4 = M_ADDRESS_CONTROL_BASE;
   2749                      }
   2750          #if (BIT_MA_CURRENT_AF_LAST + 1) < BIT_MA_GENERAL_AF_BASE
   2751                      else if((add_data >= BIT_MA_CURRENT_AF_BASE) && ((add_data + number - 1) <= BIT_MA_CURRENT_AF_LAST))
   2752                      {
   2753                        //Стан активних функцій
   2754                        offset = add_data - BIT_MA_CURRENT_AF_BASE;
   2755                        first_address_of_word_for_function_3_or_4 = M_ADDRESS_FIRST_CURRENT_AF;
   2756                      }
   2757                      else if((add_data >= BIT_MA_GENERAL_AF_BASE) && ((add_data + number - 1) <= BIT_MA_GENERAL_AF_LAST))
   2758                      {
   2759                        //Стан активних функцій
   2760                        offset = add_data - BIT_MA_GENERAL_AF_BASE;
   2761                        first_address_of_word_for_function_3_or_4 = M_ADDRESS_FIRST_GENERAL_AF;
   2762                      }
   2763          #else
   2764                      else if((add_data >= BIT_MA_CURRENT_AF_BASE) && ((add_data + number - 1) <= BIT_MA_GENERAL_AF_LAST))
   2765                      {
   2766                        //Стан активних функцій
   2767                        offset = add_data - BIT_MA_CURRENT_AF_BASE;
   2768                        first_address_of_word_for_function_3_or_4 = M_ADDRESS_FIRST_CURRENT_AF;
   2769                      }
   2770          #endif
   2771                      
   2772                      //Визначаємо, з якого слова треба розпочати зчитування цілими словами
   2773                      first_address_of_word_for_function_3_or_4 += (offset >> 4);
   2774                      //Визначаємо ще остачу від ділення
   2775                      offset &= 0xf;
   2776                      
   2777                      number_word_read = number_word_transmit;
   2778                      /*
   2779                      Визначаємо скільки слів треба прочитати (підрахунок ведемо по кількості біт 
   2780                      і з перший біт приймаємо начперший біт слова, яке буде прочитане функцією Get_data
   2781                      і  додаємо зміщення, бо може перший біт не буде потрібний а будуть потрібні біти наступної величини)
   2782                      Тут ми визначаємо скільки слів треба буде прочитати функцією Get_data щоб отримати дані для передачі
   2783                      */
   2784                      if ((offset + number) > (number_word_transmit << 4)) number_word_read++; //Бо буде захоплене ще наступне слово за рахунок зміщення
   2785                      
   2786                      //Зчитуємо спочатку цілі слова
   2787                      unsigned int i=0;
   2788                      while((i < number_word_read) && ((error = Get_data((transmited_buffer + 3 + 2*i), (first_address_of_word_for_function_3_or_4 + i), type_interface))==0)) i++;
   2789                    }
   2790                    else
   2791                    {
   2792                      if ((number == 0) || (number_byte_transmit >= (255-5))) error = ERROR_ILLEGAL_DATA_VALUE;
   2793                      else error = ERROR_ILLEGAL_DATA_ADDRESS;
   2794                    }
   2795                    
   2796                    //Формуємо байти відповіді і саму відповідь у протоколі MODBUS-RTU
   2797                    if (error == 0)
   2798                    {
   2799                      unsigned short int temp_value_for_offset, current_word, next_word;
   2800                      unsigned int maska = 0, max_bit_in_high_byte = (number & 0x7);
   2801                      
   2802                      for(unsigned int i = 0; i < number_word_transmit; i++)
   2803                      {
   2804                        //Функція Get_data помістила байти в порядку MSB-LSB і т.д
   2805                        current_word = (*(transmited_buffer + 3 + 2*i) << 8) | (*(transmited_buffer + 3 + 2*i + 1));
   2806                        if ((i + 1) < number_word_read) next_word = (*(transmited_buffer + 3 + 2*(i + 1)) << 8) | (*(transmited_buffer + 3 + 2*(i + 1) + 1));
   2807                        else next_word = 0;
   2808                        
   2809                        //Визначаємо , які біти з наступного слова треба перемістити в дане слово і зміщуємо їх у старші розряди
   2810                        temp_value_for_offset = next_word << (16 - offset);
   2811                        
   2812                        //Формуємо слово із врахуванням зміщення
   2813                        temp_value_for_offset |= (current_word >> offset);
   2814                       
   2815                        if((2*i    ) < number_byte_transmit)
   2816                          *(transmited_buffer + 3 + 2*i    ) = temp_value_for_offset        & 0xff;
   2817                        if((2*i + 1) < number_byte_transmit)
   2818                          *(transmited_buffer + 3 + 2*i + 1) = (temp_value_for_offset >> 8) & 0xff;
   2819                      }
   2820                      
   2821                      //В останньому байті треба зайві біти змасувати
   2822                      if (max_bit_in_high_byte != 0)
   2823                      {
   2824                        for(unsigned int i = 0; i < max_bit_in_high_byte; i++) maska = (maska << 1) + 0x1;
   2825                        *(transmited_buffer + 3 + number_byte_transmit - 1 ) &= maska;
   2826                      }
   2827                        
   2828                      CRC_sum = 0xffff;
   2829                      for (int index = 0; index < ((int)(number_byte_transmit + 3)); index++) CRC_sum = AddCRC(*(transmited_buffer + index),CRC_sum);
   2830                      *(transmited_buffer + 3 + number_byte_transmit + 0) = CRC_sum & 0xff;
   2831                      *(transmited_buffer + 3 + number_byte_transmit + 1) = CRC_sum >> 8;
   2832          
   2833                      *transmited_count = number_byte_transmit + 5;
   2834                      if(type_interface == USB_RECUEST) data_usb_transmiting = true;
   2835                      else if(type_interface ==  RS485_RECUEST) start_transmint_data_via_RS_485(*transmited_count);
   2836                    }
   2837                    else
   2838                    {
   2839                      //Відповідаємо про помилку
   2840                      Error_modbus((unsigned char)settings_fix.address, *(received_buffer+1), error, transmited_buffer);
   2841                      *transmited_count = 5;
   2842                      if(type_interface == USB_RECUEST) data_usb_transmiting = true;
   2843                      else if(type_interface ==  RS485_RECUEST) start_transmint_data_via_RS_485(*transmited_count);
   2844                    }
   2845                    
   2846                    break;
   2847                  }//Кінець для обробки функцій 1 і 2
   2848                case 3:
   2849                case 4:
   2850                  {
   2851                    unsigned int add_data, number;
   2852                    number   = (*(received_buffer + 4))<<8 | (*(received_buffer + 5));
   2853                    
   2854                    if ((number == 0) || (number > ((255-5)>>1)))
   2855                    {
   2856                      //Помилка запиту кількості регістрів
   2857                      error = ERROR_ILLEGAL_DATA_VALUE;
   2858                    }
   2859                    else
   2860                    {
   2861                      *transmited_buffer = *(received_buffer);
   2862                      *(transmited_buffer + 1) = *(received_buffer + 1) ;
   2863                      *(transmited_buffer + 2) = number*2;
   2864          
   2865                      add_data = (*(received_buffer + 2))<<8 | (*(received_buffer + 3));
   2866          
   2867                      if (
   2868                          /*((add_data >= M_ADDRESS_FIRST_MEASUREMENTS_1 ) && (add_data <= M_ADDRESS_LAST_MEASUREMENTS_1)) ||
   2869                          ((add_data >= M_ADDRESS_FIRST_MEASUREMENTS_2 ) && (add_data <= M_ADDRESS_LAST_MEASUREMENTS_2)) ||*/
   2870                          ((add_data >= M_ADDRESS_FIRST_TMP_MEASURMENTS) && (add_data <  M_ADDRESS_LAST_TMP_MEASURMENTS))  
   2871                         )
   2872                      {
   2873                        //Копіюємо вимірювання
   2874                        semaphore_measure_values_low1 = 1;
   2875                        for (unsigned int i = 0; i < NUMBER_ANALOG_CANALES; i++ ) 
   2876                        {
   2877                          measurement_low[i] = measurement_middle[i];
   2878                        }
   2879                        semaphore_measure_values_low1 = 0;
   2880                      }
   2881          
   2882                      unsigned int i=0;
   2883                      while((i<number) && ((error = Get_data((transmited_buffer+3+2*i),(add_data+i), type_interface))==0))i++;
   2884                    }
   2885          
   2886                    if (error == 0)
   2887                    {
   2888                      CRC_sum = 0xffff;
   2889                      for (int index = 0; index < ((int)(3+2*number)); index++) CRC_sum = AddCRC(*(transmited_buffer + index),CRC_sum);
   2890                      *(transmited_buffer+3+2*number) = CRC_sum & 0xff;
   2891                      *(transmited_buffer+4+2*number) = CRC_sum >> 8;
   2892          
   2893                      *transmited_count = 5+2*number;
   2894                      if(type_interface == USB_RECUEST) data_usb_transmiting = true;
   2895                      else if(type_interface ==  RS485_RECUEST) start_transmint_data_via_RS_485(*transmited_count);
   2896                    }
   2897                    else
   2898                    {
   2899                      Error_modbus((unsigned char)settings_fix.address, *(received_buffer+1), error, transmited_buffer);
   2900                      *transmited_count = 5;
   2901                      if(type_interface == USB_RECUEST) data_usb_transmiting = true;
   2902                      else if(type_interface ==  RS485_RECUEST) start_transmint_data_via_RS_485(*transmited_count);
   2903                    }
   2904          
   2905                    break;
   2906                  }//Кінець для обробки функцій 3 і 4
   2907                case 5:
   2908                  {
   2909                    unsigned int add_data;
   2910                    unsigned short int value, temp_value = 0;
   2911                    unsigned int offset;
   2912                    
   2913                    add_data = (*(received_buffer + 2))<<8 | (*(received_buffer + 3));
   2914                    value    = (*(received_buffer + 4))<<8 | (*(received_buffer + 5));
   2915          
   2916                    if ((type_interface != USB_RECUEST) && (type_interface != RS485_RECUEST))
   2917                    {
   2918                      //Теоретично такого бути не мало б ніколи
   2919                      error = ERROR_SLAVE_DEVICE_FAILURE;
   2920                    }
   2921                    else if(
   2922                            (
   2923                             ((value == 0 ) || (value == 0xff00)) && 
   2924                             (
   2925                              ((add_data >= BIT_MA_CONTROL_BASE) && (add_data <= BIT_MA_CONTROL_LAST)) || /*Настройки захистів*/
   2926                              (add_data == BIT_MA_NEW_SETTINGS_SET) /*Команда активації внесених змін у налаштування приладу через інтерфейс*/ 
   2927                             )
   2928                            )   
   2929                            || 
   2930                            (
   2931                             (value == 0xff00) 
   2932                             &&
   2933                             (
   2934                              (add_data == BIT_MA_RESET_GENERAL_AF) /*Скидання загальних функцій*/
   2935                              ||
   2936                              (  
   2937                               ((add_data >= BIT_MA_INPUT_DF1) && (add_data <= BIT_MA_INPUT_DF8)) || /*Входи Определяємих функцій*/
   2938                               ((add_data >= BIT_MA_DT1_SET  ) && (add_data <= BIT_MA_DT4_RESET))/* ||*/ /*Оприділювальні триггери*/
   2939          //                     ( add_data == BIT_MA_RESET_LEDS                                  ) || /*Очищення індикації*/
   2940          //                     ( add_data == BIT_MA_RESET_RELES                                 )    /*Скидання реле*/
   2941                              )
   2942                             )   
   2943                            )
   2944                           )
   2945                    {
   2946                      unsigned int first_address_of_word_for_function_3_or_4;
   2947                     
   2948                      //Визначаємо початковий базовий регістр і зміщення відношно його першого біту
   2949                      if ((add_data >= BIT_MA_CONTROL_BASE) && (add_data <= BIT_MA_CONTROL_LAST))
   2950                      {
   2951                        //Стан функцій захистів
   2952                        offset = add_data - BIT_MA_CONTROL_BASE;
   2953                        first_address_of_word_for_function_3_or_4 = M_ADDRESS_CONTROL_BASE;
   2954                      }
   2955                      else if ((add_data >= BIT_MA_INPUT_DF1) && (add_data <= BIT_MA_INPUT_DF8))
   2956                      {
   2957                        offset = add_data - BIT_MA_DF_BASE;
   2958                        first_address_of_word_for_function_3_or_4 = M_ADDRESS_DF;
   2959                      }
   2960                      else if (( add_data >= BIT_MA_DT1_SET) && (add_data <= BIT_MA_DT4_RESET ))
   2961                      {
   2962                        offset = add_data - BIT_MA_DT_BASE;
   2963                        first_address_of_word_for_function_3_or_4 = M_ADDRESS_DT;
   2964                      }
   2965                      else if(
   2966          //                    (add_data == BIT_MA_RESET_LEDS            ) || /*Очищення індикації*/
   2967          //                    (add_data == BIT_MA_RESET_RELES           ) || /*Скидання реле*/
   2968                              (add_data == BIT_MA_RESET_GENERAL_AF      ) || /*Скидання загальних функцій*/
   2969                              (add_data == BIT_MA_NEW_SETTINGS_SET      )    /*Команда активації внесених змін у налаштування приладу через інтерфейс*/
   2970                             )
   2971                      {
   2972                        offset = add_data - BIT_MA_COMMAND_BASE;
   2973                        first_address_of_word_for_function_3_or_4 = M_ADDRESS_COMMAND_BASE;
   2974                      }
   2975                      
   2976                      //Виконуємо дію
   2977                      if (first_address_of_word_for_function_3_or_4 == M_ADDRESS_CONTROL_BASE)
   2978                      {
   2979                        //Іде намагання змінити настройку захисту
   2980                        
   2981                        ///Перевіряємо, чи пароль доступу знятий і чи система меню не є у стані редагування
   2982                        if (
   2983                            (
   2984                             ((type_interface == USB_RECUEST  ) && (password_set_USB   == 0)) ||
   2985                             ((type_interface == RS485_RECUEST) && (password_set_RS485 == 0))
   2986                            )
   2987                            &&  
   2988                            (current_state_menu2.edition == ED_VIEWING)
   2989                           )
   2990                        {
   2991                          //Запис проводимо тільки тоді, коли пароль знятий і система меню не у режимі редагування, або іде команда управління
   2992                      
   2993                          //Визначаємо, з якого слова треба розпочати зчитування цілими словами
   2994                          first_address_of_word_for_function_3_or_4 += (offset >> 4);
   2995          
   2996                          //Визначаємо ще скільки розрядів залишається у наступному слові
   2997                          offset &= 0xf;
   2998                      
   2999                          //Зчитуємо спочатку ціле слово
   3000                          unsigned char temp_value_in_char[2];
   3001                          error = Get_data(temp_value_in_char, first_address_of_word_for_function_3_or_4, type_interface);
   3002                          temp_value = temp_value_in_char[1];
   3003                          temp_value |= temp_value_in_char[0] << 8;
   3004          
   3005                          if (error == 0)
   3006                          {
   3007                            //Якщо регістр прочитався вдало, то формуємо байт, який треба записати 
   3008                            if (value == 0xff00) temp_value |=   (1 << offset); //Встановити
   3009                            else if (value == 0x0)temp_value &= ~(1 << offset); //Зняти
   3010                            else error = ERROR_ILLEGAL_DATA_VALUE;              //Невизначена ситуація, яка теоретично ніколи не мала настати бо попередньо ми цю умову вже провіряли і цю ситуацію відкинули як недопустиму
   3011          
   3012                            if (error == 0)
   3013                            {
   3014                              error = Set_data(temp_value,first_address_of_word_for_function_3_or_4, SET_DATA_IMMEDITATE, /*false,*/ type_interface);
   3015                              if (error == 0)
   3016                              {
   3017                                //Дійсно відбулася зміна настройки
   3018          //                      _SET_BIT(active_functions, RANG_SETTINGS_CHANGED);
   3019                                restart_timeout_idle_new_settings = true;
   3020                                type_of_settings_changed_from_interface |= (1 << SETTINGS_DATA_CHANGED_BIT);
   3021                              }
   3022                            }
   3023                          }
   3024                        }
   3025                        else
   3026                        {
   3027                          if (current_state_menu2.edition != ED_VIEWING) error = ERROR_SLAVE_DEVICE_BUSY;
   3028                          else error = ERROR_ILLEGAL_DATA_ADDRESS;
   3029                        }
   3030                      }
   3031                      else if (
   3032                               (
   3033                                ((first_address_of_word_for_function_3_or_4 == M_ADDRESS_DF) || (first_address_of_word_for_function_3_or_4 == M_ADDRESS_DT))
   3034                                &&
   3035                                (
   3036                                 ((type_interface == USB_RECUEST  ) && (password_set_USB   == 0)) ||
   3037                                 ((type_interface == RS485_RECUEST) && (password_set_RS485 == 0))
   3038                                ) 
   3039                               )
   3040                               ||  
   3041                               (
   3042                                (first_address_of_word_for_function_3_or_4 == M_ADDRESS_COMMAND_BASE)
   3043                                &&
   3044                                (
   3045                                 (add_data != BIT_MA_NEW_SETTINGS_SET) ||
   3046                                 ((type_interface == USB_RECUEST  ) && (password_set_USB   == 0)) ||
   3047                                 ((type_interface == RS485_RECUEST) && (password_set_RS485 == 0))
   3048                                )   
   3049                               )   
   3050                              )
   3051                      {
   3052                        //Іде подача активації команди
   3053                        
   3054                        /*
   3055                        Тут ми використовуємо каонстанти активації функцій з допомогою ф-кнопок, бо механізм обробки однаковий що активацшя
   3056                        функції з ф-кнопкт, що активація функції з інтерейсу
   3057                        */
   3058                        /*     if  (add_data == BIT_MA_RESET_LEDS                       ) activation_function_from_interface |= 1 << RANG_TU_RESET_LEDS;
   3059                        else if  (add_data == BIT_MA_RESET_RELES                      ) activation_function_from_interface |= 1 << RANG_TU_RESET_RELES;
   3060                        else*/ if  (add_data == BIT_MA_RESET_GENERAL_AF) 
   3061                        {
   3062                          //Скидання загальних функцій 
   3063                          reset_trigger_function_from_interface |= (1 << type_interface);
   3064                        }
   3065                        else if  (add_data == BIT_MA_NEW_SETTINGS_SET) 
   3066                        {
   3067                          /*Команда активації внесених змін у налаштування приладу через інтерфейс*/ 
   3068                          if (value == 0xff00)
   3069                          {
   3070                            //Активація внесекних змін
   3071                            unsigned int source = MENU_PARAMS_FIX_CHANGES;
   3072                            if(type_interface == USB_RECUEST) source = USB_PARAMS_FIX_CHANGES;
   3073                            else if(type_interface ==  RS485_RECUEST) source = RS485_PARAMS_FIX_CHANGES;
   3074          
   3075                            unsigned int result = set_config_and_settings(1, source);
   3076                            if (result != 0)
   3077                            {
   3078                              error = ERROR_SLAVE_DEVICE_FAILURE;
   3079                              if (result == 2)
   3080                              {
   3081                                //Повідомляємо про критичну помилку
   3082                                current_state_menu2.edition = ED_ERROR;
   3083                              }
   3084                            }
   3085                          }
   3086                          else
   3087                          {
   3088                            //Відміна внесекних змін
   3089                            unsigned int result = set_config_and_settings(0, NO_MATTER_PARAMS_FIX_CHANGES);
   3090                            if (result != 0)
   3091                            {
   3092                              //Повідомляємо про критичну помилку
   3093                              current_state_menu2.edition = ED_ERROR;
   3094                            }
   3095                          }
   3096                          config_settings_modified = 0;
   3097                          type_of_settings_changed_from_interface = 0;
   3098          //                _CLEAR_BIT(active_functions, RANG_SETTINGS_CHANGED);
   3099                        }
   3100                      }
   3101                      else
   3102                      {
   3103                        //Теоретично сюди програма ніколи не малаб зайти
   3104                        
   3105                        error = ERROR_ILLEGAL_DATA_ADDRESS;
   3106                      }
   3107                    }
   3108                    else
   3109                    {
   3110                      if (
   3111                          ((value != 0x0) && (value != 0xff00)) ||
   3112                          (
   3113                           (value == 0x0) 
   3114                           &&
   3115                           (add_data != BIT_MA_NEW_SETTINGS_SET) /*Команда активації внесених змін у налаштування приладу через інтерфейс*/
   3116                           &&
   3117                           (  
   3118                            (add_data == BIT_MA_RESET_GENERAL_AF) /*Скидання загальних функцій*/
   3119                            ||
   3120                            (  
   3121                             ((add_data >= BIT_MA_INPUT_DF1) && (add_data <= BIT_MA_INPUT_DF8)) || /*Входи Определяємих функцій*/
   3122                             ((add_data >= BIT_MA_DT1_SET ) && (add_data <= BIT_MA_DT4_RESET ))/* ||*/ /*Оприд. триґери*/
   3123          //                   ( add_data == BIT_MA_RESET_LEDS                                  ) || /*Очищення індикації*/
   3124          //                   ( add_data == BIT_MA_RESET_RELES                                 )    /*Скидання реле*/
   3125                            )
   3126                           )   
   3127                          )
   3128                         ) error = ERROR_ILLEGAL_DATA_VALUE;
   3129                      else error = ERROR_ILLEGAL_DATA_ADDRESS;
   3130                    }
   3131                    
   3132                    if (error == 0)
   3133                    {
   3134                      for (int index = 0; index < 8; index++) *(transmited_buffer + index ) = *(received_buffer + index );
   3135                      *transmited_count = 8;
   3136                      if(type_interface == USB_RECUEST) data_usb_transmiting = true;
   3137                      else if(type_interface ==  RS485_RECUEST) start_transmint_data_via_RS_485(*transmited_count);
   3138                    }
   3139                    else
   3140                    {
   3141                      //Відповідаємо про помилку
   3142                      Error_modbus((unsigned char)settings_fix.address, *(received_buffer+1), error, transmited_buffer);
   3143                      *transmited_count = 5;
   3144                      if(type_interface == USB_RECUEST) data_usb_transmiting = true;
   3145                      else if(type_interface ==  RS485_RECUEST) start_transmint_data_via_RS_485(*transmited_count);
   3146                    }
   3147                    break;
   3148                  }//Кінець для обробки функції 5        
   3149                case 6:
   3150                  {
   3151                    unsigned int add_data;
   3152                    unsigned short int data;
   3153                    unsigned int changing_ustuvannja = 0;
   3154          
   3155                    add_data = (*(received_buffer + 2))<<8 | (*(received_buffer + 3));
   3156                    data     = (*(received_buffer + 4))<<8 | (*(received_buffer + 5));
   3157          
   3158                    if ((type_interface != USB_RECUEST) && (type_interface != RS485_RECUEST))
   3159                    {
   3160                      //Теоретично такого бути не мало б ніколи
   3161                      error = ERROR_SLAVE_DEVICE_FAILURE;
   3162                    }
   3163                    else if (
   3164                             (global_requect != 0) && /*запит по адресі BROADCAST_ADDRESS_MODBUS_RTU протоколу Modbus-RTU*/
   3165                             (
   3166                              !(
   3167                                ((add_data >= M_ADDRESS_FIRST_TIME_AND_DATA) && (add_data <= M_ADDRESS_LAST_TIME_AND_DATA))
   3168                               )
   3169                             )     
   3170                            )
   3171                    {
   3172                      /*
   3173                      По глобалній адресі можна змінювати тільки час і дату
   3174                      */
   3175                      error = ERROR_BROADCAST_ADDRESS;
   3176                    }
   3177                    else if (
   3178                             (current_state_menu2.edition == ED_VIEWING                     ) ||
   3179                             (add_data                    == MA_CURRENT_NUMBER_RECORD_PR_ERR)  
   3180                            )
   3181                    {
   3182                      /*****/
   3183                      //Перевірка на необхідність паролю доступу для запису
   3184                      /*****/
   3185                      if (
   3186                          (
   3187                           ((type_interface == USB_RECUEST  ) && (password_set_USB   != 0)) ||
   3188                           ((type_interface == RS485_RECUEST) && (password_set_RS485 != 0))
   3189                          )
   3190                          &&
   3191                          (
   3192                           ((add_data >= M_ADDRESS_FIRST_SETPOINTS_PART1                 ) && (add_data <= M_ADDRESS_LAST_SETPOINTS_PART1                 )                                       ) || /*уставки і витримки*/
   3193                           ((add_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G1)) && (add_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G1))                                       ) || /*уставки і витримки першої групи*/
   3194          //                 ((add_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G2)) && (add_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G2))                                       ) || /*уставки і витримки другої групи*/
   3195          //                 ((add_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G3)) && (add_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G3))                                       ) || /*уставки і витримки третьої групи*/
   3196          //                 ((add_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G4)) && (add_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G4))                                       ) || /*уставки і витримки четвертої групи*/
   3197                           ((add_data >= M_ADDRESS_CONTROL_BASE                          ) && (add_data <= M_ADDRESS_CONTROL_LAST                         )                                       ) || /*налаштування захистів*/
   3198                           ((add_data >= M_ADDRESS_FIRST_SETPOINTS_CONTINUE              ) && (add_data <= M_ADDRESS_LAST_SETPOINTS_CONTINUE              ) && (add_data != MA_PASSWORD_INTERFACE)) || /*уставки і витримки (продовження) крім паролю доступу*/
   3199                           ((add_data >= M_ADDRESS_FIRST_TIME_AND_DATA                   ) && (add_data <= M_ADDRESS_LAST_TIME_AND_DATA                   )                                       ) || /*час*/
   3200                           ((add_data >= M_ADDRESS_FIRST_SETPOINTS_RANG                  ) && (add_data <= M_ADDRESS_LAST_SETPOINTS_RANG                  )                                       ) || /*ранжування*/
   3201                            (add_data == MA_CLEAR_NUMBER_RECORD_PR_ERR                   )                                                                                                          || /*очищення реєстратора програмних подій*/        
   3202                            (add_data == MA_DEFAULT_SETTINGS                             )                                                                                                          || /*встановлення мінімальної конфігурації*/        
   3203                            (add_data == MA_TEST_WATCHDOGS                               )                                                                                                        /*||*//*тестування внутрішнього і зовнішнього watchdog*/        
   3204          //                  (add_data == MA_NUMBER_ITERATION_EL                          )                                                                                                             /*встановленнямаксимальної кількості ітераційдля розширеної логіки*/        
   3205                          )   
   3206                         )
   3207                      {
   3208                        //Не можна зараз записати цей регістр, бо треба спочатку зняти пароль доступу
   3209                        error = ERROR_ILLEGAL_DATA_ADDRESS;
   3210                      }
   3211                      else
   3212                      {
   3213                        unsigned int changed_ustuvannja_tmp; /*буде проініціалізована пізніше*/
   3214                        
   3215                        if ((add_data >= M_ADDRESS_FIRST_TIME_AND_DATA) && (add_data <= M_ADDRESS_LAST_TIME_AND_DATA))
   3216                        {
   3217                          if (_CHECK_SET_BIT(control_i2c_taskes, TASK_START_WRITE_RTC_BIT) == 0)
   3218                          {  
   3219                            //Іде намагання встановити новий час-дату, тому робимо копію часу
   3220                            unsigned char *label_to_time_array, *label_calibration;
   3221                            if (copying_time == 0)
   3222                            {
   3223                              label_to_time_array = time;
   3224                              label_calibration = &calibration;
   3225                            }
   3226                            else
   3227                            {
   3228                              label_to_time_array = time_copy;
   3229                              label_calibration = &calibration_copy;
   3230                            }
   3231                            for(unsigned int index = 0; index < 7; index++) time_edit[index] = *(label_to_time_array + index);
   3232                            calibration_edit = *label_calibration;
   3233                          }
   3234                          else
   3235                          {
   3236                            /*
   3237                            Ще виконалася попередня команда запису часу, а нова може змінити 
   3238                            попередньо введені дані при копіюванні текучого часу (щоб мати цілісний масив часу)
   3239                            Тому ця операція є тимчасово недоступною
   3240                            */
   3241                            error = ERROR_SLAVE_DEVICE_BUSY;
   3242                          }
   3243                        }
   3244                        else if(
   3245                                ((add_data >= M_ADDRESS_FIRST_SETPOINTS_RANG   ) && (add_data <= M_ADDRESS_LAST_SETPOINTS_RANG   )) /*ранжування*/
   3246                               ) 
   3247                        {
   3248                          //Враховуючи той факт, що зараз буде відбуватися ранжування, то скидаємо вказівник на редагуюче поле в 0
   3249                          point_to_edited_rang = NULL;
   3250          //                for (unsigned int i = 0; i < N_BIG; i++)
   3251          //                {
   3252          //                  clear_array_rang[i] = 0;
   3253          //                  set_array_rang[i]   = 0;
   3254          //                }
   3255                        }
   3256                        else if((add_data >= MA_ADDRESS_FIRST_USTUVANNJA) && (add_data <= MA_ADDRESS_LAST_USTUVANNJA))/*амплітудні і фазні юстуючі коефіцієнти*/ 
   3257                        {
   3258                          //Помічаємо ненульовим значенням, що йде намагання змінити юстуючі коефіцієнти
   3259                          changing_ustuvannja = 0xff;
   3260                          
   3261                          /*
   3262                          Робимо копію змінної changed_ustuvannja, щоб при неуспішній спробі
   3263                          зміни коефіцієнтів юстування відновити попереднє значення. Оскільки з верхнбого рівня
   3264                          можлива зміна CHANGED_ETAP_ENDED -> CHANGED_ETAP_NONE,
   3265                          то я думаю нічого "надзвичайного" не станеться, якщо ми попередній 
   3266                          стан зафіксуємо CHANGED_ETAP_ENDED, потім більш пріоритетна задача
   3267                          вимірювальної системи зкопіює коефіцієнти юстування і скине змінну в 
   3268                          CHANGED_ETAP_NONE, а потім відбудеться неуспішна спроба
   3269                          ввести нову зміну у в масив юстування, що приведе до того, що ми з цієї фунціїї
   3270                          відновимо попереднє значення (до зміни вимірювальною системою) CHANGED_ETAP_ENDED.
   3271                          Як я думаю, наслідком цього може бути тільки повторне копіювання масиву юстування.
   3272                          */
   3273                          changed_ustuvannja_tmp = changed_ustuvannja;
   3274          
   3275                          //Помічаємо, що зараз, можоиво, елемент юстування буде змінений
   3276                          changed_ustuvannja = CHANGED_ETAP_EXECUTION;
   3277                        }
   3278          
   3279                        if (error == 0)
   3280                        {
   3281                          error = Set_data(data,add_data, SET_DATA_IMMEDITATE, /*false,*/ type_interface);
   3282                          if (error != 0)
   3283                          {
   3284                            if (changing_ustuvannja != 0)
   3285                            {
   3286                              /*
   3287                              Зміна коефіцієнітів юстування не відбулася, тому відновлюємо попереднє значення
   3288                              змінної changed_ustuvannja, яке було до її встановлення у значення
   3289                              CHANGED_ETAP_EXECUTION
   3290                              */
   3291                              changed_ustuvannja = changed_ustuvannja_tmp;
   3292                            }
   3293                          }
   3294                        }
   3295                      }
   3296                    }
   3297                    else error = ERROR_SLAVE_DEVICE_BUSY;
   3298                       
   3299                    /*****/
   3300                    //Якщо є спроба встановити час, то робимо його найперше, бо тут ще буде перевірка на достовірні дані
   3301                    /*****/
   3302                    if ((error == 0) && (add_data >= M_ADDRESS_FIRST_TIME_AND_DATA) && (add_data <= M_ADDRESS_LAST_TIME_AND_DATA))
   3303                    {
   3304                      //Встановлення нового часу-дати
   3305          
   3306                      //Перевіряємо достовірність даних
   3307                      if (check_data_for_data_time_menu() == 1)
   3308                      {
   3309                        //Дані достовірні
   3310                        //Виставляємо повідомлення запису часу в RTC
   3311                        //При цьому виставляємо біт блокування негайного запуску операції, щоб засинхронізуватися з роботою вимірювальної системи
   3312                        _SET_BIT(control_i2c_taskes, TASK_START_WRITE_RTC_BIT);
   3313                        _SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);
   3314                      }
   3315                      else error = ERROR_ILLEGAL_DATA_VALUE;
   3316                    }
   3317                    /*****/
   3318                     
   3319                    if(error == 0)
   3320                    {
   3321                      if  (global_requect == 0)
   3322                      {
   3323                        for (int index = 0; index < 8; index++) *(transmited_buffer + index ) = *(received_buffer + index );
   3324                        *transmited_count = 8;
   3325                        if(type_interface == USB_RECUEST) data_usb_transmiting = true;
   3326                        else if(type_interface ==  RS485_RECUEST) start_transmint_data_via_RS_485(*transmited_count);
   3327                      }
   3328                      else
   3329                      {
   3330                        if(type_interface == RS485_RECUEST)
   3331                        {
   3332                          //Перезапускаємо моніторинг лінії RS-485
   3333                          restart_monitoring_RS485();
   3334                        }
   3335                      }
   3336                      
   3337                      /*****/
   3338                      //При необхідності записуємо інформацію у EEPROM
   3339                      /*****/
   3340                      if (
   3341                          ((add_data >= M_ADDRESS_FIRST_SETPOINTS_PART1                 ) && (add_data <= M_ADDRESS_LAST_SETPOINTS_PART1                 )) ||
   3342                          ((add_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G1)) && (add_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G1))) ||
   3343          //                ((add_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G2)) && (add_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G2))) ||
   3344          //                ((add_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G3)) && (add_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G3))) ||
   3345          //                ((add_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G4)) && (add_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G4))) ||
   3346                          ((add_data >= M_ADDRESS_CONTROL_BASE                          ) && (add_data <= M_ADDRESS_CONTROL_LAST                         )) ||
   3347                          ((add_data >= M_ADDRESS_FIRST_SETPOINTS_CONTINUE              ) && (add_data <= M_ADDRESS_LAST_SETPOINTS_CONTINUE              )) ||
   3348                          ((add_data >= M_ADDRESS_FIRST_SETPOINTS_RANG                  ) && (add_data <= M_ADDRESS_LAST_SETPOINTS_RANG                  ))/*||*/
   3349          //                (add_data == MA_NUMBER_ITERATION_EL)
   3350                         )
   3351                      {
   3352                        //Записуємо інформацю, яка відноситься до настройок
   3353                        
   3354                        if (
   3355                            ((add_data == MA_PASSWORD_INTERFACE) && (password_changed == true))
   3356                            ||  
   3357                            ( add_data != MA_PASSWORD_INTERFACE) /*встановлення всіх інших настрройок чи ранжування (за виключенням паролю доступу)*/ 
   3358                           )   
   3359                        {
   3360                          //Виключаємо той випадок, коли робилося зняття паролю доступу
   3361                             
   3362                          //Дійсно відбулася зміна настройки
   3363          //                _SET_BIT(active_functions, RANG_SETTINGS_CHANGED);
   3364                          restart_timeout_idle_new_settings = true;
   3365                              
   3366                          if (
   3367                              ((add_data >= M_ADDRESS_FIRST_SETPOINTS_RANG   ) && (add_data <= M_ADDRESS_LAST_SETPOINTS_RANG   ))
   3368                             )
   3369                          {
   3370                            if  ( !((add_data >= M_ADDRESS_FIRST_USER_REGISTER   ) && (add_data <= M_ADDRESS_LAST_USER_REGISTER)) )
   3371                            {
   3372                              //Не іде ранжування регістрів користувача
   3373                              
   3374                              if (point_to_edited_rang != NULL)
   3375                              {
   3376                                //Останні введення ще не введені у цільовий масив піля операції ранжування
   3377                                //(бо остання операція завжди вводиться вкінці операції запису)
   3378                                set_previous_ranguvannja();
   3379                              }
   3380                              
   3381                              //Записуємо інформацю по ранжуванню
   3382                              type_of_settings_changed_from_interface |= (1 << RANGUVANNJA_DATA_CHANGED_BIT);
   3383                            }
   3384                            else
   3385                            {
   3386                              //Іде ранжування регістрів користувача
   3387                              type_of_settings_changed_from_interface |= (1 << USER_REGISTRY_CHANGED_BIT);
   3388                            }
   3389                          }
   3390                          else
   3391                          {
   3392                            if (add_data == MA_PASSWORD_INTERFACE) 
   3393                            {
   3394                              //Записуємо значення нового парголю доступу
   3395                              type_of_settings_changed_from_interface |= (1 << NEW_PASSWORD_SET_BIT);
   3396                            }
   3397                            else
   3398                            {
   3399                              //Записуємо інформацю настройках (крім ранжування)
   3400                              type_of_settings_changed_from_interface |= (1 << SETTINGS_DATA_CHANGED_BIT);
   3401                            }
   3402                          }
   3403                        }
   3404                      }
   3405                      else if (
   3406                               ((add_data >= MA_ADDRESS_FIRST_USTUVANNJA) && (add_data <= MA_ADDRESS_LAST_USTUVANNJA)) ||
   3407                               ( add_data == MA_SET_SERIAL_NUMBER)  
   3408                              )
   3409                      {
   3410                        if (
   3411                            ((add_data >= MA_ADDRESS_FIRST_USTUVANNJA) && (add_data <= MA_ADDRESS_LAST_USTUVANNJA))
   3412                           )   
   3413                        {
   3414                          //Помічаємо, що вимірювальною системою треба забрати нові коефіцієнти юстування
   3415                          changed_ustuvannja = CHANGED_ETAP_ENDED;
   3416                        }
   3417                        //Запис юстуючик коефіцієнтів
   3418                        _SET_BIT(control_i2c_taskes, TASK_START_WRITE_USTUVANNJA_EEPROM_BIT);
   3419                      }
   3420                      else if (add_data == MA_DEFAULT_SETTINGS)
   3421                      {
   3422                             
   3423                        //Дійсно відбулася зміна настройки
   3424          //              _SET_BIT(active_functions, RANG_SETTINGS_CHANGED);
   3425                        restart_timeout_idle_new_settings = true;
   3426                        
   3427                        //Відбулася успішна команда скидання у мінімальну конфігурацію
   3428                        type_of_settings_changed_from_interface = (1 << DEFAULT_SETTINGS_SET_BIT);
   3429                      }
   3430                      /*****/
   3431                    }
   3432                    else 
   3433                    {
   3434                      if (global_requect == 0)
   3435                      {
   3436                        Error_modbus((unsigned char)settings_fix.address, *(received_buffer+1), error, transmited_buffer);
   3437                        *transmited_count = 5;
   3438                        if(type_interface == USB_RECUEST) data_usb_transmiting = true;
   3439                        else if(type_interface ==  RS485_RECUEST) start_transmint_data_via_RS_485(*transmited_count);
   3440                      }
   3441                      else
   3442                      {
   3443                        if(type_interface == RS485_RECUEST)
   3444                        {
   3445                          //Перезапускаємо моніторинг лінії RS-485
   3446                          restart_monitoring_RS485();
   3447                        }
   3448                      }
   3449                    }
   3450                    break;
   3451                  }//Кінець для обробки функції 6
   3452                case 15:
   3453                  {
   3454                    unsigned int add_data, number, reinit_settings = 0;       
   3455                  
   3456                    add_data = (*(received_buffer + 2))<<8 | (*(received_buffer + 3));
   3457                    number   = (*(received_buffer + 4))<<8 | (*(received_buffer + 5));
   3458          
   3459                    unsigned int number_bytes = number >> 3;
   3460                    if ((number_bytes << 3) != number) number_bytes++;
   3461                  
   3462                    if ((type_interface != USB_RECUEST) && (type_interface != RS485_RECUEST))
   3463                    {
   3464                      //Теоретично такого бути не мало б ніколи
   3465                      error = ERROR_SLAVE_DEVICE_FAILURE;
   3466                    }
   3467                    else if ((number < 1) || (number > 0x7B0) || (number_bytes != *(received_buffer + 6)))
   3468                        error= ERROR_ILLEGAL_DATA_VALUE;
   3469                    else if (
   3470                             ((add_data >= BIT_MA_CONTROL_BASE) && ((add_data + number - 1) <= BIT_MA_CONTROL_LAST))
   3471                             ||
   3472                             ((add_data >= BIT_MA_RESET_GENERAL_AF) && ((add_data + number - 1) <= BIT_MA_RESET_GENERAL_AF))
   3473                             ||
   3474                             ((add_data >= BIT_MA_NEW_SETTINGS_SET) && ((add_data + number - 1) <= BIT_MA_NEW_SETTINGS_SET))
   3475                             ||
   3476                             (
   3477                              ((add_data >= BIT_MA_INPUT_DF1          ) && ((add_data + number - 1) <= BIT_MA_INPUT_DF8             )) || 
   3478                              ((add_data >= BIT_MA_DT1_SET            ) && ((add_data + number - 1) <= BIT_MA_DT4_RESET             ))/* ||
   3479                              ((add_data >= BIT_MA_RESET_LEDS         ) && ((add_data + number - 1) <= BIT_MA_RESET_GENERAL_AF      ))*/
   3480                             ) 
   3481                            )
   3482                    {
   3483                      unsigned int first_address_of_word_for_function_3_or_4;
   3484                      unsigned int offset;
   3485          
   3486                      if((add_data >= BIT_MA_CONTROL_BASE) && (add_data <= BIT_MA_CONTROL_LAST))
   3487                      {
   3488                        //Стан функцій захистів
   3489                        offset = add_data - BIT_MA_CONTROL_BASE;
   3490                        first_address_of_word_for_function_3_or_4 = M_ADDRESS_CONTROL_BASE;
   3491                      }
   3492                      else if((add_data >= BIT_MA_INPUT_DF1) && (add_data <= BIT_MA_INPUT_DF8)) /*Определяємі функції*/
   3493                      {
   3494                        offset = add_data - BIT_MA_DF_BASE;
   3495                        first_address_of_word_for_function_3_or_4 = M_ADDRESS_DF;
   3496                      }
   3497                      else if((add_data >= BIT_MA_DT1_SET) && (add_data <= BIT_MA_DT4_RESET)) /*Опред. триґери*/
   3498                      {
   3499                        offset = add_data - BIT_MA_DT_BASE;
   3500                        first_address_of_word_for_function_3_or_4 = M_ADDRESS_DT;
   3501                      }
   3502                      else if(
   3503                              /*((add_data >= BIT_MA_RESET_LEDS                       ) && (add_data <= BIT_MA_RESET_GENERAL_AF      ))*/(add_data == BIT_MA_RESET_GENERAL_AF) ||
   3504                              ( add_data == BIT_MA_NEW_SETTINGS_SET                 )
   3505                             )
   3506                      {
   3507                        //Команди загальні
   3508                        offset = add_data - BIT_MA_COMMAND_BASE;
   3509                        first_address_of_word_for_function_3_or_4 = M_ADDRESS_COMMAND_BASE;
   3510                      }
   3511          
   3512                      if (
   3513                          (first_address_of_word_for_function_3_or_4 >= M_ADDRESS_CONTROL_BASE) &&
   3514                          (first_address_of_word_for_function_3_or_4 <= M_ADDRESS_CONTROL_LAST)
   3515                         )
   3516                      {
   3517                        //Іде намагання запису інформації, яка відноситься до настройок
   3518                        
   3519                        //Перевіряємо чи можемо ми ці операції зараз виконати
   3520                        if (
   3521                            (
   3522                             ((type_interface == USB_RECUEST  ) && (password_set_USB   == 0)) ||
   3523                             ((type_interface == RS485_RECUEST) && (password_set_RS485 == 0))
   3524                            )   
   3525                            &&
   3526                            (current_state_menu2.edition == ED_VIEWING)
   3527                           )
   3528                        {
   3529                          //Операція запису є доступною
   3530          
   3531                          //Робимо копію таблиці настройок
   3532          //                edition_settings = current_settings_interfaces;
   3533          
   3534                          //Визначаємо початкову адресу читання/запису цілими словами
   3535                          first_address_of_word_for_function_3_or_4 += (offset >> 4);
   3536                          //Визначаємо зміщення у наступному слові
   3537                          offset &= 0xf;
   3538                          
   3539                          //Зчитуємо спочатку ціле слово
   3540                          unsigned short int temp_value;
   3541                          unsigned char temp_value_in_char[2];
   3542                          error = Get_data(temp_value_in_char,first_address_of_word_for_function_3_or_4, type_interface);
   3543                          temp_value = temp_value_in_char[1];
   3544                          temp_value |= temp_value_in_char[0] << 8;
   3545          
   3546                          unsigned int index_byte = 0, index_bit, index_of_bit_in_target_word;
   3547                          unsigned char temp_data;
   3548                          unsigned int i = 0;
   3549                          index_of_bit_in_target_word = offset;//початковий номер біту
   3550                          while ((i < number) && (error == 0))
   3551                          {
   3552                            //Оскільки сама інформація які значення встановлювати, а які скинути упаковано побайтно, то і нам треба рухатися по-байтно
   3553                            index_bit  = i &  0x7; //Виділення трьох молодших біт аналогічне виділенню остачі при діленні цього числа на 8 - тобто це визначення номеру біту з вхідного "масиву" значень
   3554                      
   3555                            //Новий байт зчитуємо тільки коли номер біту є 0, бо інакше байт вже є зчитаним
   3556                            if (index_bit == 0)
   3557                            {
   3558                              index_byte = i >> 3  ; //Зміщення на три розряди вправо аналогічне виділенню цілої частини при діленні цього числа на 8 - тобто це визначення номеру байту з вхідного "масиву" значень
   3559                              temp_data = *(received_buffer + 7 + index_byte);
   3560                            }
   3561                      
   3562                            //Виділяємо значення біту, яке треба встановити
   3563                            unsigned int value_of_bit;
   3564                            value_of_bit = ((temp_data << (7 - index_bit)) >> 7) & 0x1;
   3565                      
   3566                            //У слові, яке змінюємо спочатку скидаємо у нуль біт, який ми змінюємо
   3567                            //Це робимо тільки для тих сигналів, які можна скидати - для всіх інших цю операцію не виконуємо!!!
   3568                            temp_value &= (unsigned short)(~(1 << index_of_bit_in_target_word));
   3569          
   3570                            //Тепер виставляємо потрібний біт
   3571                            temp_value |=  (value_of_bit << index_of_bit_in_target_word);
   3572            
   3573                            //Збільшуємо номер біту
   3574                            i++;
   3575                            //Вираховуємо номер наступного біту, який треба змінити
   3576                            index_of_bit_in_target_word = ((offset + i) & 0xf);//Виділення чотиох молодших біт аналогічне виділенню остачі при діленні цього числа на 16 - тобто це визначення номеру біту з вихідному слові
   3577                      
   3578                            /*
   3579                            У разі, якщо індекс наступного цілового біту є нуль або якщо ми записали останній біт,
   3580                            то значить треба спочатку записати модернізоване слово і якщо є ще біти для запису, то зчитати нове слово
   3581                            */
   3582                            if ((index_of_bit_in_target_word == 0) || (i == number))
   3583                            {
   3584                              //Записуємо відповідне нове значення
   3585                              error = Set_data(temp_value, first_address_of_word_for_function_3_or_4, SET_DATA_INTO_EDIT_TABLE, /*(i < number),*/ type_interface); /*тут і вже збільшений на одиницю, тому перевірка здійснюється (i) з (number)*/
   3586                              if (error == 0)
   3587                              {
   3588                                if (reinit_settings == 0) reinit_settings = 1; //Помічаємо, що треба буде виконати запис нових настройок у EEPROM
   3589          
   3590                                //Якщо є ще біти для запису, то зчитати нове слово
   3591                                if (i < number)
   3592                                {
   3593                                  //Збільшуємо адресу слова у якому мають проводитися зміни
   3594                                  first_address_of_word_for_function_3_or_4++;
   3595            
   3596                                  //Зчитуємо ціле слово
   3597                                  error = Get_data(temp_value_in_char,first_address_of_word_for_function_3_or_4, type_interface);
   3598                                  temp_value = temp_value_in_char[1];
   3599                                  temp_value |= temp_value_in_char[0] << 8;
   3600                                }
   3601                              }
   3602                            }
   3603                          }
   3604                        }
   3605                        else
   3606                        {
   3607                          if (current_state_menu2.edition != ED_VIEWING) error = ERROR_SLAVE_DEVICE_BUSY;
   3608                          else error = ERROR_ILLEGAL_DATA_ADDRESS;
   3609                        }
   3610                      }
   3611                      else if (
   3612                               (
   3613                                (
   3614                                 (first_address_of_word_for_function_3_or_4 == M_ADDRESS_DF) || 
   3615                                 (first_address_of_word_for_function_3_or_4 == M_ADDRESS_DT)
   3616                                )
   3617                                &&
   3618                                (
   3619                                 ((type_interface == USB_RECUEST  ) && (password_set_USB   == 0)) ||
   3620                                 ((type_interface == RS485_RECUEST) && (password_set_RS485 == 0))
   3621                                ) 
   3622                               )
   3623                               ||  
   3624                               (
   3625                                (first_address_of_word_for_function_3_or_4 == M_ADDRESS_COMMAND_BASE)
   3626                                &&
   3627                                (
   3628                                 (!((add_data >= BIT_MA_NEW_SETTINGS_SET) && ((add_data + number - 1) <= BIT_MA_NEW_SETTINGS_SET))) ||
   3629                                 ((type_interface == USB_RECUEST  ) && (password_set_USB   == 0)) ||
   3630                                 ((type_interface == RS485_RECUEST) && (password_set_RS485 == 0))
   3631                                )   
   3632                               )   
   3633                              )
   3634                      {
   3635                        //Іде подача активації команд телеуправління
   3636                        
   3637                        /*
   3638                        Тут ми використовуємо константи активації функцій з допомогою ф-кнопок, бо механізм обробки однаковий що активацшя
   3639                        функції з ф-кнопкт, що активація функції з інтерейсу
   3640                        */
   3641                        
   3642                        unsigned int index_byte = 0, index_bit, number_activated_function;
   3643                        unsigned char temp_data;
   3644                        unsigned int i = 0;
   3645                        unsigned int activation_function_from_interface_tmp = 0, reset_trigger_functions = 0;
   3646                        int set_new_settings = -1;
   3647                        while ((i < number) && (error == 0))
   3648                        {
   3649                          //Оскільки сама інформація які значення встановлювати упакована побайтно, то і нам треба рухатися по-байтно
   3650                          index_bit  = i &  0x7; //Виділення трьох молодших біт аналогічне виділенню остачі при діленні цього числа на 8 - тобто це визначення номеру біту з вхідного "масиву" значень
   3651                      
   3652                          //Новий байт зчитуємо тільки коли номер біту є 0, бо інакше байт вже є зчитаним
   3653                          if (index_bit == 0)
   3654                          {
   3655                            index_byte = i >> 3  ; //Зміщення на три розряди вправо аналогічне виділенню цілої частини при діленні цього числа на 8 - тобто це визначення номеру байту з вхідного "масиву" значень
   3656                            temp_data = *(received_buffer + 7 + index_byte);
   3657                          }
   3658                      
   3659                          //Виділяємо значення біту, яке треба встановити
   3660                          unsigned int value_of_bit;
   3661                          value_of_bit = ((temp_data << (7 - index_bit)) >> 7) & 0x1;
   3662                          
   3663                          number_activated_function = add_data + i;
   3664                          if (value_of_bit != 0)
   3665                          {
   3666                            /*     if  (number_activated_function == BIT_MA_RESET_LEDS                       )
   3667                              activation_function_from_interface_tmp |= 1 << RANG_TU_RESET_LEDS;
   3668                            else if  (number_activated_function == BIT_MA_RESET_RELES                      )
   3669                              activation_function_from_interface_tmp |= 1 << RANG_TU_RESET_RELES;
   3670                            else*/ if  (number_activated_function == BIT_MA_RESET_GENERAL_AF                 ) 
   3671                            {
   3672                              //Скидання загальних функцій 
   3673                              reset_trigger_functions = 0xff; /*ненульове значення означає, що треба скинути тригерні функції*/
   3674                            }
   3675                            else if  (number_activated_function == BIT_MA_NEW_SETTINGS_SET) 
   3676                            {
   3677                              /*Команда активації внесених змін у налаштування приладу через інтерфейс*/ 
   3678                              set_new_settings = true;
   3679                            }
   3680                            else 
   3681                            {
   3682                              //Теоретично сюди програма ніколи не малаб зайти
   3683                              error = ERROR_ILLEGAL_DATA_ADDRESS;
   3684                            }
   3685                          }
   3686                          else
   3687                          {
   3688                            if  (number_activated_function == BIT_MA_NEW_SETTINGS_SET) 
   3689                            {
   3690                              /*Команда деактивації внесених змін у налаштування приладу через інтерфейс*/ 
   3691                              set_new_settings = false;
   3692                            }
   3693                          }
   3694                          
   3695                          i++;
   3696                        }
   3697          
   3698                        if (error == 0)
   3699                        {
   3700                          if (activation_function_from_interface_tmp != 0)
   3701                          {
   3702                            activation_function_from_interface |= activation_function_from_interface_tmp;
   3703                          }
   3704                          if (reset_trigger_functions != 0)
   3705                          {
   3706                            reset_trigger_function_from_interface |= (1 << type_interface);
   3707                          }
   3708                          if (set_new_settings != -1)
   3709                          {
   3710                            if (set_new_settings == true)
   3711                            {
   3712                              //Активація внесекних змін
   3713                              unsigned int source = MENU_PARAMS_FIX_CHANGES;
   3714                              if(type_interface == USB_RECUEST) source = USB_PARAMS_FIX_CHANGES;
   3715                              else if(type_interface ==  RS485_RECUEST) source = RS485_PARAMS_FIX_CHANGES;
   3716          
   3717                              unsigned int result = set_config_and_settings(1, source);
   3718                              if (result != 0)
   3719                              {
   3720                                error = ERROR_SLAVE_DEVICE_FAILURE;
   3721                                if (result == 2)
   3722                                {
   3723                                  //Повідомляємо про критичну помилку
   3724                                  current_state_menu2.edition = ED_ERROR;
   3725                                }
   3726                              }
   3727                            }
   3728                            else
   3729                            {
   3730                              //Відміна внесекних змін
   3731                              unsigned int result = set_config_and_settings(0, NO_MATTER_PARAMS_FIX_CHANGES);
   3732                              if (result != 0)
   3733                              {
   3734                                //Повідомляємо про критичну помилку
   3735                                current_state_menu2.edition = ED_ERROR;
   3736                              }
   3737                            }
   3738                            config_settings_modified = 0;
   3739                            type_of_settings_changed_from_interface = 0;
   3740          //                  _CLEAR_BIT(active_functions, RANG_SETTINGS_CHANGED);
   3741                          }
   3742                        }
   3743                      }
   3744                      else
   3745                      {
   3746                        //Теоретично сюди програма ніколи не малаб зайти
   3747                        error = ERROR_ILLEGAL_DATA_ADDRESS;
   3748                      }
   3749                    }
   3750                    else
   3751                      error = ERROR_ILLEGAL_DATA_ADDRESS;
   3752          
   3753                    if (error == 0)
   3754                    {
   3755                      CRC_sum = 0xffff;
   3756                      for (int index = 0; index < 6; index++)
   3757                      {
   3758                        *(transmited_buffer + index ) = *(received_buffer + index );
   3759                        CRC_sum = AddCRC(*(transmited_buffer + index),CRC_sum);
   3760                      }
   3761                      *(transmited_buffer + 6) = CRC_sum & 0xff;
   3762                      *(transmited_buffer + 7) = CRC_sum >> 8;
   3763          
   3764                      *transmited_count = 8;
   3765                      if(type_interface == USB_RECUEST) data_usb_transmiting = true;
   3766                      else if(type_interface ==  RS485_RECUEST) start_transmint_data_via_RS_485(*transmited_count);
   3767                    
   3768                      if (reinit_settings != 0)
   3769                      {
   3770                        //Копіюємо введені зміни у робочу структуру
   3771          //              current_settings_interfaces = edition_settings;
   3772          
   3773                        //Відбулася зміна настройки
   3774          //              _SET_BIT(active_functions, RANG_SETTINGS_CHANGED);
   3775                        restart_timeout_idle_new_settings = true;
   3776                        type_of_settings_changed_from_interface |= (1 << SETTINGS_DATA_CHANGED_BIT);
   3777                      }
   3778                    }
   3779                    else
   3780                    {
   3781                      //Відповідаємо про помилку
   3782                      Error_modbus((unsigned char)settings_fix.address, *(received_buffer+1), error, transmited_buffer);
   3783                      *transmited_count = 5;
   3784                      if(type_interface == USB_RECUEST) data_usb_transmiting = true;
   3785                      else if(type_interface ==  RS485_RECUEST) start_transmint_data_via_RS_485(*transmited_count);
   3786                    }
   3787                    break;
   3788                  }//Кінець для обробки функції 15        
   3789                case 16:
   3790                  {
   3791                    unsigned int add_data, number;
   3792                    unsigned int reinit_ustuvannja = 0, reinit_settings = 0, set_new_password = 0, reinit_ranguvannja = 0, set_min_param = 0;
   3793                    unsigned int reinit_user_register = 0;
   3794                    unsigned int setting_new_rtc = 0;
   3795                      
   3796                    add_data = (*(received_buffer + 2))<<8 | (*(received_buffer + 3));
   3797                    number   = (*(received_buffer + 4))<<8 | (*(received_buffer + 5));
   3798          
   3799                    //Робимо встановлений/невстановлений пароль доступу
   3800                    unsigned int before_password_set;
   3801                    if (type_interface == USB_RECUEST) before_password_set = password_set_USB;
   3802                    else if (type_interface == RS485_RECUEST) before_password_set = password_set_RS485;
   3803                    else error= ERROR_SLAVE_DEVICE_FAILURE;
   3804          
   3805                    if ((number < 1) || (number > 0x7B) || ((*(received_buffer + 6)) != ( number <<1)))
   3806                      error= ERROR_ILLEGAL_DATA_VALUE;
   3807                    else if (
   3808                             (global_requect != 0) && /*запит по адресі BROADCAST_ADDRESS_MODBUS_RTU протоколу Modbus-RTU*/
   3809                             (
   3810                              !(
   3811                                ((add_data >= M_ADDRESS_FIRST_TIME_AND_DATA) && ((add_data + number - 1) <= M_ADDRESS_LAST_TIME_AND_DATA))
   3812                               )
   3813                             )     
   3814                            )
   3815                    {
   3816                      /*
   3817                      По глобалній адресі можна змінювати тільки час і дату
   3818                      */
   3819                      error = ERROR_BROADCAST_ADDRESS;
   3820                    }
   3821          
   3822                    //Починаємо вводити прийняті дані
   3823                    unsigned int i = 0;
   3824                    while((i < number) && (error == 0 ))
   3825                    {
   3826                      unsigned short int data = (*(received_buffer+7+2*i))<<8 | (*(received_buffer+8+2*i));
   3827          
   3828                      if (
   3829                          (current_state_menu2.edition == ED_VIEWING                     ) ||
   3830                          (add_data                    == MA_CURRENT_NUMBER_RECORD_PR_ERR)  
   3831                         )
   3832                      {
   3833                        /*****/
   3834                        //Перевірка на необхідність паролю доступу для запису
   3835                        /*****/
   3836                        if (
   3837                            ((add_data >= M_ADDRESS_FIRST_SETPOINTS_PART1                 ) && (add_data <= M_ADDRESS_LAST_SETPOINTS_PART1                 )) || /*уставки і витримки*/
   3838                            ((add_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G1)) && (add_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G1))) || /*уставки і витримки першої групи*/
   3839          //                  ((add_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G2)) && (add_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G2))) || /*уставки і витримки другої групи*/
   3840          //                  ((add_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G3)) && (add_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G3))) || /*уставки і витримки третьої групи*/
   3841          //                  ((add_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G4)) && (add_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G4))) || /*уставки і витримки четвертої групи*/
   3842                            ((add_data >= M_ADDRESS_CONTROL_BASE                          ) && (add_data <= M_ADDRESS_CONTROL_LAST                         )) || /*налаштування захистів*/
   3843                            ((add_data >= M_ADDRESS_FIRST_SETPOINTS_CONTINUE              ) && (add_data <= M_ADDRESS_LAST_SETPOINTS_CONTINUE              )) || /*уставки і витримки (продовження) крім паролю доступу*/
   3844                            ((add_data >= M_ADDRESS_FIRST_TIME_AND_DATA                   ) && (add_data <= M_ADDRESS_LAST_TIME_AND_DATA                   )) || /*час*/
   3845                            ((add_data >= M_ADDRESS_FIRST_SETPOINTS_RANG                  ) && (add_data <= M_ADDRESS_LAST_SETPOINTS_RANG                  )) || /*ранжування*/
   3846                             (add_data == MA_CLEAR_NUMBER_RECORD_PR_ERR                   )                                                                   || /*очищення реєстратора програмних подій*/
   3847                             (add_data == MA_DEFAULT_SETTINGS                             )                                                                   || /*встановлення мінімальної конфігурації*/        
   3848                             (add_data == MA_TEST_WATCHDOGS                               )                                                                 /*||*/ /*тестування внутрішнього і зовнішнього watchdog*/        
   3849          //                   (add_data == MA_NUMBER_ITERATION_EL                          )                                                                      /*встановленнямаксимальної кількості ітераційдля розширеної логіки*/        
   3850                           )
   3851                        {
   3852                          if (
   3853                              (add_data != MA_PASSWORD_INTERFACE) &&
   3854                              (
   3855                               ((type_interface == USB_RECUEST  ) && (password_set_USB != 0  )) ||
   3856                               ((type_interface == RS485_RECUEST) && (password_set_RS485 != 0))
   3857                              )   
   3858                             )
   3859                          {
   3860                            //Не можна зараз записати цей регістр, бо треба спочатку зняти пароль доступу
   3861                            error = ERROR_ILLEGAL_DATA_ADDRESS;
   3862                          }
   3863                          else if (
   3864                                   (number != 1)
   3865                                   &&
   3866                                   (  
   3867                                    (add_data == MA_CLEAR_NUMBER_RECORD_PR_ERR) || /*очищення реєстратора програмних подій*/
   3868                                    (add_data == MA_DEFAULT_SETTINGS          ) || /*встановлення мінімальної конфігурації*/        
   3869                                    (add_data == MA_TEST_WATCHDOGS            )    /*тестування внутрішнього і зовнішнього watchdog*/        
   3870                                   )   
   3871                                  )
   3872                          {
   3873                            //Ці команди можуть подаватися одночано тільки на один регістр - інакше повідомляємо про помилку
   3874                            error = ERROR_ILLEGAL_DATA_ADDRESS;
   3875                          }
   3876                          else
   3877                          {
   3878                            //Можна записувати нові дані для настройок
   3879                          
   3880                            //Якщо у даній трансакції ми перший раз вводим нове значення по натройках (крім часу) то робимо копію структури настройок
   3881                            if (
   3882                                (
   3883                                 (reinit_settings      == 0) && 
   3884                                 (reinit_ranguvannja   == 0) &&
   3885                                 (reinit_user_register == 0)
   3886                                )/*ще не проводився запис настройкок, тому ще не зроблена копія таблиці настройок*/ 
   3887                                &&  
   3888                                ( 
   3889                                 !(
   3890                                   (add_data >= M_ADDRESS_FIRST_TIME_AND_DATA) && 
   3891                                   (add_data <= M_ADDRESS_LAST_TIME_AND_DATA ) 
   3892                                  )/*копію таблиці настройок не треба робити коли ми встановлюємо час*/
   3893                                )    
   3894                               )
   3895                            {
   3896                              //Робимо копію таблиці настройок
   3897          //                    edition_settings  = current_settings_interfaces;
   3898          
   3899                              //Враховуючи той факт, що може зараз відбуватися ранжування, то скидаємо вказівник на редагуюче поле в 0
   3900                              point_to_edited_rang = NULL;
   3901          //                    for (unsigned int j = 0; j < N_BIG; j++)
   3902          //                    {
   3903          //                      clear_array_rang[j] = 0;
   3904          //                      set_array_rang[j]   = 0;
   3905          //                    }
   3906                            }
   3907          
   3908                            if (
   3909                                (add_data >= M_ADDRESS_FIRST_TIME_AND_DATA) &&
   3910                                (add_data <= M_ADDRESS_LAST_TIME_AND_DATA ) &&
   3911                                (setting_new_rtc == 0                     )
   3912                               )
   3913                            {
   3914                              if (_CHECK_SET_BIT(control_i2c_taskes, TASK_START_WRITE_RTC_BIT) == 0)
   3915                              {  
   3916                                //Помічаємо, що треба ввести новий системний час
   3917                                setting_new_rtc = 1;
   3918          
   3919                                //Робимо копію часу, дати і калібровки на яку ми накладемо зміни, перевіримо їх на достовірність і потім, якщо провірка пройде вдало, то запишемо їх у мікросхему RTC
   3920                                unsigned char *label_to_time_array, *label_calibration;
   3921                                if (copying_time == 0)
   3922                                {
   3923                                  label_to_time_array = time;
   3924                                  label_calibration = &calibration;
   3925                                }
   3926                                else
   3927                                {
   3928                                  label_to_time_array = time_copy;
   3929                                  label_calibration = &calibration_copy;
   3930                                }
   3931                                for(unsigned int index = 0; index < 7; index++) time_edit[index] = *(label_to_time_array + index);
   3932                                calibration_edit = *label_calibration;
   3933                              }
   3934                              else
   3935                              {
   3936                                /*
   3937                                Ще виконалася попередня команда запису часу, а нова може змінити 
   3938                                попередньо введені дані при копіюванні текучого часу (щоб мати цілісний масив часу)
   3939                                Тому ця операція є тимчасово недоступною
   3940                                */
   3941                                error = ERROR_SLAVE_DEVICE_BUSY;
   3942                              }
   3943                            }
   3944                          
   3945                            if (error == 0)
   3946                            {
   3947                              //Вводимо нові значення через тимчасову структуру
   3948                              error = Set_data(data, add_data, SET_DATA_INTO_EDIT_TABLE, /*((i + 1) < number),*/ type_interface); /*тут і ще не збільшений на одиницю, тому перевірка здійснюється(i + 1) з (number)*/
   3949                            }
   3950                          }
   3951                        }
   3952                        else
   3953                        {
   3954                          //Ці дані не потребують перевірки на пароль
   3955                        
   3956                          if (
   3957                              (add_data >= MA_ADDRESS_FIRST_USTUVANNJA) && (add_data <= MA_ADDRESS_LAST_USTUVANNJA) || /*юстуючі амплітудні і фазові коефіцієнти*/
   3958                              (add_data == MA_SET_SERIAL_NUMBER                                                       )    /*серійний номер*/  
   3959                             )
   3960                          {
   3961                            //Вводяться нові дані для юстування або серійний номер
   3962                        
   3963                            //Якщо у даній трансакції ми перший раз вводим нове значення по юстуванню то робимо копію масиву юстування
   3964                            if (reinit_ustuvannja == 0)
   3965                            {
   3966                              for(unsigned int k = 0; k < NUMBER_ANALOG_CANALES; k++) 
   3967                              {
   3968                                edit_ustuvannja[k] = ustuvannja[k];
   3969                              }
   3970                              edit_serial_number_dev = serial_number_dev;
   3971                            }
   3972                          }
   3973                          //Вводимо нові значення через тимчасовий масив (хоч настравді він використовується тільки для юстування, а для всіх інших регістрів все одно який другий параметра викликаємої функції)
   3974                          error = Set_data(data, add_data, SET_DATA_INTO_EDIT_TABLE, /*((i + 1) < number),*/ type_interface); /*тут і ще не збільшений на одиницю, тому перевірка здійснюється(i + 1) з (number)*/
   3975                        }
   3976                      }
   3977                      else error = ERROR_SLAVE_DEVICE_BUSY;
   3978                        
   3979                      if (error == 0)
   3980                      {
   3981                        if (
   3982                            ((add_data >= M_ADDRESS_FIRST_SETPOINTS_PART1                 ) && (add_data <= M_ADDRESS_LAST_SETPOINTS_PART1                 )) ||
   3983                            ((add_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G1)) && (add_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G1))) ||
   3984          //                  ((add_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G2)) && (add_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G2))) ||
   3985          //                  ((add_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G3)) && (add_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G3))) ||
   3986          //                  ((add_data >= (M_ADDRESS_FIRST_SETPOINTS_ZACHYSTIV + SHIFT_G4)) && (add_data <= (M_ADDRESS_LAST_SETPOINTS_ZACHYSTIV + SHIFT_G4))) ||
   3987                            ((add_data >= M_ADDRESS_CONTROL_BASE                          ) && (add_data <= M_ADDRESS_CONTROL_LAST                         )) ||  
   3988                            ((add_data >= M_ADDRESS_FIRST_SETPOINTS_CONTINUE              ) && (add_data <= M_ADDRESS_LAST_SETPOINTS_CONTINUE              )) ||
   3989                            ((add_data >= M_ADDRESS_FIRST_SETPOINTS_RANG                  ) && (add_data <= M_ADDRESS_LAST_SETPOINTS_RANG                  ))/* ||*/
   3990          //                  (add_data == MA_NUMBER_ITERATION_EL)
   3991                           )
   3992                        {
   3993                          //Записуємо інформацю, яка відноситься до настройок
   3994                          
   3995                          if (
   3996                              ((add_data == MA_PASSWORD_INTERFACE) && (password_changed == true))
   3997                              ||  
   3998                              ( add_data != MA_PASSWORD_INTERFACE) /*встановлення всіх інших настрройок чи ранжування (за виключенням паролю доступу)*/ 
   3999                             )   
   4000                          {
   4001                            //Виключаємо той випадок, коли робилося зняття паролю доступу
   4002                            //Записуємо настройки
   4003                            if (
   4004                                ((add_data >= M_ADDRESS_FIRST_SETPOINTS_RANG   ) && (add_data <= M_ADDRESS_LAST_SETPOINTS_RANG   ))
   4005                               )
   4006                            {
   4007                              if  ( !((add_data >= M_ADDRESS_FIRST_USER_REGISTER) && (add_data <= M_ADDRESS_LAST_USER_REGISTER)) )
   4008                              {
   4009                                //Не іде ранжування регістрів користувача
   4010                                
   4011                                //Помічаємо, що треба записати інформацю по ранжуванню
   4012                                reinit_ranguvannja = 1;
   4013                              }
   4014                              else
   4015                              {
   4016                                //Іде ранжування регістрів користувача
   4017                                reinit_user_register = 1;
   4018                              }
   4019                            }
   4020                            else
   4021                            {
   4022                              //Помічаємо, що треба записати інформацю по настройках (крім ранжування)
   4023                              if (add_data == MA_PASSWORD_INTERFACE)
   4024                              {
   4025                                set_new_password = 1;
   4026                              }
   4027                              else
   4028                              {
   4029                                reinit_settings = 1;
   4030                              }
   4031                            }
   4032                          }
   4033                        }
   4034                        else if (
   4035                                 ((add_data >= MA_ADDRESS_FIRST_USTUVANNJA ) && (add_data <= MA_ADDRESS_LAST_USTUVANNJA)) ||
   4036                                 ( add_data == MA_SET_SERIAL_NUMBER)  
   4037                                )
   4038                        {
   4039                          //Помічаємо, що треба записати юстуючі коефіцієнти
   4040                          reinit_ustuvannja = 1;
   4041                        }
   4042                        else if (add_data == MA_DEFAULT_SETTINGS)
   4043                        {
   4044                          //Скидання у мінімальну конфігурацію
   4045                          set_min_param = 1;
   4046                        }
   4047                      }
   4048                      add_data++;
   4049                      i++;
   4050                    } 
   4051          
   4052                    /*****/
   4053                    //Якщо була спроба встановити час-дату, то виконуємо запис у мікросхему RTC, бо тут ще буде перевірка на достовірні дані
   4054                    /*****/
   4055                    if ((error == 0) && (setting_new_rtc != 0))
   4056                    {
   4057                      //Встановлення нового часу-дати
   4058          
   4059                      //Перевіряємо достовірність даних
   4060                      if (check_data_for_data_time_menu() == 1)
   4061                      {
   4062                        //Дані достовірні
   4063                        //Виставляємо повідомлення запису часу в RTC
   4064                        //При цьому виставляємо біт блокування негайного запуску операції, щоб засинхронізуватися з роботою вимірювальної системи
   4065                        _SET_BIT(control_i2c_taskes, TASK_START_WRITE_RTC_BIT);
   4066                        _SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);
   4067                      }
   4068                      else error = ERROR_ILLEGAL_DATA_VALUE;
   4069                    }
   4070                    /*****/
   4071          
   4072                    /*****/
   4073                    if ((error == 0) && (reinit_ranguvannja != 0))
   4074                    {
   4075                      //Перевіряємо чи останні зміни вже ввежені у цільовий масив
   4076                      if(point_to_edited_rang != NULL)
   4077                      {
   4078                        //Останні введення ще не введені у цільовий масив піля операції ранжування
   4079                        //(бо остання операція завжди вводиться вкінці операції запису)
   4080                        set_previous_ranguvannja();
   4081                      }
   4082                    }
   4083                    /*****/
   4084                    
   4085                    if (error == 0)
   4086                    {
   4087                      if  (global_requect == 0)
   4088                      {
   4089                        CRC_sum = 0xffff;
   4090                        for (int index = 0; index < 6; index++)
   4091                        {
   4092                          *(transmited_buffer + index ) = *(received_buffer + index );
   4093                          CRC_sum = AddCRC(*(transmited_buffer + index),CRC_sum);
   4094                        }
   4095                        *(transmited_buffer +6 ) = CRC_sum & 0xff;
   4096                        *(transmited_buffer +7 ) = CRC_sum >> 8;
   4097          
   4098                        *transmited_count = 8;
   4099                        if(type_interface == USB_RECUEST) data_usb_transmiting = true;
   4100                        else if(type_interface ==  RS485_RECUEST) start_transmint_data_via_RS_485(*transmited_count);
   4101                      }
   4102                      else
   4103                      {
   4104                        if(type_interface == RS485_RECUEST)
   4105                        {
   4106                          //Перезапускаємо моніторинг лінії RS-485
   4107                          restart_monitoring_RS485();
   4108                        }
   4109                      }
   4110          
   4111                      /*****/
   4112                      //При необхідності записуємо інформацію у EEPROM
   4113                      /*****/
   4114                      if (reinit_ustuvannja != 0)
   4115                      {
   4116                        //Попередньо вводимо нові значення у дію
   4117                        //Помічаємо, що елементи масиву юстування зараз будуть змінені
   4118                        changed_ustuvannja = CHANGED_ETAP_EXECUTION;
   4119                        for(unsigned int k = 0; k < NUMBER_ANALOG_CANALES; k++) 
   4120                        {
   4121                          ustuvannja[k] = edit_ustuvannja[k];
   4122                        }
   4123                        //Помічаємо, що елементи масиву юстування змінені і готові для передавання у вимірювальну систему
   4124                        changed_ustuvannja = CHANGED_ETAP_ENDED;
   4125                        serial_number_dev = edit_serial_number_dev;
   4126          
   4127                        _SET_BIT(control_i2c_taskes, TASK_START_WRITE_USTUVANNJA_EEPROM_BIT);
   4128                      }
   4129                      if (
   4130                          (reinit_settings      != 0) ||
   4131                          (set_new_password     != 0) ||  
   4132                          (reinit_ranguvannja   != 0) ||
   4133                          (set_min_param        != 0) ||
   4134                          (reinit_user_register != 0)  
   4135                         )
   4136                      {
   4137                        //Копіюємо введені зміни у робочу структуру
   4138          //              current_settings_interfaces = edition_settings;
   4139          
   4140                        //Відбулася зміна настройки
   4141          //              _SET_BIT(active_functions, RANG_SETTINGS_CHANGED);
   4142                        restart_timeout_idle_new_settings = true;
   4143                        
   4144                        if (set_min_param != 0)
   4145                        {
   4146                          type_of_settings_changed_from_interface = (1 << DEFAULT_SETTINGS_SET_BIT);
   4147                        }
   4148                        
   4149                        if (reinit_settings != 0)
   4150                        {
   4151                          type_of_settings_changed_from_interface |= (1 << SETTINGS_DATA_CHANGED_BIT);
   4152                        }
   4153          
   4154                        if (set_new_password != 0)
   4155                        {
   4156                          type_of_settings_changed_from_interface |= (1 << NEW_PASSWORD_SET_BIT);
   4157                        }
   4158          
   4159                        if (reinit_ranguvannja != 0)
   4160                        {
   4161                          type_of_settings_changed_from_interface |= (1 << RANGUVANNJA_DATA_CHANGED_BIT);
   4162                        }
   4163          
   4164                        if (reinit_user_register != 0)
   4165                        {
   4166                          type_of_settings_changed_from_interface |= (1 << USER_REGISTRY_CHANGED_BIT);
   4167                        }
   4168                      }
   4169                      /*****/
   4170                    }
   4171                    else 
   4172                    {
   4173                      //Встановлюємо попередній стан доступу по поралю
   4174                      if (type_interface == USB_RECUEST) password_set_USB = before_password_set;
   4175                      else if (type_interface == RS485_RECUEST) password_set_RS485 = before_password_set;
   4176          
   4177                      if  (global_requect == 0)
   4178                      {
   4179                        Error_modbus((unsigned char)settings_fix.address, *(received_buffer+1), error, transmited_buffer);
   4180                        *transmited_count = 5;
   4181                        if(type_interface == USB_RECUEST) data_usb_transmiting = true;
   4182                        else if(type_interface ==  RS485_RECUEST) start_transmint_data_via_RS_485(*transmited_count);
   4183                      }
   4184                      else
   4185                      {
   4186                        if(type_interface == RS485_RECUEST)
   4187                        {
   4188                          //Перезапускаємо моніторинг лінії RS-485
   4189                          restart_monitoring_RS485();
   4190                        }
   4191                      }
   4192                    }
   4193          
   4194                    break;
   4195                  }//Кінець для обробки функції 16
   4196          //      case 20:
   4197          //        {
   4198          //          *transmited_buffer = *(received_buffer);
   4199          //          *(transmited_buffer + 1) = *(received_buffer + 1) ;
   4200          //
   4201          //          unsigned int number_requests = *(received_buffer + 2);
   4202          //          unsigned int total_number_answer = 0;
   4203          //
   4204          //          if ((number_requests >= 0x7) && (number_requests <= 0xF5))
   4205          //          {
   4206          //            unsigned int i = 0; 
   4207          //            while ((i < number_requests) && ((error = Get_data_file((received_buffer + 3 + i), (transmited_buffer + 3 + total_number_answer), &total_number_answer, type_interface)) == 0))
   4208          //            {
   4209          //              i += 7;
   4210          //            }
   4211          //         
   4212          //          }
   4213          //          else error = ERROR_ILLEGAL_DATA_VALUE;
   4214          //        
   4215          //          if (error == 0)
   4216          //          {
   4217          //            *(transmited_buffer + 2) = total_number_answer ;
   4218          //
   4219          //            CRC_sum = 0xffff;
   4220          //            for (int index = 0; index < ((int)(total_number_answer + 3)); index++) CRC_sum = AddCRC(*(transmited_buffer + index),CRC_sum);
   4221          //            *(transmited_buffer+3+total_number_answer) = CRC_sum & 0xff;
   4222          //            *(transmited_buffer+4+total_number_answer) = CRC_sum >> 8;
   4223          //            
   4224          //            *transmited_count = 5+total_number_answer;
   4225          //            if(type_interface == USB_RECUEST) data_usb_transmiting = true;
   4226          //            else if(type_interface ==  RS485_RECUEST) start_transmint_data_via_RS_485(*transmited_count);
   4227          //          }
   4228          //          else
   4229          //          {
   4230          //            
   4231          //            Error_modbus((unsigned char)settings_fix.address, *(received_buffer+1), error, transmited_buffer);
   4232          //            *transmited_count = 5;
   4233          //            if(type_interface == USB_RECUEST) data_usb_transmiting = true;
   4234          //            else if(type_interface ==  RS485_RECUEST) start_transmint_data_via_RS_485(*transmited_count);
   4235          //          }
   4236          //
   4237          //          break;
   4238          //        }//Кінець для обробки функції 20        
   4239                default:
   4240                  {
   4241                    Error_modbus((unsigned char)settings_fix.address, *(received_buffer+1), ERROR_ILLEGAL_FUNCTION, transmited_buffer);
   4242                    *transmited_count = 5;
   4243                    if(type_interface == USB_RECUEST) data_usb_transmiting = true;
   4244                    else if(type_interface ==  RS485_RECUEST) start_transmint_data_via_RS_485(*transmited_count);
   4245                  }
   4246                }
   4247              }
   4248              else
   4249              {
   4250                if(type_interface == RS485_RECUEST)
   4251                {
   4252                  //Перезапускаємо моніторинг лінії RS-485
   4253                  restart_monitoring_RS485();
   4254                }
   4255              }
   4256            }
   4257            else
   4258            {
   4259              if(type_interface == RS485_RECUEST)
   4260              {
   4261                //Перезапускаємо моніторинг лінії RS-485
   4262                restart_monitoring_RS485();
   4263              }
   4264            }
   4265            *received_count = 0;
   4266          }
   4267          /***********************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      16   AddCRC
      32   Error_modbus
        32   -> AddCRC
      32   Get_data
        32   -> Get_data
        32   -> str_to_int_DATE_Mmm
      24   Set_data
     112   modbus_rountines
       112   -> AddCRC
       112   -> Error_modbus
       112   -> Get_data
       112   -> Set_data
       112   -> check_data_for_data_time_menu
       112   -> restart_monitoring_RS485
       112   -> set_config_and_settings
       112   -> set_previous_ranguvannja
       112   -> start_transmint_data_via_RS_485
       112   -> total_error_sw_fixed
       0   set_previous_ranguvannja
      16   start_transmint_data_via_RS_485
        16   -> DMA_ClearFlag
        16   -> USART_ClearFlag
        16   -> restart_monitoring_RS485


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_10
       4  ??DataTable1_11
       4  ??DataTable1_12
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
       4  ??DataTable1_8
       4  ??DataTable1_9
      12  ?_0
      12  ?_1
      60  AddCRC
      74  Error_modbus
    2048  Get_data
    2024  Set_data
    6124  modbus_rountines
       8  set_previous_ranguvannja
     216  start_transmint_data_via_RS_485

 
     24 bytes in section .rodata
 10 610 bytes in section .text
 
 6 188 bytes of CODE  memory (+ 4 422 bytes shared)
    24 bytes of CONST memory

Errors: none
Warnings: none
