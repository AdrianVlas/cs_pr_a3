###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       24/Mar/2017  12:54:56
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\v_A_shm\LULed.cpp
#    Command line =  
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\v_A_shm\LULed.cpp" -D USE_STDPERIPH_DRIVER -D STM32F2XX -D
#        USE_USB_OTG_FS -D SYSTEM_VIEWER_ENABLE -lc
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List" -lB
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List" --remarks -o
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --enable_multibytes --fpu=None
#        --dlib_config G:\PRG\IAR7_50_2\arm\INC\c\DLib_Config_Full.h -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\usb\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_OTG_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Core\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\"
#        -I "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\Config\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\OS\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\SEGGER\" -On --eec++ -I
#        G:\PRG\IAR7_50_2\arm\CMSIS\Include\ -D ARM_MATH_CM3
#    List file    =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List\LULed.lst
#    Object file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj\LULed.o
#
###############################################################################

G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working files\v_A_shm\LULed.cpp
      1          #ifdef VISUAL_STUDIO
      2          #include "StdAfx.h"
      3          #endif
      4          #include "LULed.h"
      5          //#include "libraries.h"
      6          
      7          #include "stm32f2xx.h"
      8          #include "stm32f2xx_it.h"
      9          #include "Ereg.h"
     10          
     11          
     12          
     13          void PUT_Op_1_0_    (void *pObj)
                                            ^
Remark[Pe826]: parameter "pObj" was never referenced
     14          {
     15          //CLUNot_1_1& refCLUNot_1_1 = pObj;
     16          //CLULed *pCLULed = (CLULed*)pObj;
     17          
     18          }
     19          
     20          CLULed::CLULed(void)
     21          {
     22          }
     23          CLULed::CLULed(char chM,char chI)//,LUOutDsc* pLUOutDsc)
     24          {
     25          	chMaxIteratoin = chM;
     26          	chIteration = chI;
     27          	chNumInput  = static_cast<char>(shCLULed_1_0_AmtIn);
     28          	chNumOutput = static_cast<char>(shCLULed_1_0_AmtOut);
     29          	
     30          	
     31          
     32          	//Set Input parameters
     33          	//pIn = (void*)arrPchIn;
     34          	//pOut = (void*)arrOut;
     35          	//Set OutPut parameters
     36          
     37          }
     38          
     39          CLULed::~CLULed(void)
     40          {
     41          }
     42          char chGLBIn1_5 = 0;
     43          char chGLBIn6_12 = 0;
     44          long lGLBInChek_6_12 = 0;
     45          long lGLBInChek_8_72 = 0;
     46          void SET_LED_Op(void *pObj)
     47          {
     48          	//CLUNot_1_1& refCLUNot_1_1 = pObj;
     49          //	CLULed *pCLULed = (CLULed*)pObj;
     50          CLULed& rCLULed = *(static_cast<CLULed*>(pObj));
     51          struct {
     52          char *pLAdr1;
     53          char *pLAdr2;
     54          char *pLAdr3;
     55          char *pLAdr4;
     56          short*pLASh;
     57          long L_Vl;
     58          char chVal;
     59          short shVal;
     60          } sLV;
     61           /* asm(
     62                 "bkpt 1"
     63                 );/*
                          ^
Warning[Pe009]: nested comment is not allowed
     64          rCLULed.CalcLedSchematic();*/
     65          return;
     66          sLV.pLAdr1 = reinterpret_cast<char*>(NOR_PSRAM_BANK2);
                 ^
Warning[Pe111]: statement is unreachable

  CLULed& rCLULed = *(static_cast<CLULed*>(pObj));
          ^
"G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working files\v_A_shm\LULed.cpp",50  Warning[Pe177]: 
          variable "rCLULed" was declared but never referenced
     67          sLV.pLAdr1 += ADR_WRITE_RI_COLUMNS01__06;//reinterpret_cast<char*>(NOR_PSRAM_BANK2+ADR_WRITE_RI_COLUMNS01__06 );
     68          sLV.pLAdr2 = reinterpret_cast<char*>( NOR_PSRAM_BANK2);
     69          sLV.pLAdr2 += ADR_WRITE_RDO__REL_1_6__ROWS_A__D;
     70          sLV.chVal = 0xff;
     71          *(sLV.pLAdr1) = sLV.chVal;
     72          *(sLV.pLAdr2) = sLV.chVal;
     73          
     74          sLV.pLAdr1 = reinterpret_cast<char*>(NOR_PSRAM_BANK2);
     75          sLV.pLAdr1 += ADR_WRITE_RI_COLUMNS01__06<<1;//reinterpret_cast<char*>(NOR_PSRAM_BANK2+ADR_WRITE_RI_COLUMNS01__06 );
     76          sLV.pLAdr2 = reinterpret_cast<char*>( NOR_PSRAM_BANK2);
     77          sLV.pLAdr2 += ADR_WRITE_RDO__REL_1_6__ROWS_A__D<<1;
     78          sLV.chVal = 0xff;
     79          *(sLV.pLAdr1) = sLV.chVal;
     80          *(sLV.pLAdr2) = sLV.chVal;
     81          
     82          sLV.pLAdr3 = reinterpret_cast<char*>(NOR_PSRAM_BANK2);
     83          sLV.pLAdr3 +=ADR_WRITE_RDO_REL7_REL14;//reinterpret_cast<char*>(NOR_PSRAM_BANK2+ADR_WRITE_RI_COLUMNS01__06 );
     84          sLV.pLAdr4 = reinterpret_cast<char*>( NOR_PSRAM_BANK2);
     85          sLV.pLAdr4 += ADR_WRITE_RDO_REL7_REL14;
     86          sLV.chVal = 0xff;
     87          *(sLV.pLAdr3) = sLV.chVal;
     88          *(sLV.pLAdr4) = sLV.chVal;
     89          
     90          sLV.pLAdr3 = reinterpret_cast<char*>(NOR_PSRAM_BANK2);
     91          sLV.pLAdr3 += ADR_READ_DIN01__05<<1;//
     92          sLV.pLAdr4 = reinterpret_cast<char*>( NOR_PSRAM_BANK2);
     93          sLV.pLAdr4 += ADR_READ_DIN06__12<<1;
     94          sLV.chVal = *(sLV.pLAdr3);
     95          chGLBIn1_5  |= sLV.chVal;
     96          sLV.chVal = *(sLV.pLAdr4);
     97          chGLBIn6_12 |= sLV.chVal;
     98          
     99          sLV.chVal = 0;
    100          sLV.L_Vl = NOR_PSRAM_BANK2+(ADR_READ_CHECK_RDO__REL_1_6<<1);
    101          sLV.pLASh = reinterpret_cast<short*>(sLV.L_Vl);
    102          //sLV.pLASh += ADR_READ_CHECK_RDO__REL_1_6<<1;//
    103          sLV.shVal = *(sLV.pLASh);
    104          lGLBInChek_6_12  |= sLV.shVal;
    105          
    106          sLV.chVal = 0;
    107          sLV.L_Vl = NOR_PSRAM_BANK2+(ADR_READ_CHECK_RDO_REL7_REL14<<1);
    108          sLV.pLASh = reinterpret_cast<short*>(sLV.L_Vl);
    109          //sLV.pLASh += ADR_READ_CHECK_RDO__REL_1_6<<1;//
    110          sLV.shVal = *(sLV.pLASh);
    111          lGLBInChek_8_72  |= sLV.shVal;
    112          
    113          
    114          
    115          //sLV.pLAdr3 = reinterpret_cast<long*>( );
    116          //sLV.pLAdr4 = reinterpret_cast<long*>( );
    117          //Set PD3 In O-state
    118          //GPIO_ResetBits(CON_L, CON_L_PIN);
    119          //GPIO_SetBits  (CON_L, CON_L_PIN);
    120          
    121          //GPIO_SetBits(CON_L, CON_L_PIN);GPIO_ResetBits(CON_L, CON_L_PIN);
    122          
    123          
    124          }
    125          
    126          #include "LULedp1.cpp"
    127          static char chGLB_QTrg = 0;
    128          void CLULed::CalcLedSchematic(void){
    129          register long rl_Val,i;
    130          
    131          #pragma data_alignment=4
    132          char arChIntermediaResult[(TOTAL_LU_CALC_POINT)];
    133          const LedShcemasDscRecord* pLUShcemasDscRec;// = &arPLedShcemasDscRecords;
    134          
    135          
    136          arChIntermediaResult[OFFSET_OUT_IN_00_LEDIN                   ] = 0;//Now Default
    137          arChIntermediaResult[OFFSET_OUT_IN_01_RESET                   ] = 0;//Now Default
    138          arChIntermediaResult[OFFSET_OUT_IN_02_BL_IMP                  ] = 0;//Now Default
    139          arChIntermediaResult[OFFSET_OUT_IN_03_C1_C2_SELECTOR          ] = 0;//Now Default
    140          arChIntermediaResult[OFFSET_OUT_IN_04_C1                      ] = 0;//Now Default
    141          arChIntermediaResult[OFFSET_OUT_IN_05_C2                      ] = 0;//Now Default
    142          arChIntermediaResult[OFFSET_OUT_IN_MNU_NORMAL_SELECTOR        ] = 0;//Now Default
    143          arChIntermediaResult[OFFSET_OUT_IN_MNU_TRIGGER_SELECTOR       ] = 0;//Now Default
    144          arChIntermediaResult[OFFSET_OUT_IN_MNU_STABLE_SELECTOR        ] = 0;//Now Default
    145          arChIntermediaResult[OFFSET_OUT_IN_MNU_PULSE_SELECTOR         ] = 0;//Now Default
    146          arChIntermediaResult[OFFSET_OUT_IN_MNU_PULSE_SIMPLE_SELECTOR  ] = 0;//Now Default
    147          arChIntermediaResult[OFFSET_OUT_IN_MNU_PULSE_EXTANDED_SELECTOR] = 0;//Now Default
    148              rl_Val = 0;
    149          	long k, j, l;
    150              short shCounterProcessedRec = Not06__1_1;
    151              do {
    152          pLUShcemasDscRec = arPLedShcemasDscRecords[shCounterProcessedRec - Not06__1_1];
    153                  i = pLUShcemasDscRec->chTypeOperation;
    154                  switch (i) {
    155                      case LU_GEN_OP_AND:
    156                          rl_Val = 1;
    157                          for (i = 0; (i < pLUShcemasDscRec->chAmtOut)&&(rl_Val == 1); i++) {
    158                              k = pLUShcemasDscRec->pInputDscData[i].shOrderNumLU;
    159                              l = arShOffsets[k];
    160                              j = l + pLUShcemasDscRec->pInputDscData[i].shIndexOut;
    161                              rl_Val &= arChIntermediaResult[j];
    162                          }
    163                          arChIntermediaResult[shCounterProcessedRec++] = rl_Val;
    164                          break;
    165                      case LU_GEN_OP_OR:
    166                          rl_Val = 0;
    167                          for (i = 0; (i < pLUShcemasDscRec->chAmtOut)&&( rl_Val == 0); i++) {
    168                              k = pLUShcemasDscRec->pInputDscData[i].shOrderNumLU;
    169                              l = arShOffsets[k];
    170                              j = l + pLUShcemasDscRec->pInputDscData[i].shIndexOut;
    171                              rl_Val |= arChIntermediaResult[j];
    172                          }
    173                          arChIntermediaResult[shCounterProcessedRec++] = rl_Val;
    174                          break;
    175                      case LU_GEN_OP_XOR:
    176                          i = pLUShcemasDscRec->pInputDscData[0].shOrderNumLU;
    177                          rl_Val = arShOffsets[i];
    178                          i = rl_Val + pLUShcemasDscRec->pInputDscData[0].shIndexOut;
    179                          j = arChIntermediaResult[i];
    180                          i = pLUShcemasDscRec->pInputDscData[1].shOrderNumLU;
    181                          rl_Val = arShOffsets[i];
    182                          i = rl_Val + pLUShcemasDscRec->pInputDscData[1].shIndexOut;
    183                          rl_Val = j^arChIntermediaResult[i];
    184                          arChIntermediaResult[shCounterProcessedRec++] = rl_Val;
    185                          break;
    186                      case LU_GEN_OP_NOT:
    187                          LUShcemasInDataDsc const *pLUShcemasInDataDsc;
    188                          rl_Val = 0;
    189                          pLUShcemasInDataDsc = pLUShcemasDscRec->pInputDscData;
    190                          i = pLUShcemasInDataDsc[0].shOrderNumLU;
    191                          rl_Val = arShOffsets[i];
    192                          i = rl_Val + pLUShcemasInDataDsc[0].shIndexOut;
    193                          rl_Val = arChIntermediaResult[i];
    194          
    195                          arChIntermediaResult[shCounterProcessedRec++] = rl_Val;
    196                          break;
    197                      case LU_GEN_OP_RS_TRIGGER:
    198                          rl_Val = 0;
    199                          rl_Val = chGLB_QTrg;
    200                          arChIntermediaResult[shCounterProcessedRec++] = rl_Val;
    201                          arChIntermediaResult[shCounterProcessedRec++] = !rl_Val;
    202                          break;
    203                          //Read Input Data
    204          
    205                          //Eval Function
    206                          //Put Result
    207                          
    208                      default:
    209                          ;
    210                  }
    211            
    212              } while (shCounterProcessedRec < IN_MNU_NORMAL_SELECTOR);
    213          
    214          }
    215          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   CLULed::CLULed()
         8   -> CLUBase::subobject CLUBase()
      16   CLULed::CLULed(char, char)
        16   -> CLUBase::subobject CLUBase()
      64   CLULed::CalcLedSchematic()
       8   CLULed::subobject CLULed()
         8   -> CLULed::CLULed()
       8   CLULed::subobject CLULed(char, char)
         8   -> CLULed::CLULed(char, char)
       8   CLULed::subobject ~CLULed()
         8   -> CLULed::~CLULed()
       8   CLULed::~CLULed()
         8   -> CLUBase::subobject ~CLUBase()
       0   PUT_Op_1_0_(void *)
       0   SET_LED_Op(void *)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
       4  ??DataTable0_1
       4  ??DataTable0_2
       8  And07__2_1DscRec
       8  And08__2_1DscRec
       8  And09__2_1DscRec
       8  And13__2_1DscRec
       8  And14__2_1DscRec
       8  And15__2_1DscRec
       8  And16__2_1DscRec
       8  And20__3_1DscRec
       8  And21__3_1DscRec
      14  CLULed::CLULed()
      30  CLULed::CLULed(char, char)
     564  CLULed::CalcLedSchematic()
      12  CLULed::subobject CLULed()
      16  CLULed::subobject CLULed(char, char)
      12  CLULed::subobject ~CLULed()
      14  CLULed::~CLULed()
       8  Not06__1_1DscRec
       8  Not19__1_1DscRec
       8  Or22__3_1DscRec
       8  Or_10__2_1DscRec
       8  Or_11__2_1DscRec
       8  Or_17__2_1DscRec
       8  Or_18__2_1DscRec
       2  PUT_Op_1_0_(void *)
       8  RS_12__2_2DscRec
       2  SET_LED_Op(void *)
       8  arAnd07__2_1InDataDsc
       8  arAnd08__2_1InDataDsc
       8  arAnd09__2_1InDataDsc
       8  arAnd13__2_1InDataDsc
       8  arAnd14__2_1InDataDsc
       8  arAnd15__2_1InDataDsc
       8  arAnd16__2_1InDataDsc
      12  arAnd20__3_1InDataDsc
      12  arAnd21__3_1InDataDsc
       4  arNot06__1_1InDataDsc
       4  arNot19__1_1InDataDsc
      12  arOr22__3_1InDataDsc
       8  arOr_10__2_1InDataDsc
       8  arOr_11__2_1InDataDsc
       8  arOr_17__2_1InDataDsc
       8  arOr_18__2_1InDataDsc
      68  arPLedShcemasDscRecords
       8  arRS_12__2_2InDataDsc
      68  arShOffsets
       1  chGLBIn1_5
       1  chGLBIn6_12
       1  chGLB_QTrg
       4  lGLBInChek_6_12
       4  lGLBInChek_8_72

 
  11 bytes in section .bss
 412 bytes in section .rodata
 678 bytes in section .text
 
 678 bytes of CODE  memory
 412 bytes of CONST memory
  11 bytes of DATA  memory

Errors: none
Warnings: 3
