###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       24/Mar/2017  12:55:00
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\SystemView\SEGGER\SEGGER_RTT.c
#    Command line =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\SystemView\SEGGER\SEGGER_RTT.c
#        -D USE_STDPERIPH_DRIVER -D STM32F2XX -D USE_USB_OTG_FS -D
#        KEYBOARD_VER_1 -D SYSTEM_VIEWER_ENABLE -lc
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List" --remarks -o
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --enable_multibytes --fpu=None
#        --dlib_config G:\PRG\IAR7_50_2\arm\INC\c\DLib_Config_Full.h -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\usb\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_OTG_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Core\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\"
#        -I "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\Config\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\OS\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\SEGGER\" -On --use_c++_inline
#        --require_prototypes -I G:\PRG\IAR7_50_2\arm\CMSIS\Include\ -D
#        ARM_MATH_CM3
#    List file    =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List\SEGGER_RTT.lst
#    Object file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj\SEGGER_RTT.o
#
###############################################################################

G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\SystemView\SEGGER\SEGGER_RTT.c
      1          /*********************************************************************
      2          *               SEGGER MICROCONTROLLER GmbH & Co. KG                 *
      3          *       Solutions for real time microcontroller applications         *
      4          **********************************************************************
      5          *                                                                    *
      6          *       (c) 2015 - 2016  SEGGER Microcontroller GmbH & Co. KG        *
      7          *                                                                    *
      8          *       www.segger.com     Support: support@segger.com               *
      9          *                                                                    *
     10          **********************************************************************
     11          *                                                                    *
     12          *       SEGGER SystemView * Real-time application analysis           *
     13          *                                                                    *
     14          **********************************************************************
     15          *                                                                    *
     16          * All rights reserved.                                               *
     17          *                                                                    *
     18          * * This software may in its unmodified form be freely redistributed *
     19          *   in source form.                                                  *
     20          * * The source code may be modified, provided the source code        *
     21          *   retains the above copyright notice, this list of conditions and  *
     22          *   the following disclaimer.                                        *
     23          * * Modified versions of this software in source or linkable form    *
     24          *   may not be distributed without prior consent of SEGGER.          *
     25          *                                                                    *
     26          * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS "AS IS" AND     *
     27          * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,  *
     28          * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A        *
     29          * PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL               *
     30          * SEGGER Microcontroller BE LIABLE FOR ANY DIRECT, INDIRECT,         *
     31          * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES           *
     32          * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS    *
     33          * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS            *
     34          * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,       *
     35          * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING          *
     36          * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS *
     37          * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.       *
     38          *                                                                    *
     39          **********************************************************************
     40          *                                                                    *
     41          *       SystemView version: V2.28                                    *
     42          *                                                                    *
     43          **********************************************************************
     44          ---------------------------END-OF-HEADER------------------------------
     45          File    : SEGGER_RTT.c
     46          Purpose : Implementation of SEGGER real-time transfer (RTT) which
     47                    allows real-time communication on targets which support
     48                    debugger memory accesses while the CPU is running.
     49          
     50          Additional information:
     51                    Type "int" is assumed to be 32-bits in size
     52                    H->T    Host to target communication
     53                    T->H    Target to host communication
     54          
     55                    RTT channel 0 is always present and reserved for Terminal usage.
     56                    Name is fixed to "Terminal"
     57          
     58          ----------------------------------------------------------------------
     59          */
     60          
     61          #include "SEGGER_RTT.h"
     62          
     63          #include <string.h>                 // for memcpy
     64          
     65          /*********************************************************************
     66          *
     67          *       Configuration, default values
     68          *
     69          **********************************************************************
     70          */
     71          
     72          #ifndef   BUFFER_SIZE_UP
     73            #define BUFFER_SIZE_UP                                  1024  // Size of the buffer for terminal output of target, up to host
     74          #endif
     75          
     76          #ifndef   BUFFER_SIZE_DOWN
     77            #define BUFFER_SIZE_DOWN                                16    // Size of the buffer for terminal input to target from host (Usually keyboard input)
     78          #endif
     79          
     80          #ifndef   SEGGER_RTT_MAX_NUM_UP_BUFFERS
     81            #define SEGGER_RTT_MAX_NUM_UP_BUFFERS                    2    // Number of up-buffers (T->H) available on this target
     82          #endif
     83          
     84          #ifndef   SEGGER_RTT_MAX_NUM_DOWN_BUFFERS
     85            #define SEGGER_RTT_MAX_NUM_DOWN_BUFFERS                  2    // Number of down-buffers (H->T) available on this target
     86          #endif
     87          
     88          #ifndef   SEGGER_RTT_MODE_DEFAULT
     89            #define SEGGER_RTT_MODE_DEFAULT                         SEGGER_RTT_MODE_NO_BLOCK_SKIP
     90          #endif
     91          
     92          #ifndef   SEGGER_RTT_LOCK
     93            #define SEGGER_RTT_LOCK()
     94          #endif
     95          
     96          #ifndef   SEGGER_RTT_UNLOCK
     97            #define SEGGER_RTT_UNLOCK()
     98          #endif
     99          
    100          #ifndef   STRLEN
    101            #define STRLEN(a)                                       strlen((a))
    102          #endif
    103          
    104          #ifndef   MEMCPY
    105            #define MEMCPY(pDest, pSrc, NumBytes)                   memcpy((pDest), (pSrc), (NumBytes))
    106          #endif
    107          
    108          #ifndef   MIN
    109            #define MIN(a, b)         (((a) < (b)) ? (a) : (b))
    110          #endif
    111          
    112          #ifndef   MAX
    113            #define MAX(a, b)         (((a) > (b)) ? (a) : (b))
    114          #endif
    115          //
    116          // For some environments, NULL may not be defined until certain headers are included
    117          //
    118          #ifndef NULL
    119            #define NULL 0
    120          #endif
    121          
    122          /*********************************************************************
    123          *
    124          *       Static const data
    125          *
    126          **********************************************************************
    127          */
    128          
    129          static unsigned char _aTerminalId[16] = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
    130          
    131          /*********************************************************************
    132          *
    133          *       Static data
    134          *
    135          **********************************************************************
    136          */
    137          //
    138          // Allocate buffers for channel 0
    139          //
    140          static char _acUpBuffer  [BUFFER_SIZE_UP];
    141          static char _acDownBuffer[BUFFER_SIZE_DOWN];
    142          //
    143          // Initialize SEGGER Real-time-Terminal control block (CB)
    144          //
    145          SEGGER_RTT_CB _SEGGER_RTT;
    146          
    147          static char _ActiveTerminal;
    148          
    149          /*********************************************************************
    150          *
    151          *       Static functions
    152          *
    153          **********************************************************************
    154          */
    155          
    156          /*********************************************************************
    157          *
    158          *       _DoInit()
    159          *
    160          *  Function description
    161          *    Initializes the control block an buffers.
    162          *    May only be called via INIT() to avoid overriding settings.
    163          *
    164          */
    165          #define INIT()  do {                                            \
    166                            if (_SEGGER_RTT.acID[0] == '\0') { _DoInit(); }  \
    167                          } while (0)
    168          static void _DoInit(void) {
    169            SEGGER_RTT_CB* p;
    170            //
    171            // Initialize control block
    172            //
    173            p = &_SEGGER_RTT;
    174            p->MaxNumUpBuffers    = SEGGER_RTT_MAX_NUM_UP_BUFFERS;
    175            p->MaxNumDownBuffers  = SEGGER_RTT_MAX_NUM_DOWN_BUFFERS;
    176            //
    177            // Initialize up buffer 0
    178            //
    179            p->aUp[0].sName         = "Terminal";
    180            p->aUp[0].pBuffer       = _acUpBuffer;
    181            p->aUp[0].SizeOfBuffer  = sizeof(_acUpBuffer);
    182            p->aUp[0].RdOff         = 0u;
    183            p->aUp[0].WrOff         = 0u;
    184            p->aUp[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    185            //
    186            // Initialize down buffer 0
    187            //
    188            p->aDown[0].sName         = "Terminal";
    189            p->aDown[0].pBuffer       = _acDownBuffer;
    190            p->aDown[0].SizeOfBuffer  = sizeof(_acDownBuffer);
    191            p->aDown[0].RdOff         = 0u;
    192            p->aDown[0].WrOff         = 0u;
    193            p->aDown[0].Flags         = SEGGER_RTT_MODE_DEFAULT;
    194            //
    195            // Finish initialization of the control block.
    196            // Copy Id string in three steps to make sure "SEGGER RTT" is not found
    197            // in initializer memory (usually flash) by J-Link
    198            //
    199            strcpy(&p->acID[7], "RTT");
    200            strcpy(&p->acID[0], "SEGGER");
    201            p->acID[6] = ' ';
    202          }
    203          
    204          /*********************************************************************
    205          *
    206          *       _WriteBlocking()
    207          *
    208          *  Function description
    209          *    Stores a specified number of characters in SEGGER RTT ring buffer
    210          *    and updates the associated write pointer which is periodically
    211          *    read by the host.
    212          *    The caller is responsible for managing the write chunk sizes as
    213          *    _WriteBlocking() will block until all data has been posted successfully.
    214          *
    215          *  Parameters
    216          *    pRing        Ring buffer to post to.
    217          *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
    218          *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
    219          *
    220          *  Return value
    221          *    >= 0 - Number of bytes written into buffer.
    222          */
    223          static unsigned _WriteBlocking(SEGGER_RTT_BUFFER_UP* pRing, const char* pBuffer, unsigned NumBytes) {
    224            unsigned NumBytesToWrite;
    225            unsigned NumBytesWritten;
    226            unsigned RdOff;
    227            unsigned WrOff;
    228            //
    229            // Write data to buffer and handle wrap-around if necessary
    230            //
    231            NumBytesWritten = 0u;
    232            WrOff = pRing->WrOff;
    233            do {
    234              RdOff = pRing->RdOff;                         // May be changed by host (debug probe) in the meantime
    235              if (RdOff > WrOff) {
    236                NumBytesToWrite = RdOff - WrOff - 1u;
    237              } else {
    238                NumBytesToWrite = pRing->SizeOfBuffer - (WrOff - RdOff + 1u);
    239              }
    240              NumBytesToWrite = MIN(NumBytesToWrite, (pRing->SizeOfBuffer - WrOff));      // Number of bytes that can be written until buffer wrap-around
    241              NumBytesToWrite = MIN(NumBytesToWrite, NumBytes);
    242              memcpy(pRing->pBuffer + WrOff, pBuffer, NumBytesToWrite);
    243              NumBytesWritten += NumBytesToWrite;
    244              pBuffer         += NumBytesToWrite;
    245              NumBytes        -= NumBytesToWrite;
    246              WrOff           += NumBytesToWrite;
    247              if (WrOff == pRing->SizeOfBuffer) {
    248                WrOff = 0u;
    249              }
    250              pRing->WrOff = WrOff;
    251            } while (NumBytes);
    252            //
    253            return NumBytesWritten;
    254          }
    255          
    256          /*********************************************************************
    257          *
    258          *       _WriteNoCheck()
    259          *
    260          *  Function description
    261          *    Stores a specified number of characters in SEGGER RTT ring buffer
    262          *    and updates the associated write pointer which is periodically
    263          *    read by the host.
    264          *    It is callers responsibility to make sure data actually fits in buffer.
    265          *
    266          *  Parameters
    267          *    pRing        Ring buffer to post to.
    268          *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
    269          *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
    270          *
    271          *  Notes
    272          *    (1) If there might not be enough space in the "Up"-buffer, call _WriteBlocking
    273          */
    274          static void _WriteNoCheck(SEGGER_RTT_BUFFER_UP* pRing, const char* pData, unsigned NumBytes) {
    275            unsigned NumBytesAtOnce;
    276            unsigned WrOff;
    277            unsigned Rem;
    278          
    279            WrOff = pRing->WrOff;
    280            Rem = pRing->SizeOfBuffer - WrOff;
    281            if (Rem > NumBytes) {
    282              //
    283              // All data fits before wrap around
    284              //
    285              memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
    286              pRing->WrOff = WrOff + NumBytes;
    287            } else {
    288              //
    289              // We reach the end of the buffer, so need to wrap around
    290              //
    291              NumBytesAtOnce = Rem;
    292              memcpy(pRing->pBuffer + WrOff, pData, NumBytesAtOnce);
    293              NumBytesAtOnce = NumBytes - Rem;
    294              memcpy(pRing->pBuffer, pData + Rem, NumBytesAtOnce);
    295              pRing->WrOff = NumBytesAtOnce;
    296            }
    297          }
    298          
    299          /*********************************************************************
    300          *
    301          *       _PostTerminalSwitch()
    302          *
    303          *  Function description
    304          *    Switch terminal to the given terminal ID.  It is the caller's
    305          *    responsibility to ensure the terminal ID is correct and there is
    306          *    enough space in the buffer for this to complete successfully.
    307          *
    308          *  Parameters
    309          *    pRing        Ring buffer to post to.
    310          *    TerminalId   Terminal ID to switch to.
    311          */
    312          static void _PostTerminalSwitch(SEGGER_RTT_BUFFER_UP* pRing, unsigned char TerminalId) {
    313            char ac[2];
    314          
    315            ac[0] = 0xFFu;
    316            ac[1] = _aTerminalId[TerminalId];  // Caller made already sure that TerminalId does not exceed our terminal limit
    317            _WriteBlocking(pRing, ac, 2u);
    318          }
    319          
    320          /*********************************************************************
    321          *
    322          *       _GetAvailWriteSpace()
    323          *
    324          *  Function description
    325          *    Returns the number of bytes that can be written to the ring
    326          *    buffer without blocking.
    327          *
    328          *  Parameters
    329          *    pRing        Ring buffer to check.
    330          *
    331          *  Return value
    332          *    Number of bytes that are free in the buffer.
    333          */
    334          static unsigned _GetAvailWriteSpace(SEGGER_RTT_BUFFER_UP* pRing) {
    335            unsigned RdOff;
    336            unsigned WrOff;
    337            unsigned r;
    338            //
    339            // Avoid warnings regarding volatile access order.  It's not a problem
    340            // in this case, but dampen compiler enthusiasm.
    341            //
    342            RdOff = pRing->RdOff;
    343            WrOff = pRing->WrOff;
    344            if (RdOff <= WrOff) {
    345              r = pRing->SizeOfBuffer - 1u - WrOff + RdOff;
    346            } else {
    347              r = RdOff - WrOff - 1u;
    348            }
    349            return r;
    350          }
    351          
    352          /*********************************************************************
    353          *
    354          *       Public code
    355          *
    356          **********************************************************************
    357          */
    358          /*********************************************************************
    359          *
    360          *       SEGGER_RTT_ReadNoLock()
    361          *
    362          *  Function description
    363          *    Reads characters from SEGGER real-time-terminal control block
    364          *    which have been previously stored by the host.
    365          *    Do not lock against interrupts and multiple access.
    366          *
    367          *  Parameters
    368          *    BufferIndex  Index of Down-buffer to be used (e.g. 0 for "Terminal").
    369          *    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-down-buffer to.
    370          *    BufferSize   Size of the target application buffer.
    371          *
    372          *  Return value
    373          *    Number of bytes that have been read.
    374          */
    375          unsigned SEGGER_RTT_ReadNoLock(unsigned BufferIndex, void* pData, unsigned BufferSize) {
    376            unsigned                NumBytesRem;
    377            unsigned                NumBytesRead;
    378            unsigned                RdOff;
    379            unsigned                WrOff;
    380            unsigned char*          pBuffer;
    381            SEGGER_RTT_BUFFER_DOWN* pRing;
    382            //
    383            INIT();
    384            pRing = &_SEGGER_RTT.aDown[BufferIndex];
    385            pBuffer = (unsigned char*)pData;
    386            RdOff = pRing->RdOff;
    387            WrOff = pRing->WrOff;
    388            NumBytesRead = 0u;
    389            //
    390            // Read from current read position to wrap-around of buffer, first
    391            //
    392            if (RdOff > WrOff) {
    393              NumBytesRem = pRing->SizeOfBuffer - RdOff;
    394              NumBytesRem = MIN(NumBytesRem, BufferSize);
    395              memcpy(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
    396              NumBytesRead += NumBytesRem;
    397              pBuffer      += NumBytesRem;
    398              BufferSize   -= NumBytesRem;
    399              RdOff        += NumBytesRem;
    400              //
    401              // Handle wrap-around of buffer
    402              //
    403              if (RdOff == pRing->SizeOfBuffer) {
    404                RdOff = 0u;
    405              }
    406            }
    407            //
    408            // Read remaining items of buffer
    409            //
    410            NumBytesRem = WrOff - RdOff;
    411            NumBytesRem = MIN(NumBytesRem, BufferSize);
    412            if (NumBytesRem > 0u) {
    413              memcpy(pBuffer, pRing->pBuffer + RdOff, NumBytesRem);
    414              NumBytesRead += NumBytesRem;
    415              pBuffer      += NumBytesRem;
    416              BufferSize   -= NumBytesRem;
    417              RdOff        += NumBytesRem;
    418            }
    419            if (NumBytesRead) {
    420              pRing->RdOff = RdOff;
    421            }
    422            //
    423            return NumBytesRead;
    424          }
    425          
    426          /*********************************************************************
    427          *
    428          *       SEGGER_RTT_Read
    429          *
    430          *  Function description
    431          *    Reads characters from SEGGER real-time-terminal control block
    432          *    which have been previously stored by the host.
    433          *
    434          *  Parameters
    435          *    BufferIndex  Index of Down-buffer to be used (e.g. 0 for "Terminal").
    436          *    pBuffer      Pointer to buffer provided by target application, to copy characters from RTT-down-buffer to.
    437          *    BufferSize   Size of the target application buffer.
    438          *
    439          *  Return value
    440          *    Number of bytes that have been read.
    441          */
    442          unsigned SEGGER_RTT_Read(unsigned BufferIndex, void* pBuffer, unsigned BufferSize) {
    443            unsigned NumBytesRead;
    444            //
    445            SEGGER_RTT_LOCK();
    446            //
    447            // Call the non-locking read function
    448            //
    449            NumBytesRead = SEGGER_RTT_ReadNoLock(BufferIndex, pBuffer, BufferSize);
    450            //
    451            // Finish up.
    452            //
    453            SEGGER_RTT_UNLOCK();
    454            //
    455            return NumBytesRead;
    456          }
    457          
    458          /*********************************************************************
    459          *
    460          *       SEGGER_RTT_WriteSkipNoLock
    461          *
    462          *  Function description
    463          *    Stores a specified number of characters in SEGGER RTT
    464          *    control block which is then read by the host.
    465          *    SEGGER_RTT_WriteSkipNoLock does not lock the application and
    466          *    skips all data, if the data does not fit into the buffer.
    467          *
    468          *  Parameters
    469          *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
    470          *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
    471          *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
    472          *
    473          *  Return value
    474          *    Number of bytes which have been stored in the "Up"-buffer.
    475          *
    476          *  Notes
    477          *    (1) If there is not enough space in the "Up"-buffer, all data is dropped.
    478          *    (2) For performance reasons this function does not call Init()
    479          *        and may only be called after RTT has been initialized.
    480          *        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
    481          */
    482          unsigned SEGGER_RTT_WriteSkipNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    483            const char*           pData;
    484            SEGGER_RTT_BUFFER_UP* pRing;
    485            unsigned              Avail;
    486            unsigned              RdOff;
    487            unsigned              WrOff;
    488            unsigned              Rem;
    489          
    490            pData = (const char *)pBuffer;
    491            //
    492            // Get "to-host" ring buffer and copy some elements into local variables.
    493            //
    494            pRing = &_SEGGER_RTT.aUp[BufferIndex];
    495            RdOff = pRing->RdOff;
    496            WrOff = pRing->WrOff;
    497            //
    498            // Handle the most common cases fastest.
    499            // Which is:
    500            //    RdOff <= WrOff -> Space until wrap around is free.
    501            //  AND
    502            //    WrOff + NumBytes < SizeOfBuffer -> No Wrap around necessary.
    503            //
    504            //  OR
    505            //
    506            //    RdOff > WrOff -> Space until RdOff - 1 is free.
    507            //  AND
    508            //    WrOff + NumBytes < RdOff -> Data fits into buffer
    509            //
    510            if (RdOff <= WrOff) {
    511              //
    512              // Get space until WrOff will be at wrap around.
    513              //
    514              Avail = pRing->SizeOfBuffer - 1u - WrOff ;
    515              if (Avail >= NumBytes) {
    516          #if 1 // memcpy() is good for large amounts of data, but the overhead is too big for small amounts. Use a simple byte loop instead.
    517                char* pDst;
    518                pDst = pRing->pBuffer + WrOff;
    519                WrOff += NumBytes;
    520                do {
    521                  *pDst++ = *pData++;
    522                } while (--NumBytes);
    523                pRing->WrOff = WrOff + NumBytes;
    524          #else
    525                memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
    526                pRing->WrOff = WrOff + NumBytes;
    527          #endif
    528                return 1;
    529              }
    530              //
    531              // If data did not fit into space until wrap around calculate complete space in buffer.
    532              //
    533              Avail += RdOff;
    534              //
    535              // If there is still no space for the whole of this output, don't bother.
    536              //
    537              if (Avail >= NumBytes) {
    538                //
    539                //  OK, we have enough space in buffer. Copy in one or 2 chunks
    540                //
    541                Rem = pRing->SizeOfBuffer - WrOff;      // Space until end of buffer
    542                if (Rem > NumBytes) {
    543                  memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
    544                  pRing->WrOff = WrOff + NumBytes;
    545                } else {
    546                  //
    547                  // We reach the end of the buffer, so need to wrap around
    548                  //
    549                  memcpy(pRing->pBuffer + WrOff, pData, Rem);
    550                  memcpy(pRing->pBuffer, pData + Rem, NumBytes - Rem);
    551                  pRing->WrOff = NumBytes - Rem;
    552                }
    553                return 1;
    554              }
    555            } else {
    556              Avail = RdOff - WrOff - 1u;
    557              if (Avail >= NumBytes) {
    558                memcpy(pRing->pBuffer + WrOff, pData, NumBytes);
    559                pRing->WrOff = WrOff + NumBytes;
    560                return 1;
    561              }
    562            }
    563            //
    564            // If we reach this point no data has been written
    565            //
    566            return 0;
    567          }
    568          
    569          /*********************************************************************
    570          *
    571          *       SEGGER_RTT_WriteNoLock
    572          *
    573          *  Function description
    574          *    Stores a specified number of characters in SEGGER RTT
    575          *    control block which is then read by the host.
    576          *    SEGGER_RTT_WriteNoLock does not lock the application.
    577          *
    578          *  Parameters
    579          *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
    580          *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
    581          *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
    582          *
    583          *  Return value
    584          *    Number of bytes which have been stored in the "Up"-buffer.
    585          *
    586          *  Notes
    587          *    (1) If there is not enough space in the "Up"-buffer, remaining characters of pBuffer are dropped.
    588          *    (2) For performance reasons this function does not call Init()
    589          *        and may only be called after RTT has been initialized.
    590          *        Either by calling SEGGER_RTT_Init() or calling another RTT API function first.
    591          */
    592          unsigned SEGGER_RTT_WriteNoLock(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    593            unsigned              Status;
    594            unsigned              Avail;
    595            const char*           pData;
    596            SEGGER_RTT_BUFFER_UP* pRing;
    597          
    598            pData = (const char *)pBuffer;
    599            //
    600            // Get "to-host" ring buffer.
    601            //
    602            pRing = &_SEGGER_RTT.aUp[BufferIndex];
    603            //
    604            // How we output depends upon the mode...
    605            //
    606            switch (pRing->Flags) {
    607            case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
    608              //
    609              // If we are in skip mode and there is no space for the whole
    610              // of this output, don't bother.
    611              //
    612              Avail = _GetAvailWriteSpace(pRing);
    613              if (Avail < NumBytes) {
    614                Status = 0u;
    615              } else {
    616                Status = NumBytes;
    617                _WriteNoCheck(pRing, pData, NumBytes);
    618              }
    619              break;
    620            case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
    621              //
    622              // If we are in trim mode, trim to what we can output without blocking.
    623              //
    624              Avail = _GetAvailWriteSpace(pRing);
    625              Status = Avail < NumBytes ? Avail : NumBytes;
    626              _WriteNoCheck(pRing, pData, Status);
    627              break;
    628            case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
    629              //
    630              // If we are in blocking mode, output everything.
    631              //
    632              Status = _WriteBlocking(pRing, pData, NumBytes);
    633              break;
    634            default:
    635              Status = 0u;
    636              break;
    637            }
    638            //
    639            // Finish up.
    640            //
    641            return Status;
    642          }
    643          
    644          /*********************************************************************
    645          *
    646          *       SEGGER_RTT_Write
    647          *
    648          *  Function description
    649          *    Stores a specified number of characters in SEGGER RTT
    650          *    control block which is then read by the host.
    651          *
    652          *  Parameters
    653          *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
    654          *    pBuffer      Pointer to character array. Does not need to point to a \0 terminated string.
    655          *    NumBytes     Number of bytes to be stored in the SEGGER RTT control block.
    656          *
    657          *  Return value
    658          *    Number of bytes which have been stored in the "Up"-buffer.
    659          *
    660          *  Notes
    661          *    (1) If there is not enough space in the "Up"-buffer, remaining characters of pBuffer are dropped.
    662          */
    663          unsigned SEGGER_RTT_Write(unsigned BufferIndex, const void* pBuffer, unsigned NumBytes) {
    664            unsigned Status;
    665            //
    666            INIT();
    667            SEGGER_RTT_LOCK();
    668            //
    669            // Call the non-locking write function
    670            //
    671            Status = SEGGER_RTT_WriteNoLock(BufferIndex, pBuffer, NumBytes);
    672            //
    673            // Finish up.
    674            //
    675            SEGGER_RTT_UNLOCK();
    676            //
    677            return Status;
    678          }
    679          
    680          /*********************************************************************
    681          *
    682          *       SEGGER_RTT_WriteString
    683          *
    684          *  Function description
    685          *    Stores string in SEGGER RTT control block.
    686          *    This data is read by the host.
    687          *
    688          *  Parameters
    689          *    BufferIndex  Index of "Up"-buffer to be used (e.g. 0 for "Terminal").
    690          *    s            Pointer to string.
    691          *
    692          *  Return value
    693          *    Number of bytes which have been stored in the "Up"-buffer.
    694          *
    695          *  Notes
    696          *    (1) If there is not enough space in the "Up"-buffer, depending on configuration,
    697          *        remaining characters may be dropped or RTT module waits until there is more space in the buffer.
    698          *    (2) String passed to this function has to be \0 terminated
    699          *    (3) \0 termination character is *not* stored in RTT buffer
    700          */
    701          unsigned SEGGER_RTT_WriteString(unsigned BufferIndex, const char* s) {
    702            unsigned Len;
    703          
    704            Len = STRLEN(s);
    705            return SEGGER_RTT_Write(BufferIndex, s, Len);
    706          }
    707          
    708          /*********************************************************************
    709          *
    710          *       SEGGER_RTT_GetKey
    711          *
    712          *  Function description
    713          *    Reads one character from the SEGGER RTT buffer.
    714          *    Host has previously stored data there.
    715          *
    716          *  Return value
    717          *    <  0 -   No character available (buffer empty).
    718          *    >= 0 -   Character which has been read. (Possible values: 0 - 255)
    719          *
    720          *  Notes
    721          *    (1) This function is only specified for accesses to RTT buffer 0.
    722          */
    723          int SEGGER_RTT_GetKey(void) {
    724            char c;
    725            int r;
    726          
    727            r = (int)SEGGER_RTT_Read(0u, &c, 1u);
    728            if (r == 1) {
    729              r = (int)(unsigned char)c;
    730            } else {
    731              r = -1;
    732            }
    733            return r;
    734          }
    735          
    736          /*********************************************************************
    737          *
    738          *       SEGGER_RTT_WaitKey
    739          *
    740          *  Function description
    741          *    Waits until at least one character is avaible in the SEGGER RTT buffer.
    742          *    Once a character is available, it is read and this function returns.
    743          *
    744          *  Return value
    745          *    >=0 -   Character which has been read.
    746          *
    747          *  Notes
    748          *    (1) This function is only specified for accesses to RTT buffer 0
    749          *    (2) This function is blocking if no character is present in RTT buffer
    750          */
    751          int SEGGER_RTT_WaitKey(void) {
    752            int r;
    753          
    754            do {
    755              r = SEGGER_RTT_GetKey();
    756            } while (r < 0);
    757            return r;
    758          }
    759          
    760          /*********************************************************************
    761          *
    762          *       SEGGER_RTT_HasKey
    763          *
    764          *  Function description
    765          *    Checks if at least one character for reading is available in the SEGGER RTT buffer.
    766          *
    767          *  Return value
    768          *    == 0 -     No characters are available to read.
    769          *    == 1 -     At least one character is available.
    770          *
    771          *  Notes
    772          *    (1) This function is only specified for accesses to RTT buffer 0
    773          */
    774          int SEGGER_RTT_HasKey(void) {
    775            unsigned RdOff;
    776            int r;
    777          
    778            INIT();
    779            RdOff = _SEGGER_RTT.aDown[0].RdOff;
    780            if (RdOff != _SEGGER_RTT.aDown[0].WrOff) {
    781              r = 1;
    782            } else {
    783              r = 0;
    784            }
    785            return r;
    786          }
    787          
    788          /*********************************************************************
    789          *
    790          *       SEGGER_RTT_HasData
    791          *
    792          *  Function description
    793          *    Check if there is data from the host in the given buffer.
    794          *
    795          *  Return value:
    796          *  ==0:  No data
    797          *  !=0:  Data in buffer
    798          *
    799          */
    800          unsigned SEGGER_RTT_HasData(unsigned BufferIndex) {
    801            SEGGER_RTT_BUFFER_DOWN* pRing;
    802            unsigned                v;
    803          
    804            pRing = &_SEGGER_RTT.aDown[BufferIndex];
    805            v = pRing->WrOff;
    806            return v - pRing->RdOff;
    807          }
    808          
    809          /*********************************************************************
    810          *
    811          *       SEGGER_RTT_AllocDownBuffer
    812          *
    813          *  Function description
    814          *    Run-time configuration of the next down-buffer (H->T).
    815          *    The next buffer, which is not used yet is configured.
    816          *    This includes: Buffer address, size, name, flags, ...
    817          *
    818          *  Parameters
    819          *    sName        Pointer to a constant name string.
    820          *    pBuffer      Pointer to a buffer to be used.
    821          *    BufferSize   Size of the buffer.
    822          *    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
    823          *
    824          *  Return value
    825          *    >= 0 - O.K. Buffer Index
    826          *     < 0 - Error
    827          */
    828          int SEGGER_RTT_AllocDownBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
    829            int BufferIndex;
    830          
    831            INIT();
    832            SEGGER_RTT_LOCK();
    833            BufferIndex = 0;
    834            do {
    835              if (_SEGGER_RTT.aDown[BufferIndex].pBuffer == NULL) {
    836                break;
    837              }
    838              BufferIndex++;
    839            } while (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers);
    840            if (BufferIndex < _SEGGER_RTT.MaxNumDownBuffers) {
    841              _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
    842              _SEGGER_RTT.aDown[BufferIndex].pBuffer      = pBuffer;
    843              _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
    844              _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
    845              _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
    846              _SEGGER_RTT.aDown[BufferIndex].Flags        = Flags;
    847            } else {
    848              BufferIndex = -1;
    849            }
    850            SEGGER_RTT_UNLOCK();
    851            return BufferIndex;
    852          }
    853          
    854          /*********************************************************************
    855          *
    856          *       SEGGER_RTT_AllocUpBuffer
    857          *
    858          *  Function description
    859          *    Run-time configuration of the next up-buffer (T->H).
    860          *    The next buffer, which is not used yet is configured.
    861          *    This includes: Buffer address, size, name, flags, ...
    862          *
    863          *  Parameters
    864          *    sName        Pointer to a constant name string.
    865          *    pBuffer      Pointer to a buffer to be used.
    866          *    BufferSize   Size of the buffer.
    867          *    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
    868          *
    869          *  Return value
    870          *    >= 0 - O.K. Buffer Index
    871          *     < 0 - Error
    872          */
    873          int SEGGER_RTT_AllocUpBuffer(const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
    874            int BufferIndex;
    875          
    876            INIT();
    877            SEGGER_RTT_LOCK();
    878            BufferIndex = 0;
    879            do {
    880              if (_SEGGER_RTT.aUp[BufferIndex].pBuffer == NULL) {
    881                break;
    882              }
    883              BufferIndex++;
    884            } while (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers);
    885            if (BufferIndex < _SEGGER_RTT.MaxNumUpBuffers) {
    886              _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
    887              _SEGGER_RTT.aUp[BufferIndex].pBuffer      = pBuffer;
    888              _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
    889              _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
    890              _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
    891              _SEGGER_RTT.aUp[BufferIndex].Flags        = Flags;
    892            } else {
    893              BufferIndex = -1;
    894            }
    895            SEGGER_RTT_UNLOCK();
    896            return BufferIndex;
    897          }
    898          
    899          /*********************************************************************
    900          *
    901          *       SEGGER_RTT_ConfigUpBuffer
    902          *
    903          *  Function description
    904          *    Run-time configuration of a specific up-buffer (T->H).
    905          *    Buffer to be configured is specified by index.
    906          *    This includes: Buffer address, size, name, flags, ...
    907          *
    908          *  Parameters
    909          *    BufferIndex  Index of the buffer to configure.
    910          *    sName        Pointer to a constant name string.
    911          *    pBuffer      Pointer to a buffer to be used.
    912          *    BufferSize   Size of the buffer.
    913          *    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
    914          *
    915          *  Return value
    916          *    >= 0 - O.K.
    917          *     < 0 - Error
    918          */
    919          int SEGGER_RTT_ConfigUpBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
    920            int r;
    921          
    922            INIT();
    923            if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
    924              SEGGER_RTT_LOCK();
    925              if (BufferIndex > 0u) {
    926                _SEGGER_RTT.aUp[BufferIndex].sName        = sName;
    927                _SEGGER_RTT.aUp[BufferIndex].pBuffer      = pBuffer;
    928                _SEGGER_RTT.aUp[BufferIndex].SizeOfBuffer = BufferSize;
    929                _SEGGER_RTT.aUp[BufferIndex].RdOff        = 0u;
    930                _SEGGER_RTT.aUp[BufferIndex].WrOff        = 0u;
    931              }
    932              _SEGGER_RTT.aUp[BufferIndex].Flags          = Flags;
    933              SEGGER_RTT_UNLOCK();
    934              r =  0;
    935            } else {
    936              r = -1;
    937            }
    938            return r;
    939          }
    940          
    941          /*********************************************************************
    942          *
    943          *       SEGGER_RTT_ConfigDownBuffer
    944          *
    945          *  Function description
    946          *    Run-time configuration of a specific down-buffer (H->T).
    947          *    Buffer to be configured is specified by index.
    948          *    This includes: Buffer address, size, name, flags, ...
    949          *
    950          *  Parameters
    951          *    BufferIndex  Index of the buffer to configure.
    952          *    sName        Pointer to a constant name string.
    953          *    pBuffer      Pointer to a buffer to be used.
    954          *    BufferSize   Size of the buffer.
    955          *    Flags        Operating modes. Define behavior if buffer is full (not enough space for entire message).
    956          *
    957          *  Return value
    958          *    >= 0  O.K.
    959          *     < 0  Error
    960          */
    961          int SEGGER_RTT_ConfigDownBuffer(unsigned BufferIndex, const char* sName, void* pBuffer, unsigned BufferSize, unsigned Flags) {
    962            int r;
    963          
    964            INIT();
    965            if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
    966              SEGGER_RTT_LOCK();
    967              if (BufferIndex > 0u) {
    968                _SEGGER_RTT.aDown[BufferIndex].sName        = sName;
    969                _SEGGER_RTT.aDown[BufferIndex].pBuffer      = pBuffer;
    970                _SEGGER_RTT.aDown[BufferIndex].SizeOfBuffer = BufferSize;
    971                _SEGGER_RTT.aDown[BufferIndex].RdOff        = 0u;
    972                _SEGGER_RTT.aDown[BufferIndex].WrOff        = 0u;
    973              }
    974              _SEGGER_RTT.aDown[BufferIndex].Flags          = Flags;
    975              SEGGER_RTT_UNLOCK();
    976              r =  0;
    977            } else {
    978              r = -1;
    979            }
    980            return r;
    981          }
    982          
    983          /*********************************************************************
    984          *
    985          *       SEGGER_RTT_SetNameUpBuffer
    986          *
    987          *  Function description
    988          *    Run-time configuration of a specific up-buffer name (T->H).
    989          *    Buffer to be configured is specified by index.
    990          *
    991          *  Parameters
    992          *    BufferIndex  Index of the buffer to renamed.
    993          *    sName        Pointer to a constant name string.
    994          *
    995          *  Return value
    996          *    >= 0  O.K.
    997          *     < 0  Error
    998          */
    999          int SEGGER_RTT_SetNameUpBuffer(unsigned BufferIndex, const char* sName) {
   1000            int r;
   1001          
   1002            INIT();
   1003            if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumUpBuffers) {
   1004              SEGGER_RTT_LOCK();
   1005              _SEGGER_RTT.aUp[BufferIndex].sName = sName;
   1006              SEGGER_RTT_UNLOCK();
   1007              r =  0;
   1008            } else {
   1009              r = -1;
   1010            }
   1011            return r;
   1012          }
   1013          
   1014          /*********************************************************************
   1015          *
   1016          *       SEGGER_RTT_SetNameDownBuffer
   1017          *
   1018          *  Function description
   1019          *    Run-time configuration of a specific Down-buffer name (T->H).
   1020          *    Buffer to be configured is specified by index.
   1021          *
   1022          *  Parameters
   1023          *    BufferIndex  Index of the buffer to renamed.
   1024          *    sName        Pointer to a constant name string.
   1025          *
   1026          *  Return value
   1027          *    >= 0  O.K.
   1028          *     < 0  Error
   1029          */
   1030          int SEGGER_RTT_SetNameDownBuffer(unsigned BufferIndex, const char* sName) {
   1031            int r;
   1032          
   1033            INIT();
   1034            if (BufferIndex < (unsigned)_SEGGER_RTT.MaxNumDownBuffers) {
   1035              SEGGER_RTT_LOCK();
   1036              _SEGGER_RTT.aDown[BufferIndex].sName = sName;
   1037              SEGGER_RTT_UNLOCK();
   1038              r =  0;
   1039            } else {
   1040              r = -1;
   1041            }
   1042            return r;
   1043          }
   1044          
   1045          /*********************************************************************
   1046          *
   1047          *       SEGGER_RTT_Init
   1048          *
   1049          *  Function description
   1050          *    Initializes the RTT Control Block.
   1051          *    Should be used in RAM targets, at start of the application.
   1052          *
   1053          */
   1054          void SEGGER_RTT_Init (void) {
   1055            INIT();
   1056          }
   1057          
   1058          /*********************************************************************
   1059          *
   1060          *       SEGGER_RTT_SetTerminal
   1061          *
   1062          *  Function description
   1063          *    Sets the terminal to be used for output on channel 0.
   1064          *
   1065          *  Parameters
   1066          *    TerminalId  Index of the terminal.
   1067          *
   1068          *  Return value
   1069          *    >= 0  O.K.
   1070          *     < 0  Error (e.g. if RTT is configured for non-blocking mode and there was no space in the buffer to set the new terminal Id)
   1071          */
   1072          int SEGGER_RTT_SetTerminal (char TerminalId) {
   1073            char                  ac[2];
   1074            SEGGER_RTT_BUFFER_UP* pRing;
   1075            unsigned Avail;
   1076            int r;
   1077            //
   1078            INIT();
   1079            //
   1080            r = 0;
   1081            ac[0] = 0xFFU;
   1082            if ((unsigned char)TerminalId < (unsigned char)sizeof(_aTerminalId)) { // We only support a certain number of channels
   1083              ac[1] = _aTerminalId[(unsigned char)TerminalId];
   1084              pRing = &_SEGGER_RTT.aUp[0];    // Buffer 0 is always reserved for terminal I/O, so we can use index 0 here, fixed
   1085              SEGGER_RTT_LOCK();    // Lock to make sure that no other task is writing into buffer, while we are and number of free bytes in buffer does not change downwards after checking and before writing
   1086              if ((pRing->Flags & SEGGER_RTT_MODE_MASK) == SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL) {
   1087                _ActiveTerminal = TerminalId;
   1088                _WriteBlocking(pRing, ac, 2u);
   1089              } else {                                                                            // Skipping mode or trim mode? => We cannot trim this command so handling is the same for both modes
   1090                Avail = _GetAvailWriteSpace(pRing);
   1091                if (Avail >= 2) {
   1092                  _ActiveTerminal = TerminalId;    // Only change active terminal in case of success
   1093                  _WriteNoCheck(pRing, ac, 2u);
   1094                } else {
   1095                  r = -1;
   1096                }
   1097              }
   1098              SEGGER_RTT_UNLOCK();
   1099            } else {
   1100              r = -1;
   1101            }
   1102            return r;
   1103          }
   1104          
   1105          /*********************************************************************
   1106          *
   1107          *       SEGGER_RTT_TerminalOut
   1108          *
   1109          *  Function description
   1110          *    Writes a string to the given terminal
   1111          *     without changing the terminal for channel 0.
   1112          *
   1113          *  Parameters
   1114          *    TerminalId   Index of the terminal.
   1115          *    s            String to be printed on the terminal.
   1116          *
   1117          *  Return value
   1118          *    >= 0 - Number of bytes written.
   1119          *     < 0 - Error.
   1120          *
   1121          */
   1122          int SEGGER_RTT_TerminalOut (char TerminalId, const char* s) {
   1123            int                   Status;
   1124            unsigned              FragLen;
   1125            unsigned              Avail;
   1126            SEGGER_RTT_BUFFER_UP* pRing;
   1127            //
   1128            INIT();
   1129            //
   1130            // Validate terminal ID.
   1131            //
   1132            if (TerminalId < (char)sizeof(_aTerminalId)) { // We only support a certain number of channels
   1133              //
   1134              // Get "to-host" ring buffer.
   1135              //
   1136              pRing = &_SEGGER_RTT.aUp[0];
   1137              //
   1138              // Need to be able to change terminal, write data, change back.
   1139              // Compute the fixed and variable sizes.
   1140              //
   1141              FragLen = strlen(s);
   1142              //
   1143              // How we output depends upon the mode...
   1144              //
   1145              SEGGER_RTT_LOCK();
   1146              Avail = _GetAvailWriteSpace(pRing);
   1147              switch (pRing->Flags & SEGGER_RTT_MODE_MASK) {
   1148              case SEGGER_RTT_MODE_NO_BLOCK_SKIP:
   1149                //
   1150                // If we are in skip mode and there is no space for the whole
   1151                // of this output, don't bother switching terminals at all.
   1152                //
   1153                if (Avail < (FragLen + 4u)) {
   1154                  Status = 0;
   1155                } else {
   1156                  _PostTerminalSwitch(pRing, TerminalId);
   1157                  Status = (int)_WriteBlocking(pRing, s, FragLen);
   1158                  _PostTerminalSwitch(pRing, _ActiveTerminal);
   1159                }
   1160                break;
   1161              case SEGGER_RTT_MODE_NO_BLOCK_TRIM:
   1162                //
   1163                // If we are in trim mode and there is not enough space for everything,
   1164                // trim the output but always include the terminal switch.  If no room
   1165                // for terminal switch, skip that totally.
   1166                //
   1167                if (Avail < 4u) {
   1168                  Status = -1;
   1169                } else {
   1170                  _PostTerminalSwitch(pRing, TerminalId);
   1171                  Status = (int)_WriteBlocking(pRing, s, (FragLen < (Avail - 4u)) ? FragLen : (Avail - 4u));
   1172                  _PostTerminalSwitch(pRing, _ActiveTerminal);
   1173                }
   1174                break;
   1175              case SEGGER_RTT_MODE_BLOCK_IF_FIFO_FULL:
   1176                //
   1177                // If we are in blocking mode, output everything.
   1178                //
   1179                _PostTerminalSwitch(pRing, TerminalId);
   1180                Status = (int)_WriteBlocking(pRing, s, FragLen);
   1181                _PostTerminalSwitch(pRing, _ActiveTerminal);
   1182                break;
   1183              default:
   1184                Status = -1;
   1185                break;
   1186              }
   1187              //
   1188              // Finish up.
   1189              //
   1190              SEGGER_RTT_UNLOCK();
   1191            } else {
   1192              Status = -1;
   1193            }
   1194            return Status;
   1195          }
   1196          
   1197          
   1198          /*************************** End of file ****************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      24   SEGGER_RTT_AllocDownBuffer
        24   -> _DoInit
      24   SEGGER_RTT_AllocUpBuffer
        24   -> _DoInit
      32   SEGGER_RTT_ConfigDownBuffer
        32   -> _DoInit
      32   SEGGER_RTT_ConfigUpBuffer
        32   -> _DoInit
      16   SEGGER_RTT_GetKey
        16   -> SEGGER_RTT_Read
       4   SEGGER_RTT_HasData
      16   SEGGER_RTT_HasKey
        16   -> _DoInit
       8   SEGGER_RTT_Init
         8   -> _DoInit
      24   SEGGER_RTT_Read
        24   -> SEGGER_RTT_ReadNoLock
      48   SEGGER_RTT_ReadNoLock
        48   -> _DoInit
        48   -> __aeabi_memcpy
      16   SEGGER_RTT_SetNameDownBuffer
        16   -> _DoInit
      16   SEGGER_RTT_SetNameUpBuffer
        16   -> _DoInit
      32   SEGGER_RTT_SetTerminal
        32   -> _DoInit
        32   -> _GetAvailWriteSpace
        32   -> _WriteBlocking
        32   -> _WriteNoCheck
      32   SEGGER_RTT_TerminalOut
        32   -> _DoInit
        32   -> _GetAvailWriteSpace
        32   -> _PostTerminalSwitch
        32   -> _WriteBlocking
        32   -> strlen
       8   SEGGER_RTT_WaitKey
         8   -> SEGGER_RTT_GetKey
      24   SEGGER_RTT_Write
        24   -> SEGGER_RTT_WriteNoLock
        24   -> _DoInit
      32   SEGGER_RTT_WriteNoLock
        32   -> _GetAvailWriteSpace
        32   -> _WriteBlocking
        32   -> _WriteNoCheck
      56   SEGGER_RTT_WriteSkipNoLock
        56   -> __aeabi_memcpy
      16   SEGGER_RTT_WriteString
        16   -> SEGGER_RTT_Write
        16   -> strlen
       8   _DoInit
         8   -> strcpy
       4   _GetAvailWriteSpace
      16   _PostTerminalSwitch
        16   -> _WriteBlocking
      40   _WriteBlocking
        40   -> __aeabi_memcpy
      40   _WriteNoCheck
        40   -> __aeabi_memcpy


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable16
       4  ??DataTable16_1
       4  ??DataTable16_2
       4  ??DataTable16_3
       4  ??DataTable16_4
       4  ??DataTable16_5
       4  ??DataTable16_6
       4  ??DataTable16_7
       4  ??DataTable3
      12  ?_0
       4  ?_1
       8  ?_2
     174  SEGGER_RTT_AllocDownBuffer
     170  SEGGER_RTT_AllocUpBuffer
     138  SEGGER_RTT_ConfigDownBuffer
     138  SEGGER_RTT_ConfigUpBuffer
      38  SEGGER_RTT_GetKey
      30  SEGGER_RTT_HasData
      48  SEGGER_RTT_HasKey
      16  SEGGER_RTT_Init
      42  SEGGER_RTT_Read
     186  SEGGER_RTT_ReadNoLock
      66  SEGGER_RTT_SetNameDownBuffer
      66  SEGGER_RTT_SetNameUpBuffer
     138  SEGGER_RTT_SetTerminal
     242  SEGGER_RTT_TerminalOut
      16  SEGGER_RTT_WaitKey
      56  SEGGER_RTT_Write
     128  SEGGER_RTT_WriteNoLock
     250  SEGGER_RTT_WriteSkipNoLock
      26  SEGGER_RTT_WriteString
       1  _ActiveTerminal
      98  _DoInit
      38  _GetAvailWriteSpace
      36  _PostTerminalSwitch
     120  _SEGGER_RTT
     130  _WriteBlocking
      98  _WriteNoCheck
      16  _aTerminalId
      16  _acDownBuffer
    1024  _acUpBuffer

 
 1 161 bytes in section .bss
    16 bytes in section .data
    24 bytes in section .rodata
 2 404 bytes in section .text
 
 2 404 bytes of CODE  memory
    24 bytes of CONST memory
 1 177 bytes of DATA  memory

Errors: none
Warnings: none
