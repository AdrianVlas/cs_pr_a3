###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       24/Mar/2017  12:54:59
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\v_A_shm\Mft.cpp
#    Command line =  
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\v_A_shm\Mft.cpp" -D USE_STDPERIPH_DRIVER -D STM32F2XX -D
#        USE_USB_OTG_FS -D SYSTEM_VIEWER_ENABLE -lc
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List" -lB
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List" --remarks -o
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --enable_multibytes --fpu=None
#        --dlib_config G:\PRG\IAR7_50_2\arm\INC\c\DLib_Config_Full.h -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\usb\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_OTG_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Core\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\"
#        -I "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\Config\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\OS\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\SEGGER\" -On --eec++ -I
#        G:\PRG\IAR7_50_2\arm\CMSIS\Include\ -D ARM_MATH_CM3
#    List file    =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List\Mft.lst
#    Object file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj\Mft.o
#
###############################################################################

G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working files\v_A_shm\Mft.cpp
      1          
      2          #include "Mft.h"
      3          
      4          
      5          
      6          
      7          
      8          
      9          
     10          
     11          
     12          CMft::CMft(void):CLUBase() {
     13          m_NodeTpause.lTmrVal = 0;
     14          m_NodeTpause.next    = 0;
     15          m_NodeTdelay.lTmrVal = 0;
     16          m_NodeTdelay.next    = 0;
     17          m_NodeTWork .lTmrVal = 0;
     18          m_NodeTWork .next    = 0;
     19          m_MftSuit.chTypeMft = 0;
     20          m_MftSuit.lTpause   = 0;
     21          m_MftSuit.lTdelay   = 0;
     22          m_MftSuit.lTWork    = 0;
     23          m_chLinkedTimers    = 0;
     24          m_chStateTpause     = 0;
     25          m_chStateTdelay     = 0;
     26          m_chStateTWork      = 0;
     27          
     28          
     29          }
     30          CMft::CMft(char chM,char chI){
     31          	chMaxIteratoin = chM;
     32          	chIteration = chI;
     33          	
     34          chNumInput  = static_cast<char>(shCLUMFT_x_y_AmtIn);//
     35          chNumOutput = static_cast<char>(shCLUMFT_x_y_AmtOut);
     36          	
     37          	
     38          
     39          m_NodeTpause.lTmrVal = 0;
     40          m_NodeTpause.next    = 0;
     41          m_NodeTdelay.lTmrVal = 0;
     42          m_NodeTdelay.next    = 0;
     43          m_NodeTWork .lTmrVal = 0;
     44          m_NodeTWork .next    = 0;
     45          m_MftSuit.chTypeMft = 0;
     46          m_MftSuit.lTpause   = 0;
     47          m_MftSuit.lTdelay   = 0;
     48          m_MftSuit.lTWork    = 0;
     49          m_chLinkedTimers    = 0;
     50          m_chStateTpause     = 0;
     51          m_chStateTdelay     = 0;
     52          m_chStateTWork      = 0;
     53          
     54          }
     55          CMft::~CMft(void) {
     56          }
     57          void CMft::UpdateCMft(void) {
     58          //Set Input parameters
     59          pIn = static_cast<void*>(arrPchIn);
     60          //Set OutPut parameters
     61          pOut = static_cast<void*>(arrOut);
     62          //LinkMftTimers();
     63          //pInit2LcVarArea->pCLUBase->shShemasIdLUStng =  STNG_LU_NOT;
     64          
     65          //Set Operation
     66          //Set Type Operation
     67          }
     68          
     69          
     70          long CMft::TpauseMft(long lActivKey) {
     71              
     72              register long *plTmrVal = &m_NodeTpause.lTmrVal;
     73              if (lActivKey) {
     74                  if (m_chStateTpause == 0) {
     75                      lActivKey = m_MftSuit.lTpause; //Load Timer
     76                      *plTmrVal = lActivKey;
     77                      if (*plTmrVal != lActivKey)
     78                          *plTmrVal = lActivKey; //Possible Clear in Int
     79                      m_chStateTpause = 1;
     80                  } else {
     81                      lActivKey = *plTmrVal;
     82                      if (lActivKey == 0) {
     83                          return 1; //End of Interval
     84                      }
     85                  }
     86                  
     87              } else {
     88                  ;
     89                  m_chStateTpause = 0;
     90                  *plTmrVal = 0; //m_NodeTpause.lTmrVal = 0;
     91              }
     92              return 0;
     93          }
     94          
     95          long CMft::TdelayMft(long lResetKey, long lInKey) {
     96              register long *plTmrVal = &m_NodeTdelay.lTmrVal;
     97          	
     98              if (lResetKey == 0) {
     99                  if (lInKey) {
    100                      lInKey = m_MftSuit.lTdelay;
    101                      *plTmrVal = lInKey;
    102                      if (*plTmrVal != lInKey)
    103                          *plTmrVal = lInKey; //lResetKey == 0!
    104          			m_chStateTdelay = 1;//Activated
    105                      return 1;
    106                 	
    107                  } else {
    108                      if (m_chStateTdelay == 1) {//Activated
    109                          lInKey = *plTmrVal;
    110                          if (lInKey != 0)
    111                              return 1; //
    112                          else {
    113                              lResetKey = 1;
    114                          }
    115                      }
    116          
    117                  }
    118              }
    119              if (lResetKey) {
    120                  m_chStateTdelay = 0;
    121                  *plTmrVal = 0;
    122              }
    123              return 0;
    124          }
    125          
    126          long CMft::TWorkMft(long lResetKey, long lInKey) {
    127              register long *plTmrVal = &m_NodeTWork .lTmrVal;
    128          	
    129              if (lResetKey == 0) {
    130                  if (lInKey) {
    131                      if (m_chStateTWork == 0) {
    132                          lInKey = m_MftSuit.lTWork;
    133                          *plTmrVal = lInKey;
    134                          if (*plTmrVal != lInKey)
    135                              *plTmrVal = lInKey;
    136                          m_chStateTWork = 1;
    137                          return 1;
    138                      } else {
    139                          lInKey = *plTmrVal;
    140                          if (lInKey != 0)
    141                              return 1; //
    142                      }
    143                  } else {
    144                      if (m_chStateTWork == 1) {//Activated
    145                          lInKey = *plTmrVal;
    146                          if (lInKey != 0)
    147                              return 1; //
    148                          else
    149                              lResetKey = 1;
    150                      }
    151                  }
    152              }
    153              if (lResetKey) {
    154                  m_chStateTWork = 0;
    155                  *plTmrVal = 0;
    156              }    
    157              return 0;
    158          }
    159          
    160          long CMft::LinkMftTimers(void) {
    161              register long i = 0;
    162              //Insert TpauseMft
    163              chGlSem++;
    164              
    165              if (PushTmrNode(&m_NodeTpause)) {//static_cast<void*>(
    166                  i++;
    167                  m_chLinkedTimers |= 2;
    168              }
    169              //Insert TdelayMft
    170              if (PushTmrNode(&m_NodeTdelay)) {//static_cast<void*>(
    171                  i++;
    172                  m_chLinkedTimers |= 4;
    173              }
    174              //Insert TWorkMft 
    175              if (PushTmrNode(&m_NodeTWork)) {//static_cast<void*>(
    176                  i++;
    177                  m_chLinkedTimers |= 8;
    178              }
    179              chGlSem--;
    180              return i;
    181          }
    182          
    183          void Mft_Op(void *pObj){
    184          
    185              register long i, j;
    186              //register char* pCh;
    187          	CMft& rCMft = *(static_cast<CMft*>(pObj));
    188          	i = static_cast<long>(*(rCMft.arrPchIn[0]));
    189          	j = rCMft.TpauseMft(i);
    190          	i = static_cast<long>(*(rCMft.arrPchIn[1]));//Reset
    191          	if(rCMft.m_MftSuit.chTypeMft == 1){
    192          		
    193          		i = rCMft.TWorkMft(i,j);
    194          	}
    195          	else{
    196          		i = rCMft.TdelayMft(i,j);
    197          	}
    198          rCMft.arrOut[0] = static_cast<char>(i);
    199          }
    200          
    201          
    202          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   CMft::CMft()
         8   -> CLUBase::subobject CLUBase()
      16   CMft::CMft(char, char)
        16   -> CLUBase::subobject CLUBase()
      16   CMft::LinkMftTimers()
        16   -> PushTmrNode
       4   CMft::TWorkMft(long, long)
       4   CMft::TdelayMft(long, long)
       0   CMft::TpauseMft(long)
       0   CMft::UpdateCMft()
       8   CMft::subobject CMft()
         8   -> CMft::CMft()
       8   CMft::subobject CMft(char, char)
         8   -> CMft::CMft(char, char)
       8   CMft::subobject ~CMft()
         8   -> CMft::~CMft()
       8   CMft::~CMft()
         8   -> CLUBase::subobject ~CLUBase()
      24   Mft_Op(void *)
        24   -> CMft::TWorkMft(long, long)
        24   -> CMft::TdelayMft(long, long)
        24   -> CMft::TpauseMft(long)


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable0
      80  CMft::CMft()
      96  CMft::CMft(char, char)
     108  CMft::LinkMftTimers()
     104  CMft::TWorkMft(long, long)
      84  CMft::TdelayMft(long, long)
      66  CMft::TpauseMft(long)
      14  CMft::UpdateCMft()
      12  CMft::subobject CMft()
      16  CMft::subobject CMft(char, char)
      12  CMft::subobject ~CMft()
      14  CMft::~CMft()
      68  Mft_Op(void *)

 
 678 bytes in section .text
 
 678 bytes of CODE memory

Errors: none
Warnings: none
