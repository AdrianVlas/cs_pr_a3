###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       24/Mar/2017  12:55:00
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\procedures.c
#    Command line =  
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\procedures.c" -D USE_STDPERIPH_DRIVER -D STM32F2XX -D
#        USE_USB_OTG_FS -D KEYBOARD_VER_1 -D SYSTEM_VIEWER_ENABLE -lc
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List" --remarks -o
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --enable_multibytes --fpu=None
#        --dlib_config G:\PRG\IAR7_50_2\arm\INC\c\DLib_Config_Full.h -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\usb\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_OTG_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Core\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\"
#        -I "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\Config\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\OS\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\SEGGER\" -On --use_c++_inline
#        --require_prototypes -I G:\PRG\IAR7_50_2\arm\CMSIS\Include\ -D
#        ARM_MATH_CM3
#    List file    =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List\procedures.lst
#    Object file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj\procedures.o
#
###############################################################################

G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working files\src\procedures.c
      1          #include "header.h"
      2          
      3          /*****************************************************/
      4          //Функція, яка визначає кількість біт затримки, який допускається між байтами у RS-485 згідно з визначеними настройками
      5          /*****************************************************/
      6          void calculate_namber_bit_waiting_for_rs_485(void)
      7          {
      8            unsigned int number_bits_rs_485_waiting_tmp = 10;
      9            
     10            //Підраховуємо кількість біт у байті
     11            if (settings_fix.pare_bit_RS485 > 0) number_bits_rs_485_waiting_tmp++;
     12            if (settings_fix.number_stop_bit_RS485 > 0) number_bits_rs_485_waiting_tmp++;
     13            
     14            //Врахування швидкості
     15            unsigned int multiplicator;
     16            switch (settings_fix.baud_RS485)
     17            {
     18            case 0:
     19              {
     20                multiplicator = 12; //9600
     21                break;
     22              }
     23            case 1:
     24              {
     25                multiplicator = 8;  //14400
     26                break;
     27              }
     28            case 2:
     29              {
     30                multiplicator = 6;  //19200
     31                break;
     32              }
     33            case 3:
     34              {
     35                multiplicator = 4;  //28800
     36                break;
     37              }
     38            case 4:
     39              {
     40                multiplicator = 3;  //38400
     41                break;
     42              }
     43            case 5:
     44              {
     45                multiplicator = 2;  //57600
     46                break;
     47              }
     48            default:
     49              {
     50                multiplicator = 1;  //115200
     51                break;
     52              }
     53            }
     54            number_bits_rs_485_waiting_tmp *= (multiplicator*settings_fix.time_out_1_RS485);
     55            number_bits_rs_485_waiting_tmp /= 10;
     56            
     57            number_bits_rs_485_waiting = number_bits_rs_485_waiting_tmp;
     58          }
     59          /*****************************************************/
     60          
     61          ///******************************************************
     62          //Відновлення триґерних функцій
     63          //******************************************************/
     64          //void restore_trigger_functions(unsigned int *active_functions_point)
     65          //{
     66          //  active_functions[RANG_DT1_OUT >> 5] |= _CHECK_SET_BIT(active_functions_point, RANG_DT1_OUT);
     67          //  active_functions[RANG_DT2_OUT >> 5] |= _CHECK_SET_BIT(active_functions_point, RANG_DT2_OUT);
     68          //  active_functions[RANG_DT3_OUT >> 5] |= _CHECK_SET_BIT(active_functions_point, RANG_DT3_OUT);
     69          //  active_functions[RANG_DT4_OUT >> 5] |= _CHECK_SET_BIT(active_functions_point, RANG_DT4_OUT);
     70          //}
     71          ///*****************************************************/
     72          
     73          /*****************************************************/
     74          //Функція зміни інформації по діагностиці
     75          /*****************************************************/
     76          void changing_diagnostyka_state(void)
     77          {
     78            /*****
     79            Визначаємо новий стан діагностики
     80            
     81            Алгоритм:
     82            - Копіюємо у тимчасові масиви біти, які треба скинути і які треба виставити у 
     83              діагностиці
     84            - Після цього копіювання більш пріоритетні ситстеми можуть добавляти (не 
     85              скидають ніколи!!!) нові біти у глобальні масиви
     86            - Біти , які ми будуть скидалися/встановлюватися очищаємо з глобальних масивів
     87              (якщо в процесі цього алгоритму більшпріоритетні системи добавили чи 
     88              добавлятимуть нові біти, то вони не скинуться, а опрацюються при наступному 
     89              виклику цієї функції)
     90          
     91            - Спочатку очищаємо біти а потім встановлюємо, бо фіксація події має більший 
     92              пріоритет за очищення
     93            *****/
     94            unsigned int clear_diagnostyka_tmp[3], set_diagnostyka_tmp[3];
     95            
     96            clear_diagnostyka_tmp[0] = clear_diagnostyka[0];
     97            clear_diagnostyka_tmp[1] = clear_diagnostyka[1];
     98            clear_diagnostyka_tmp[2] = clear_diagnostyka[2];
     99          
    100            set_diagnostyka_tmp[0] = set_diagnostyka[0];
    101            set_diagnostyka_tmp[1] = set_diagnostyka[1];
    102            set_diagnostyka_tmp[2] = set_diagnostyka[2];
    103              
    104            diagnostyka[0] &= (unsigned int)(~clear_diagnostyka_tmp[0]); 
    105            diagnostyka[0] |= set_diagnostyka_tmp[0]; 
    106          
    107            diagnostyka[1] &= (unsigned int)(~clear_diagnostyka_tmp[1]); 
    108            diagnostyka[1] |= set_diagnostyka_tmp[1]; 
    109          
    110            diagnostyka[2] &= (unsigned int)(~clear_diagnostyka_tmp[2]); 
    111            diagnostyka[2] |= set_diagnostyka_tmp[2]; 
    112            
    113            diagnostyka[2] &= USED_BITS_IN_LAST_INDEX; 
    114          
    115            clear_diagnostyka[0] &= (unsigned int)(~clear_diagnostyka_tmp[0]);
    116            clear_diagnostyka[1] &= (unsigned int)(~clear_diagnostyka_tmp[1]);
    117            clear_diagnostyka[2] &= (unsigned int)(~clear_diagnostyka_tmp[2]);
    118            
    119            set_diagnostyka[0] &= (unsigned int)(~set_diagnostyka_tmp[0]);
    120            set_diagnostyka[1] &= (unsigned int)(~set_diagnostyka_tmp[1]);
    121            set_diagnostyka[2] &= (unsigned int)(~set_diagnostyka_tmp[2]);
    122            /*****/
    123            
    124            //Визначаємо, чи відбулися зміни
    125            unsigned int value_changes[3], diagnostyka_now[3];
    126            /*
    127            Робимо копію тепершньої діагностики, бо ця функція працює на найнижчому пріоритеті,
    128            тому під час роботи може появитися нові значення, які ми не врахували у цій функції
    129            */
    130            diagnostyka_now[0] = diagnostyka[0];
    131            diagnostyka_now[1] = diagnostyka[1];
    132            diagnostyka_now[2] = diagnostyka[2];
    133            value_changes[0] = diagnostyka_before[0] ^ diagnostyka_now[0];
    134            value_changes[1] = diagnostyka_before[1] ^ diagnostyka_now[1];
    135            value_changes[2] = diagnostyka_before[2] ^ diagnostyka_now[2];
    136            
    137            /*
    138            У реєстраторі програмних подій має реєструватися тільки перехід з пасивного стану у активний
    139            таких подій як " Старт устр.    " і " Рестарт устр.  "
    140            тому перехід з активного у пачсивний ми ігноруємо і крім того затираємо біти, які його "засигналізували"
    141            */
    142            
    143            /*****/
    144            //Подія " Старт устр.    "
    145            /*****/
    146            if (_CHECK_SET_BIT(value_changes, EVENT_START_SYSTEM_BIT) != 0)
    147            {
    148              //Зафіксовано що подія " Старт устр.    " змінила свій стан
    149              if (_CHECK_SET_BIT(diagnostyka_now, EVENT_START_SYSTEM_BIT) == 0)
    150              {
    151                /*
    152                Новий стан події " Старт устр.    " є неактивний стан
    153                Тому робимо так, щоб ця подія не попала у реєстратор програмних подій таким операціями
    154                - знімаємо встановлений біт про зміну стану діагностики
    155                - знімаємо повідомлення, що у попередньому стані діагностики ця подія була активною
    156                - у текучому стані діагностики нічого міняти не треба, бо цей сигнал є неактивним
    157                */
    158                _CLEAR_BIT(value_changes, EVENT_START_SYSTEM_BIT);
    159                _CLEAR_BIT(diagnostyka_before, EVENT_START_SYSTEM_BIT);
    160              }
    161            }
    162            /*****/
    163            
    164            /*****/
    165            //Подія " Рестарт устр.  "
    166            /*****/
    167            if (_CHECK_SET_BIT(value_changes, EVENT_RESTART_SYSTEM_BIT) != 0)
    168            {
    169              //Зафіксовано що подія " Рестарт устр.  " змінила свій стан
    170              if (_CHECK_SET_BIT(diagnostyka_now, EVENT_RESTART_SYSTEM_BIT) == 0)
    171              {
    172                /*
    173                Новий стан події " Рестарт устр.  " є неактивний стан
    174                Тому робимо так, щоб ця подія не попала у реєстратор програмних подій таким операціями
    175                - знімаємо встановлений біт про зміну стану діагностики
    176                - знімаємо повідомлення, що у попередньому стані діагностики ця подія була активною
    177                - у текучому стані діагностики нічого міняти не треба, бо цей сигнал є неактивним
    178                */
    179                _CLEAR_BIT(value_changes, EVENT_RESTART_SYSTEM_BIT);
    180                _CLEAR_BIT(diagnostyka_before, EVENT_RESTART_SYSTEM_BIT);
    181              }
    182            }
    183            /*****/
    184          
    185            //Перевіряємо, чи треба виконувати дії поо зміні діагностики
    186            if (
    187                (value_changes[0] != 0) ||
    188                (value_changes[1] != 0) ||
    189                (value_changes[2] != 0)
    190               )
    191            {
    192              //Є біти, які треба встановити, або зняти
    193              
    194              /*****/
    195              //При можливості формуємо запис у реєстратор програмних помилок
    196              /*****/
    197              if (_CHECK_SET_BIT(diagnostyka, ERROR_PR_ERR_OVERLOAD_BIT) == 0)
    198              {
    199                /*
    200                Новий запис робимо тільки тоді, коли попередньо не було зафіксовано 
    201                переповнення буферу, інакше чикаємо, поки запис у реєстратор програмних подій
    202                знімить подію про переповнення буферу
    203                */
    204                
    205                //Визначаємо кількість доступних комірок у буфері для реєстратора програмних подій
    206                int number_empty_cells;
    207                unsigned int head = head_fifo_buffer_pr_err_records, tail = tail_fifo_buffer_pr_err_records;
    208                number_empty_cells = (int)(((unsigned int)tail) - ((unsigned int)head));
    209                while (number_empty_cells <= 0) number_empty_cells += MAX_NUMBER_RECORDS_PR_ERR_INTO_BUFFER;
    210                if (number_empty_cells == 1)
    211                {
    212                  //Це є остання вільна комірка, то помічаємо, що з цим записом відбувається повне заповнення буферу
    213                  _SET_BIT(diagnostyka, ERROR_PR_ERR_OVERLOAD_BIT);
    214                  /*
    215                  відбулася зміна стану діагностики, яку треба врахувати у даному записфі ,тому
    216                  робимо повторноу копію тепершньої діагностики, яка може врахувати і ті зміни які відбулися
    217                  між операціями копіювання стану діагностики на початку цієї функції і
    218                  операцією, як зараз ми будемо виконувати
    219                  */
    220                  diagnostyka_now[0] = diagnostyka[0];
    221                  diagnostyka_now[1] = diagnostyka[1];
    222                  diagnostyka_now[2] = diagnostyka[2];
    223                  
    224                  //Підраховуємо нову кількість змін в діагностиці
    225                  value_changes[0] = diagnostyka_before[0] ^ diagnostyka_now[0];
    226                  value_changes[1] = diagnostyka_before[1] ^ diagnostyka_now[1];
    227                  value_changes[2] = diagnostyka_before[2] ^ diagnostyka_now[2];
    228                }
    229          
    230                //Вираховуємо кількість змін сигналів
    231                unsigned int number_changes = 0;
    232                for(unsigned int i = 0; i < (8*sizeof(value_changes)); i++)
    233                {
    234                  if (_CHECK_SET_BIT(value_changes, i) != 0) number_changes++;
    235                }
    236          
    237                if(number_changes != 0)
    238                {
    239                  /*
    240                  теоретично може бути ситуація, що ми знімали повідомлення про переповнення буферу
    241                  FIFO для записів реєстратора програмних подій  і це була єдина зміна, али при цьому
    242                  є тільки одна вільна комірка, тому ми знову виставили повідомлення про переповнення.
    243                  Тому ми не можемо зняти це повідомлення - тому і не можемо робити нового запису, 
    244                  бо фактично і зміни ніякої нема
    245                  */
    246                  
    247                  //Визначаємо індекс у масиві буферу програмних помилок з якого трбе почати заповнювати дані
    248                  unsigned int index_into_buffer_pr_err = head*SIZE_ONE_RECORD_PR_ERR;
    249                
    250                  //Помічаємо мітку початку запису
    251                  buffer_pr_err_records[index_into_buffer_pr_err + 0] = LABEL_START_RECORD_PR_ERR;
    252          
    253                  //Час фіксації зміни у діагностиці
    254                  if(
    255                     (_CHECK_SET_BIT(diagnostyka, EVENT_START_SYSTEM_BIT   ) == 0) &&
    256                     (_CHECK_SET_BIT(diagnostyka, EVENT_RESTART_SYSTEM_BIT ) == 0) &&
    257                     (_CHECK_SET_BIT(diagnostyka, EVENT_STOP_SYSTEM_BIT    ) == 0)
    258                    )
    259                  {
    260                    //Вже відбулося перше зчитуванння часу - тобто системний час у нас є
    261                    unsigned char *label_to_time_array;
    262                    if (copying_time == 0) label_to_time_array = time;
    263                    else label_to_time_array = time_copy;
    264                    for(unsigned int i = 0; i < 7; i++) buffer_pr_err_records[index_into_buffer_pr_err + 1 + i] = *(label_to_time_array + i);
    265                  }
    266                  else
    267                  {
    268                    //Ще не відбулося перше зчитуванння часу - тому покищо ці поля записуємо числом 0xff, а потім, коли системний час зчитається, то ми це поле обновимо
    269                    for(unsigned int i = 0; i < 7; i++)  buffer_pr_err_records[index_into_buffer_pr_err + 1 + i] = 0xff;
    270                  }
    271          
    272                  buffer_pr_err_records[index_into_buffer_pr_err + 8] = number_changes & 0xff;
    273                
    274                  //Записуємо попередній стан діагностики
    275                  buffer_pr_err_records[index_into_buffer_pr_err + 9 ] =  diagnostyka_before[0]        & 0xff;
    276                  buffer_pr_err_records[index_into_buffer_pr_err + 10] = (diagnostyka_before[0] >> 8 ) & 0xff;
    277                  buffer_pr_err_records[index_into_buffer_pr_err + 11] = (diagnostyka_before[0] >> 16) & 0xff;
    278                  buffer_pr_err_records[index_into_buffer_pr_err + 12] = (diagnostyka_before[0] >> 24) & 0xff;
    279                  buffer_pr_err_records[index_into_buffer_pr_err + 13] =  diagnostyka_before[1]        & 0xff;
    280                  buffer_pr_err_records[index_into_buffer_pr_err + 14] = (diagnostyka_before[1] >> 8 ) & 0xff;
    281                  buffer_pr_err_records[index_into_buffer_pr_err + 15] = (diagnostyka_before[1] >> 16) & 0xff;
    282                  buffer_pr_err_records[index_into_buffer_pr_err + 16] = (diagnostyka_before[1] >> 24) & 0xff;
    283                  buffer_pr_err_records[index_into_buffer_pr_err + 17] =  diagnostyka_before[2]        & 0xff;
    284                  buffer_pr_err_records[index_into_buffer_pr_err + 18] = (diagnostyka_before[2] >> 8 ) & 0xff;
    285                  buffer_pr_err_records[index_into_buffer_pr_err + 19] = (diagnostyka_before[2] >> 16) & 0xff;
    286          
    287                  //Записуємо теперішній стан діагностики
    288                  buffer_pr_err_records[index_into_buffer_pr_err + 20] =  diagnostyka_now[0]        & 0xff;
    289                  buffer_pr_err_records[index_into_buffer_pr_err + 21] = (diagnostyka_now[0] >> 8 ) & 0xff;
    290                  buffer_pr_err_records[index_into_buffer_pr_err + 22] = (diagnostyka_now[0] >> 16) & 0xff;
    291                  buffer_pr_err_records[index_into_buffer_pr_err + 23] = (diagnostyka_now[0] >> 24) & 0xff;
    292                  buffer_pr_err_records[index_into_buffer_pr_err + 24] =  diagnostyka_now[1]        & 0xff;
    293                  buffer_pr_err_records[index_into_buffer_pr_err + 25] = (diagnostyka_now[1] >> 8 ) & 0xff;
    294                  buffer_pr_err_records[index_into_buffer_pr_err + 26] = (diagnostyka_now[1] >> 16) & 0xff;
    295                  buffer_pr_err_records[index_into_buffer_pr_err + 27] = (diagnostyka_now[1] >> 24) & 0xff;
    296                  buffer_pr_err_records[index_into_buffer_pr_err + 28] =  diagnostyka_now[2]        & 0xff;
    297                  buffer_pr_err_records[index_into_buffer_pr_err + 29] = (diagnostyka_now[2] >> 8 ) & 0xff;
    298                  buffer_pr_err_records[index_into_buffer_pr_err + 30] = (diagnostyka_now[2] >> 16) & 0xff;
    299                  
    300                  /*
    301                  У реєстраторі програмних подій має реєструватися тільки перехід з пасивного стану у активний
    302                  таких події як " Останов.устр.  " і ця подія не має бути активною у текучій діагностиці,
    303                  бо це, фактично, подія, яка мала місце до останнього включення приладу в роботу.
    304                  Тобто це подія "попереднього сеансу роботи"
    305                  тому перехід з пасивного у фіксуємо ми фіксуємо і зразу затираємо цей біт у теперішній діагностіці,
    306                  яка після цього буде зкомійомана у масив. який відповідає за попередній стан діагностики, так і у масив
    307                  діагностики, який відповідає за текучий стан подій діагностики
    308                  */
    309                  if (_CHECK_SET_BIT(value_changes, EVENT_STOP_SYSTEM_BIT) != 0)
    310                  {
    311                    /*
    312                    Cтан події " Останов.устр.  " змінився (допускається нашим програмним забезпеченням
    313                    зміна з пасивного стану у активний стан)
    314                    Тому робимо такі операції
    315                    - знімаємо встановлений біт у масиві, який зараз буде копіюватися у масив попереднього стану
    316                    - знімаємо встановлений біт у масиві, який відповідає за текучий стан подій діагностики
    317                    */
    318                    _CLEAR_BIT(diagnostyka_now, EVENT_STOP_SYSTEM_BIT);
    319                    _CLEAR_BIT(diagnostyka, EVENT_STOP_SYSTEM_BIT);
    320                  }
    321          
    322                  //Фіксуємо попередній стан, який ми вже записали і відносно якого будемо визначати нові зміни
    323                  diagnostyka_before[0] = diagnostyka_now[0];
    324                  diagnostyka_before[1] = diagnostyka_now[1];
    325                  diagnostyka_before[2] = diagnostyka_now[2];
    326          
    327                  //Підготовлюємося до запуску запису у реєстратор програмних подій
    328                    unsigned int next_index_into_fifo_buffer = head + 1;
    329                    while(next_index_into_fifo_buffer >= MAX_NUMBER_RECORDS_PR_ERR_INTO_BUFFER) next_index_into_fifo_buffer -= MAX_NUMBER_RECORDS_PR_ERR_INTO_BUFFER;
    330                    
    331                    //Встановлюємо нове значення голови буфера FIFO 
    332                    head_fifo_buffer_pr_err_records = next_index_into_fifo_buffer;
    333                }
    334              }
    335              /*****/
    336            }
    337          }
    338          /*****************************************************/
    339          
    340          /*****************************************************/
    341          //Підрахунок кількості втановлених одиничок у області пам'яті початок якої визначається вказівником source
    342          /*****************************************************/
    343          unsigned int count_number_set_bit(unsigned int* source, unsigned int total_number)
    344          {
    345            unsigned int count = 0;
    346            unsigned int offset, shift;
    347            
    348            for (unsigned int i = 0; i < total_number; i++)  
    349            {
    350              offset = i >> 5; //Це є, фактично, ділення на 32
    351              shift  = (i & (32 - 1)); //Це є, фактично, визначення остачі від ділення на 32
    352              if ( ( (*(source + offset))  & ((unsigned int)(1 << shift)) ) != 0 ) count++;
    353            }
    354          
    355            return count;
    356          }
    357          /*****************************************************/
    358          
    359          /*****************************************************/
    360          //Контроль достовірності конфігурації
    361          /*****************************************************/
    362          void control_config(unsigned int modified)
    363          {
    364            uint8_t crc_config_tmp = 0, temp_value;
    365            uint8_t  *point_1 = (unsigned char*)(&current_config_prt); // з цими даними працюють захисти
    366            uint8_t  *point_2 = (unsigned char*)(&current_config);
    367            unsigned int i = 0, difference = 0;
    368            while ((difference == 0) && (i < sizeof(__CONFIG)))
    369            {
    370              //Контроль контрольної суми кофігурації для захистів
    371              temp_value = *(point_1++);
    372              crc_config_tmp += temp_value;
    373          
    374              //Контроль конфігурації для захистів з конфігурацією-контейнером
    375              if ((modified & MASKA_CHANGED_CONFIGURATION) == 0)
    376              {
    377                if (temp_value != *(point_2++)) difference = 0xff;
    378              }
    379          
    380              i++;
    381            }
    382            
    383            if ((difference == 0) && (crc_config == crc_config_tmp))
    384            {
    385              //Контроль достовірності конфігурації пройшов успішно
    386              
    387              //Скидаємо повідомлення у слові діагностики
    388              _SET_BIT(clear_diagnostyka, ERROR_CONFIG_EEPROM_CONTROL_BIT);
    389            }
    390            else
    391            {
    392              //Контроль достовірності конфігурації не пройшов
    393          
    394              //Виствляємо повідомлення у слові діагностики
    395              _SET_BIT(set_diagnostyka, ERROR_CONFIG_EEPROM_CONTROL_BIT);
    396            }
    397          }
    398          /*****************************************************/
    399          
    400          /*****************************************************/
    401          //Контроль достовірності настройок
    402          /*****************************************************/
    403          void control_settings(unsigned int modified)
    404          {
    405            uint8_t crc_settings_tmp = 0, temp_value;
    406            uint8_t  *point_1 = NULL, *point_2 = NULL; 
    407            unsigned int difference = 0;
    408          
    409            size_t size_of_block = 0;
    410            uint32_t n_item = 0;
    411            unsigned int item = 0, shift = 0;
    412            enum _id_fb block = _ID_FB_FIRST_ALL;
    413            while(
    414                  (difference == 0) &&
    415                  (block < _ID_FB_LAST_ALL)
    416                 )
    417            {
    418              if (shift == 0)
    419              {
    420                //Визначаємо розмір нового блоку
    421                switch (block)
    422                {
    423                case ID_FB_CONTROL_BLOCK:
    424                  {
    425                    if (item == 0)
    426                    {
    427                      size_of_block = sizeof(__SETTINGS_FIX);
    428                      n_item = 1;
    429                    }
    430                    
    431                    if (modified == 0) point_2 = (uint8_t *)(&settings_fix);
    432                    point_1 = (uint8_t *)(&settings_fix_prt);
    433                    
    434                    break;
    435                  }
    436                case ID_FB_INPUT:
    437                  {
    438                    if (item == 0)
    439                    {
    440                      size_of_block = sizeof(__settings_for_INPUT);
    441                      n_item = current_config_prt.n_input;
    442                    }
    443          
    444                    if  (modified == 0) point_2 = (uint8_t *)(((__settings_for_INPUT*)sca_of_p[ID_FB_INPUT - _ID_FB_FIRST_VAR]) + item);
    445                    point_1 = (uint8_t *)(&(((__LN_INPUT*)spca_of_p_prt[ID_FB_INPUT - _ID_FB_FIRST_VAR]) + item)->settings) ;
    446          
    447                    break;
    448                  }
    449                case ID_FB_OUTPUT:
    450                  {
    451                    if (item == 0)
    452                    {
    453                      size_of_block = sizeof(__settings_for_OUTPUT);
    454                      n_item = current_config_prt.n_output;
    455                    }
    456          
    457                    if  (modified == 0) point_2 = (uint8_t *)(((__settings_for_OUTPUT*)sca_of_p[ID_FB_OUTPUT - _ID_FB_FIRST_VAR]) + item);
    458                    point_1 = (uint8_t *)(&(((__LN_OUTPUT*)spca_of_p_prt[ID_FB_OUTPUT - _ID_FB_FIRST_VAR]) + item)->settings) ;
    459          
    460                    break;
    461                  }
    462                case ID_FB_LED:
    463                  {
    464                    if (item == 0)
    465                    {
    466                      size_of_block = sizeof(__settings_for_LED);
    467                      n_item = current_config_prt.n_led;
    468                    }
    469          
    470                    if  (modified == 0) point_2 = (uint8_t *)(((__settings_for_LED*)sca_of_p[ID_FB_LED - _ID_FB_FIRST_VAR]) + item);
    471                    point_1 = (uint8_t *)(&(((__LN_LED*)spca_of_p_prt[ID_FB_LED - _ID_FB_FIRST_VAR]) + item)->settings) ;
    472          
    473                    break;
    474                  }
    475                case ID_FB_ALARM:
    476                  {
    477                    if (item == 0)
    478                    {
    479                      size_of_block = sizeof(__settings_for_ALARM);
    480                      n_item = current_config_prt.n_alarm;
    481                    }
    482          
    483                    if  (modified == 0) point_2 = (uint8_t *)(((__settings_for_ALARM*)sca_of_p[ID_FB_ALARM - _ID_FB_FIRST_VAR]) + item);
    484                    point_1 = (uint8_t *)(&(((__LN_ALARM*)spca_of_p_prt[ID_FB_ALARM - _ID_FB_FIRST_VAR]) + item)->settings) ;
    485          
    486                    break;
    487                  }
    488                case ID_FB_GROUP_ALARM:
    489                  {
    490                    if (item == 0)
    491                    {
    492                      size_of_block = sizeof(__settings_for_GROUP_ALARM);
    493                      n_item = current_config_prt.n_group_alarm;
    494                    }
    495          
    496                    if  (modified == 0) point_2 = (uint8_t *)(((__settings_for_GROUP_ALARM*)sca_of_p[ID_FB_GROUP_ALARM - _ID_FB_FIRST_VAR]) + item);
    497                    point_1 = (uint8_t *)(&(((__LN_GROUP_ALARM*)spca_of_p_prt[ID_FB_GROUP_ALARM - _ID_FB_FIRST_VAR]) + item)->settings) ;
    498          
    499                    break;
    500                  }
    501                case ID_FB_AND:
    502                  {
    503                    if (item == 0)
    504                    {
    505                      size_of_block = sizeof(__settings_for_AND);
    506                      n_item = current_config_prt.n_and;
    507                    }
    508          
    509                    if  (modified == 0) point_2 = (uint8_t *)(((__settings_for_AND*)sca_of_p[ID_FB_AND - _ID_FB_FIRST_VAR]) + item);
    510                    point_1 = (uint8_t *)(&(((__LN_AND*)spca_of_p_prt[ID_FB_AND - _ID_FB_FIRST_VAR]) + item)->settings) ;
    511          
    512                    break;
    513                  }
    514                case ID_FB_OR:
    515                  {
    516                    if (item == 0)
    517                    {
    518                      size_of_block = sizeof(__settings_for_OR);
    519                      n_item = current_config_prt.n_or;
    520                    }
    521          
    522                    if  (modified == 0) point_2 = (uint8_t *)(((__settings_for_OR*)sca_of_p[ID_FB_OR - _ID_FB_FIRST_VAR]) + item);
    523                    point_1 = (uint8_t *)(&(((__LN_OR*)spca_of_p_prt[ID_FB_OR - _ID_FB_FIRST_VAR]) + item)->settings) ;
    524          
    525                    break;
    526                  }
    527                case ID_FB_XOR:
    528                  {
    529                    if (item == 0)
    530                    {
    531                      size_of_block = sizeof(__settings_for_XOR);
    532                      n_item = current_config_prt.n_xor;
    533                    }
    534          
    535                    if  (modified == 0) point_2 = (uint8_t *)(((__settings_for_XOR*)sca_of_p[ID_FB_XOR - _ID_FB_FIRST_VAR]) + item);
    536                    point_1 = (uint8_t *)(&(((__LN_XOR*)spca_of_p_prt[ID_FB_XOR - _ID_FB_FIRST_VAR]) + item)->settings) ;
    537          
    538                    break;
    539                  }
    540                case ID_FB_NOT:
    541                  {
    542                    if (item == 0)
    543                    {
    544                      size_of_block = sizeof(__settings_for_NOT);
    545                      n_item = current_config_prt.n_not;
    546                    }
    547          
    548                    if  (modified == 0) point_2 = (uint8_t *)(((__settings_for_NOT*)sca_of_p[ID_FB_NOT - _ID_FB_FIRST_VAR]) + item);
    549                    point_1 = (uint8_t *)(&(((__LN_NOT*)spca_of_p_prt[ID_FB_NOT - _ID_FB_FIRST_VAR]) + item)->settings) ;
    550          
    551                    break;
    552                  }
    553                case ID_FB_TIMER:
    554                  {
    555                    if (item == 0)
    556                    {
    557                      size_of_block = sizeof(__settings_for_TIMER);
    558                      n_item = current_config_prt.n_timer;
    559                    }
    560          
    561                    if  (modified == 0) point_2 = (uint8_t *)(((__settings_for_TIMER*)sca_of_p[ID_FB_TIMER - _ID_FB_FIRST_VAR]) + item);
    562                    point_1 = (uint8_t *)(&(((__LN_TIMER*)spca_of_p_prt[ID_FB_TIMER - _ID_FB_FIRST_VAR]) + item)->settings);
    563          
    564                    break;
    565                  }
    566                case ID_FB_TRIGGER:
    567                  {
    568                    if (item == 0)
    569                    {
    570                      size_of_block = sizeof(__settings_for_TRIGGER);
    571                      n_item = current_config_prt.n_trigger;
    572                    }
    573          
    574                    if  (modified == 0) point_2 = (uint8_t *)(((__settings_for_TRIGGER*)sca_of_p[ID_FB_TRIGGER - _ID_FB_FIRST_VAR]) + item);
    575                    point_1 = (uint8_t *)(&(((__LN_TRIGGER*)spca_of_p_prt[ID_FB_TRIGGER - _ID_FB_FIRST_VAR]) + item)->settings) ;
    576          
    577                    break;
    578                  }
    579                case ID_FB_MEANDER:
    580                  {
    581                    if (item == 0)
    582                    {
    583                      size_of_block = sizeof(__settings_for_MEANDER);
    584                      n_item = current_config_prt.n_meander;
    585                    }
    586          
    587                    if  (modified == 0) point_2 = (uint8_t *)(((__settings_for_MEANDER*)sca_of_p[ID_FB_MEANDER - _ID_FB_FIRST_VAR]) + item);
    588                    point_1 = (uint8_t *)(&(((__LN_MEANDER*)spca_of_p_prt[ID_FB_MEANDER - _ID_FB_FIRST_VAR]) + item)->settings) ;
    589          
    590                    break;
    591                  }
    592                default:
    593                  {
    594                    //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
    595                    total_error_sw_fixed(5);
    596                  }
    597                }
    598              }
    599                
    600              if ((size_of_block != 0) && (n_item != 0))
    601              {
    602                //Контроль контрольної суми налаштувань для захистів
    603                temp_value = *(point_1 + shift);
    604                crc_settings_tmp += temp_value;
    605          
    606                //Контроль налаштувань для захистів з налаштуваннями-контейнером
    607                if  (modified == 0)
    608                {
    609                  if (point_2 != NULL)
    610                  {
    611                    if (temp_value != *(point_2 + shift)) difference = 0xff;
    612                  }
    613                  else
    614                  {
    615                    //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
    616                    total_error_sw_fixed(61);
    617                  }
    618                }
    619                    
    620                if ((++shift) >= size_of_block)
    621                {
    622                  shift = 0;
    623                  if ((++item) >= n_item)
    624                  {
    625                    item = 0;
    626                    block++;
    627                    size_of_block = 0;
    628                    n_item = 0;
    629                  }
    630                }
    631              }
    632              else 
    633              {
    634                size_of_block = 0;
    635                n_item = 0;
    636                    
    637                shift = 0;
    638                item = 0;
    639                block++;
    640              }
    641            }
    642            
    643            if ((difference == 0) && (crc_settings == crc_settings_tmp))
    644            {
    645              //Контроль достовірності таблиці настройок пройшов успішно
    646              
    647              //Скидаємо повідомлення у слові діагностики
    648              _SET_BIT(clear_diagnostyka, ERROR_SETTINGS_EEPROM_CONTROL_BIT);
    649            }
    650            else
    651            {
    652              //Контроль достовірності таблиці настройок не пройшов
    653          
    654              //Виствляємо повідомлення у слові діагностики
    655              _SET_BIT(set_diagnostyka, ERROR_SETTINGS_EEPROM_CONTROL_BIT);
    656            }
    657          }
    658          /*****************************************************/
    659          
    660          /*****************************************************/
    661          //Контроль достовірності юстування
    662          /*****************************************************/
    663          void control_ustuvannja(void)
    664          {
    665            unsigned char crc_ustuvannja_tmp = 0, temp_value_1, temp_value_2;
    666            unsigned char  *point_1; 
    667            unsigned char  *point_2; 
    668            unsigned int i = 0, difference = 0;
    669          
    670            /*
    671            У контрольу суму входить індетифікатор типу набору юстуючих коефіцієнтів,
    672            який займає розмір типу unsigned int
    673            */
    674            unsigned int adjustment_id_tmp = ADJUSTMENT_ID;
    675            point_1 = (unsigned char*)(&adjustment_id_tmp); 
    676            while (i < sizeof(unsigned int))
    677            {
    678              temp_value_1 = *(point_1);
    679              crc_ustuvannja_tmp += temp_value_1;
    680              point_1++;
    681              i++;
    682            }
    683            
    684            point_1 = (unsigned char*)(&ustuvannja); 
    685            point_2 = (unsigned char*)(&ustuvannja_meas);
    686            i = 0;
    687            while ((difference == 0) && (i < sizeof(ustuvannja)))
    688            {
    689              temp_value_1 = *(point_1);
    690              temp_value_2 = *(point_2);
    691              crc_ustuvannja_tmp += temp_value_1;
    692              if (temp_value_1 != temp_value_2) difference = 0xff;
    693              point_1++;
    694              point_2++;
    695              i++;
    696            }
    697          
    698            /*
    699            Не треба контролювати ідентичність серійног номеру, який працює з вимірювально системою,
    700            чи системою захистів, чи ще якоюсь високопріоритетною і високонадійною від завад системою,
    701            бо його просто не існує
    702            */
    703            point_1 = (unsigned char*)(&serial_number_dev); 
    704            i = 0;
    705            while ((difference == 0) && (i < sizeof(serial_number_dev)))
    706            {
    707              temp_value_1 = *(point_1);
    708              crc_ustuvannja_tmp += temp_value_1;
    709              point_1++;
    710              i++;
    711            }
    712            
    713            if ((difference == 0) && (crc_ustuvannja == crc_ustuvannja_tmp))
    714            {
    715              //Контроль достовірності юстування пройшов успішно
    716              
    717              //Скидаємо повідомлення у слові діагностики
    718              _SET_BIT(clear_diagnostyka, ERROR_USTUVANNJA_EEPROM_CONTROL_BIT);
    719            }
    720            else
    721            {
    722              //Контроль достовірності юстування не пройшов
    723          
    724              //Виствляємо повідомлення у слові діагностики
    725              _SET_BIT(set_diagnostyka, ERROR_USTUVANNJA_EEPROM_CONTROL_BIT);
    726            }
    727          }
    728          /*****************************************************/
    729          
    730          /*****************************************************/
    731          //Контроль достовірності триґерної інформації
    732          /*****************************************************/
    733          //void control_trg_func(void)
    734          //{
    735          //  unsigned char crc_trg_func_tmp = 0, temp_value_1;
    736          //  unsigned char  *point; 
    737          //  unsigned int i;
    738          //  
    739          //  point = (unsigned char*)(trigger_active_functions_ctrl);
    740          //  i = 0;  
    741          //  while (i < sizeof(trigger_active_functions_ctrl))
    742          //  {
    743          //    temp_value_1 = *(point);
    744          //    crc_trg_func_tmp += temp_value_1;
    745          //    point++;
    746          //    i++;
    747          //  }
    748          //  
    749          //  if (crc_trg_func == crc_trg_func_tmp)
    750          //  {
    751          //    //Контроль достовірності юстування пройшов успішно
    752          //    
    753          //    //Скидаємо повідомлення у слові діагностики
    754          //    _SET_BIT(clear_diagnostyka, ERROR_TRG_FUNC_EEPROM_CONTROL_BIT);
    755          //  }
    756          //  else
    757          //  {
    758          //    //Контроль достовірності юстування не пройшов
    759          //
    760          //    //Виствляємо повідомлення у слові діагностики
    761          //    _SET_BIT(set_diagnostyka, ERROR_TRG_FUNC_EEPROM_CONTROL_BIT);
    762          //  }
    763          //}
    764          /*****************************************************/
    765          
    766          /*****************************************************/
    767          //Контроль достовірності інформації по реєстраторах
    768          /*****************************************************/
    769          unsigned int control_info_rejestrator(__INFO_REJESTRATOR* info_rejestrator_point, unsigned char crc_info_rejestrator)
    770          {
    771            unsigned int result;
    772            unsigned char crc_info_rejestrator_tmp = 0, temp_value_1;
    773            unsigned char  *point = (unsigned char*)(info_rejestrator_point); 
    774            unsigned int i = 0;
    775            while (i < sizeof(__INFO_REJESTRATOR))
    776            {
    777              temp_value_1 = *(point);
    778              crc_info_rejestrator_tmp += temp_value_1;
    779              point++;
    780              i++;
    781            }
    782            
    783            if (crc_info_rejestrator == crc_info_rejestrator_tmp)
    784            {
    785              //Контроль достовірності реєстратора пройшов успішно
    786              result = 1;    
    787            }
    788            else
    789            {
    790              //Контроль достовірності реєстратора не пройшов
    791              result = 0;    
    792            }
    793            
    794            return result;
    795          }
    796          /*****************************************************/
    797          
    798          /*****************************************************/
    799          //Визначення номеру місяця з константи __DATE__
    800          /*****************************************************/
    801          int str_to_int_DATE_Mmm(void)
    802          {
    803            static const char month_names[12*3] = "JanFebMarAprMayJunJulAugSepOctNovDec";
    804            
    805            int i = 0;
    806            while(i < 12)
    807            {
    808              if (
    809                  (month_names[3*i + 0] == __DATE__[0]) &&
    810                  (month_names[3*i + 1] == __DATE__[1]) &&
    811                  (month_names[3*i + 2] == __DATE__[2])
    812                 )
    813              {
    814                break;
    815              }
    816              
    817              i++;
    818            } 
    819            
    820            if (i < 12)
    821            { 
    822              i += 1; /*щоб нумерація місяців ішла з "1", а не з "0"*/
    823              return ((i / 10) << 4) + (i % 10);
    824            }
    825            else return 0;
    826          }
    827          /*****************************************************/
    828          
    829          
    830          /*****************************************************/
    831          //Зміна конфігурації
    832          /*****************************************************/
    833          __result_dym_mem_select allocate_dynamic_memory_for_settings(__action_dym_mem_select make_remake_restore, unsigned int mem_for_prt, uintptr_t *p_sca_of_p_current[], uintptr_t *p_sca_of_p_control[], __CONFIG *current, __CONFIG *edited, __CONFIG *control)
    834          {
    835            __result_dym_mem_select result = DYN_MEM_SELECT_OK;
    836            enum _id_fb index_1;
    837            unsigned int can_be_restore = true;
    838            
    839            if (make_remake_restore != RESTORE_DYN_MEM)
    840            {
    841              index_1 = _ID_FB_FIRST_VAR;
    842              while(
    843                    (result == DYN_MEM_SELECT_OK) &&
    844                    (index_1 < _ID_FB_LAST_VAR)
    845                   )    
    846              {
    847                uint32_t n_prev, n_cur;
    848                size_t size;
    849                void (*min_param)(unsigned int, uintptr_t *, size_t, size_t);
    850                uint32_t *p_current_field;
    851                switch (index_1)
    852                {
    853                case ID_FB_INPUT:
    854                  {
    855                    //Дискретний вхід
    856                    n_prev = (make_remake_restore != MAKE_DYN_MEM) ? current->n_input : 0;
    857                    p_current_field = &current->n_input;
    858                    n_cur = edited->n_input;
    859                    
    860                    min_param = min_settings_INPUT;
    861                    size = n_cur*((mem_for_prt == true) ? sizeof(__LN_INPUT) : sizeof(__settings_for_INPUT));
    862                    break;
    863                  }
    864                case ID_FB_OUTPUT:
    865                  {
    866                    //Дискретний вихід
    867                    n_prev = (make_remake_restore != MAKE_DYN_MEM) ? current->n_output : 0;
    868                    p_current_field = &current->n_output;
    869                    n_cur = edited->n_output;
    870                    
    871                    min_param = min_settings_OUTPUT;
    872                    size = n_cur*((mem_for_prt == true) ? sizeof(__LN_OUTPUT) : sizeof(__settings_for_OUTPUT));
    873                    break;
    874                  }
    875                case ID_FB_LED:
    876                  {
    877                    //Світлоіндикатор
    878                    n_prev = (make_remake_restore != MAKE_DYN_MEM) ? current->n_led : 0;
    879                    p_current_field = &current->n_led;
    880                    n_cur = edited->n_led;
    881                    
    882                    min_param = min_settings_LED;
    883                    size = n_cur*((mem_for_prt == true) ? sizeof(__LN_LED) : sizeof(__settings_for_LED));
    884                    break;
    885                  }
    886                case ID_FB_ALARM:
    887                  {
    888                    //Елемент "СЗС"
    889                    n_prev = (make_remake_restore != MAKE_DYN_MEM) ? current->n_alarm : 0;
    890                    p_current_field = &current->n_alarm;
    891                    n_cur = edited->n_alarm;
    892                    
    893                    min_param = min_settings_ALARM;
    894                    size = n_cur*((mem_for_prt == true) ? sizeof(__LN_ALARM) : sizeof(__settings_for_ALARM));
    895                    break;
    896                  }
    897                case ID_FB_GROUP_ALARM:
    898                  {
    899                    //Елемент "ШГС"
    900                    n_prev = (make_remake_restore != MAKE_DYN_MEM) ? current->n_group_alarm : 0;
    901                    p_current_field = &current->n_group_alarm;
    902                    n_cur = edited->n_group_alarm;
    903                    
    904                    min_param = min_settings_GROUP_ALARM;
    905                    size = n_cur*((mem_for_prt == true) ? sizeof(__LN_GROUP_ALARM) : sizeof(__settings_for_GROUP_ALARM));
    906                    break;
    907                  }
    908                case ID_FB_AND:
    909                  {
    910                    //Елемент "І"
    911                    n_prev = (make_remake_restore != MAKE_DYN_MEM) ? current->n_and : 0;
    912                    p_current_field = &current->n_and;
    913                    n_cur = edited->n_and;
    914                    
    915                    min_param = min_settings_AND;
    916                    size = n_cur*((mem_for_prt == true) ? sizeof(__LN_AND) : sizeof(__settings_for_AND));
    917                    break;
    918                  }
    919                case ID_FB_OR:
    920                  {
    921                    //Елемент "АБО"
    922                    n_prev = (make_remake_restore != MAKE_DYN_MEM) ? current->n_or : 0;
    923                    p_current_field = &current->n_or;
    924                    n_cur = edited->n_or;
    925                    
    926                    min_param = min_settings_OR;
    927                    size = n_cur*((mem_for_prt == true) ? sizeof(__LN_OR) : sizeof(__settings_for_OR));
    928                    break;
    929                  }
    930                case ID_FB_XOR:
    931                  {
    932                    //Елемент "Викл.АБО"
    933                    n_prev = (make_remake_restore != MAKE_DYN_MEM) ? current->n_xor : 0;
    934                    p_current_field = &current->n_xor;
    935                    n_cur = edited->n_xor;
    936                    
    937                    min_param = min_settings_XOR;
    938                    size = n_cur*((mem_for_prt == true) ? sizeof(__LN_XOR) : sizeof(__settings_for_XOR));
    939                    break;
    940                  }
    941                case ID_FB_NOT:
    942                  {
    943                    //Елемент "НЕ"
    944                    n_prev = (make_remake_restore != MAKE_DYN_MEM) ? current->n_not : 0;
    945                    p_current_field = &current->n_not;
    946                    n_cur = edited->n_not;
    947                    
    948                    min_param = min_settings_NOT;
    949                    size = n_cur*((mem_for_prt == true) ? sizeof(__LN_NOT) : sizeof(__settings_for_NOT));
    950                    break;
    951                  }
    952                case ID_FB_TIMER:
    953                  {
    954                    //Елемент "Таймер"
    955                    n_prev = (make_remake_restore != MAKE_DYN_MEM) ? current->n_timer : 0;
    956                    p_current_field = &current->n_timer;
    957                    n_cur = edited->n_timer;
    958                    
    959                    min_param = min_settings_TIMER;
    960                    size = n_cur*((mem_for_prt == true) ? sizeof(__LN_TIMER) : sizeof(__settings_for_TIMER));
    961                    break;
    962                  }
    963                case ID_FB_TRIGGER:
    964                  {
    965                    //Елемент "Триґер"
    966                    n_prev = (make_remake_restore != MAKE_DYN_MEM) ? current->n_trigger : 0;
    967                    p_current_field = &current->n_trigger;
    968                    n_cur = edited->n_trigger;
    969                    
    970                    min_param = min_settings_TRIGGER;
    971                    size = n_cur*((mem_for_prt == true) ? sizeof(__LN_TRIGGER) : sizeof(__settings_for_TRIGGER));
    972                    break;
    973                  }
    974                case ID_FB_MEANDER:
    975                  {
    976                    //Функціональний блок "Генератор періодичних сигналів"
    977                    n_prev = (make_remake_restore != MAKE_DYN_MEM) ? current->n_meander : 0;
    978                    p_current_field = &current->n_meander;
    979                    n_cur = edited->n_meander;
    980                    
    981                    min_param = min_settings_MEANDER;
    982                    size = n_cur*((mem_for_prt == true) ? sizeof(__LN_MEANDER) : sizeof(__settings_for_MEANDER));
    983                    break;
    984                  }
    985                default:
    986                  {
    987                    //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
    988                    total_error_sw_fixed(22);
    989                  }
    990                }
    991              
    992                if ((make_remake_restore == MAKE_DYN_MEM) || (n_cur != n_prev))
    993                {
    994                  if ((mem_for_prt != false) && (n_cur < n_prev)) can_be_restore = false;
    995                  
    996                  //Іде або виділення пергий раз області пам'яті, або кількість функціональних блоків зміникася
    997                  if(size == 0) 
    998                  {
    999                    free(p_sca_of_p_current[index_1 - _ID_FB_FIRST_VAR]);
   1000                    p_sca_of_p_current[index_1 - _ID_FB_FIRST_VAR] = NULL;
   1001                  }
   1002                  else
   1003                  {
   1004                    uintptr_t *ptr= (uintptr_t*)realloc(p_sca_of_p_current[index_1 - _ID_FB_FIRST_VAR], size);
   1005                    if (ptr != NULL)
   1006                    {
   1007                      p_sca_of_p_current[index_1 - _ID_FB_FIRST_VAR] = ptr;
   1008                      if (n_cur > n_prev)
   1009                      {
   1010                        //Викликаємо функцію встановлення нових налаштувань у мінімальні значення
   1011                        (*min_param)(mem_for_prt, ptr, n_prev, n_cur);
   1012                      }
   1013                    }
   1014                    else 
   1015                    {
   1016                      if (
   1017                          (make_remake_restore == MAKE_DYN_MEM) ||
   1018                          ((mem_for_prt != false) && (can_be_restore != true)) ||
   1019                          (control == NULL)
   1020                          ) 
   1021                      {
   1022                        result = DYN_MEM_TOTAL_ERROR;
   1023                      }
   1024                      else
   1025                      {
   1026                        result = DYN_MEM_NO_ENOUGH_MEM;
   1027                      }
   1028                    }
   1029                  }
   1030                }
   1031          
   1032                //Готуємося до зміни наступного функціонального блоку (у випадку успішної зміни або неуспішної, але з можливістю відновлення)
   1033                if (result == DYN_MEM_SELECT_OK) 
   1034                {
   1035                  *p_current_field = n_cur;
   1036                  index_1++;
   1037                }
   1038                else if (result == DYN_MEM_NO_ENOUGH_MEM) index_1--;
   1039              }
   1040            }
   1041            else
   1042            {
   1043              //Треб підготуватися для відновлення даних по контрльних даних
   1044              index_1 = _ID_FB_LAST_VAR;
   1045              index_1--;
   1046            }
   1047            
   1048            /*
   1049            Цей while потрібен тільки у тому випадку, якщо пам'яті для новогого розміщення є недостатньо
   1050            і є спроба повернутися до попередньої конфігурації
   1051            */
   1052            
   1053            /*****
   1054            Контроль на те, чи не є можлива спроба відновлення даних у ситуаціції, коли це не можливо
   1055            *****/
   1056            if(
   1057               (
   1058                (
   1059                 (make_remake_restore == RESTORE_DYN_MEM) &&
   1060                 (result == DYN_MEM_SELECT_OK)  
   1061                )   
   1062                ||  
   1063                (result == DYN_MEM_NO_ENOUGH_MEM)
   1064               )
   1065               && 
   1066               (
   1067                (make_remake_restore == MAKE_DYN_MEM) ||
   1068                ((mem_for_prt != false) && (can_be_restore != true)) ||
   1069                (control == NULL)
   1070               )
   1071              )   
   1072            {
   1073              //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
   1074              total_error_sw_fixed(66);
   1075            }
   1076            /*****/
   1077            
   1078            
   1079            while(
   1080                  (
   1081                   (
   1082                    (make_remake_restore == RESTORE_DYN_MEM) &&
   1083                    (result == DYN_MEM_SELECT_OK)  
   1084                   )   
   1085                   ||  
   1086                   (result == DYN_MEM_NO_ENOUGH_MEM)
   1087                  )
   1088                  &&  
   1089                  (index_1 >= _ID_FB_FIRST_VAR)
   1090                 )   
   1091            {
   1092              uint32_t n_prev, n_cur;
   1093              size_t size;
   1094              void (*copy_settings_LN)(unsigned int, unsigned int, uintptr_t *, uintptr_t *, size_t, size_t);
   1095              switch (index_1)
   1096              {
   1097              case ID_FB_INPUT:
   1098                {
   1099                  //Дискретний вхід
   1100                  n_cur  = current->n_input;
   1101                  current->n_input = n_prev = control->n_input;
   1102                  
   1103                  copy_settings_LN = copy_settings_INPUT;
   1104                  size = n_prev*sizeof(__settings_for_INPUT);
   1105                  break;
   1106                }
   1107              case ID_FB_OUTPUT:
   1108                {
   1109                  //Дискретний вихід
   1110                  n_cur  = current->n_output;
   1111                  current->n_output = n_prev = control->n_output;
   1112                  
   1113                  copy_settings_LN = copy_settings_OUTPUT;
   1114                  size = n_prev*sizeof(__settings_for_OUTPUT);
   1115                  break;
   1116                }
   1117              case ID_FB_LED:
   1118                {
   1119                  //Світлоіндимкатор
   1120                  n_cur  = current->n_led;
   1121                  current->n_led = n_prev = control->n_led;
   1122                  
   1123                  copy_settings_LN = copy_settings_LED;
   1124                  size = n_prev*sizeof(__settings_for_LED);
   1125                  break;
   1126                }
   1127              case ID_FB_ALARM:
   1128                {
   1129                  //Елемент "СЗС"
   1130                  n_cur  = current->n_alarm;
   1131                  current->n_alarm = n_prev = control->n_alarm;
   1132                  
   1133                  copy_settings_LN = copy_settings_ALARM;
   1134                  size = n_prev*sizeof(__settings_for_ALARM);
   1135                  break;
   1136                }
   1137              case ID_FB_GROUP_ALARM:
   1138                {
   1139                  //Елемент "ШГС"
   1140                  n_cur  = current->n_group_alarm;
   1141                  current->n_group_alarm = n_prev = control->n_group_alarm;
   1142                  
   1143                  copy_settings_LN = copy_settings_GROUP_ALARM;
   1144                  size = n_prev*sizeof(__settings_for_GROUP_ALARM);
   1145                  break;
   1146                }
   1147              case ID_FB_AND:
   1148                {
   1149                  //Елемент "І"
   1150                  n_cur  = current->n_and;
   1151                  current->n_and = n_prev = control->n_and;
   1152                  
   1153                  copy_settings_LN = copy_settings_AND;
   1154                  size = n_prev*sizeof(__settings_for_AND);
   1155                  break;
   1156                }
   1157              case ID_FB_OR:
   1158                {
   1159                  //Елемент "АБО"
   1160                  n_cur  = current->n_or;
   1161                  current->n_or = n_prev = control->n_or;
   1162                  
   1163                  copy_settings_LN = copy_settings_OR;
   1164                  size = n_prev*sizeof(__settings_for_OR);
   1165                  break;
   1166                }
   1167              case ID_FB_XOR:
   1168                {
   1169                  //Елемент "Викл.АБО"
   1170                  n_cur  = current->n_xor;
   1171                  current->n_xor = n_prev = control->n_xor;
   1172                  
   1173                  copy_settings_LN = copy_settings_XOR;
   1174                  size = n_prev*sizeof(__settings_for_XOR);
   1175                  break;
   1176                }
   1177              case ID_FB_NOT:
   1178                {
   1179                  //Елемент "НЕ"
   1180                  n_cur  = current->n_not;
   1181                  current->n_not = n_prev = control->n_not;
   1182                  
   1183                  copy_settings_LN = copy_settings_NOT;
   1184                  size = n_prev*sizeof(__settings_for_NOT);
   1185                  break;
   1186                }
   1187              case ID_FB_TIMER:
   1188                {
   1189                  //Елемент "Таймер"
   1190                  n_cur  = current->n_timer;
   1191                  current->n_timer = n_prev = control->n_timer;
   1192                  
   1193                  copy_settings_LN = copy_settings_TIMER;
   1194                  size = n_prev*sizeof(__settings_for_TIMER);
   1195                  break;
   1196                }
   1197              case ID_FB_TRIGGER:
   1198                {
   1199                  //Елемент "Триґер"
   1200                  n_cur  = current->n_trigger;
   1201                  current->n_trigger = n_prev = control->n_trigger;
   1202                  
   1203                  copy_settings_LN = copy_settings_TRIGGER;
   1204                  size = n_prev*sizeof(__settings_for_TRIGGER);
   1205                  break;
   1206                }
   1207              case ID_FB_MEANDER:
   1208                {
   1209                  //Функціональний блок "Генератор періодичних сигналів"
   1210                  n_cur  = current->n_meander;
   1211                  current->n_meander = n_prev = control->n_meander;
   1212                  
   1213                  copy_settings_LN = copy_settings_MEANDER;
   1214                  size = n_prev*sizeof(__settings_for_MEANDER);
   1215                  break;
   1216                }
   1217              default:
   1218                {
   1219                  //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
   1220                  total_error_sw_fixed(42);
   1221                }
   1222              }
   1223              
   1224              if (n_cur != n_prev)
   1225              {
   1226                //Іде або виділення пергий раз області пам'яті, або кількість функціональних блоків зміникася
   1227                if(size == 0) 
   1228                {
   1229                  free(p_sca_of_p_current[index_1 - _ID_FB_FIRST_VAR]);
   1230                  p_sca_of_p_current[index_1 - _ID_FB_FIRST_VAR] = NULL;
   1231                }
   1232                else
   1233                {
   1234                  uintptr_t *ptr= (uintptr_t*)realloc(p_sca_of_p_current[index_1 - _ID_FB_FIRST_VAR], size);
   1235                  if (ptr != NULL)
   1236                  {
   1237                    p_sca_of_p_current[index_1 - _ID_FB_FIRST_VAR] = ptr;
   1238                    if (n_prev > n_cur)
   1239                    {
   1240                      if (
   1241                          (can_be_restore == true) &&
   1242                          (p_sca_of_p_control != NULL) &&
   1243                          ( p_sca_of_p_control[index_1 - _ID_FB_FIRST_VAR] != NULL)
   1244                         )   
   1245                      {
   1246                        //Викликаємо функцію повернення нових налаштувань у попередні значення
   1247                        (*copy_settings_LN)(false, (p_sca_of_p_control == spca_of_p_prt), ptr, p_sca_of_p_control[index_1 - _ID_FB_FIRST_VAR], n_cur, n_prev);
   1248                      }
   1249                      else
   1250                      {
   1251                        //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
   1252                        total_error_sw_fixed(43);
   1253                      }
   1254                    }
   1255                  }
   1256                  else  result = DYN_MEM_TOTAL_ERROR;
   1257                }
   1258              }
   1259              
   1260              //Готуємося до зміни наступного функціонального блоку
   1261              if (result != DYN_MEM_TOTAL_ERROR) index_1--;
   1262            }
   1263            
   1264            return result;
   1265          }
   1266          /*****************************************************/
   1267          
   1268          /*****************************************************/
   1269          //Встановлення мінімальних параметрів для дискретного входу
   1270          /*****************************************************/
   1271          void min_settings_INPUT(unsigned int mem_to_prt, uintptr_t *base, size_t index_first, size_t index_last)
   1272          {
   1273            for (size_t shift = index_first; shift < index_last; shift++)
   1274            {
   1275              if (mem_to_prt == true) 
   1276              {
   1277                ((__LN_INPUT *)(base) + shift)->settings.set_delay[INPUT_SET_DELAY_DOPUSK] = KOEF_DOPUSK_DV_POST_MIN;
   1278                ((__LN_INPUT *)(base) + shift)->settings.control = 0;
   1279              }
   1280              else 
   1281              {
   1282                ((__settings_for_INPUT *)(base) + shift)->set_delay[INPUT_SET_DELAY_DOPUSK] = KOEF_DOPUSK_DV_POST_MIN;
   1283                ((__settings_for_INPUT *)(base) + shift)->control = 0;
   1284              }
   1285              
   1286              if (mem_to_prt == true)
   1287              {
   1288                for (size_t i = 0; i < INPUT_SET_DELAYS; i++) ((__LN_INPUT *)(base) + shift)->work_delay[i] = -1;
   1289                for (size_t i = 0; i < DIV_TO_HIGHER(INPUT_SIGNALS_OUT, 8); i++)
   1290                {
   1291                  ((__LN_INPUT *)(base) + shift)->active_state[i] = 0;
   1292                }
   1293              }
   1294            }
   1295          }
   1296          /*****************************************************/
   1297          
   1298          /*****************************************************/
   1299          //Відновлення попередніх параметрів для дискретного входу
   1300          /*****************************************************/
   1301          void copy_settings_INPUT(unsigned int mem_to_prt, unsigned int mem_from_prt, uintptr_t *base_target, uintptr_t *base_source, size_t index_target, size_t index_source)
   1302          {
   1303            for (size_t shift = index_target; shift < index_source; shift++)
   1304            {
   1305              if ((mem_to_prt == false) && (mem_from_prt == true))
   1306              {
   1307                ((__settings_for_INPUT *)(base_target) + shift)->control = ((__LN_INPUT *)(base_source) + shift)->settings.control;
   1308                for (size_t i = 0; i < INPUT_SET_DELAYS; i++) ((__settings_for_INPUT *)(base_target) + shift)->set_delay[i] = ((__LN_INPUT *)(base_source) + shift)->settings.set_delay[i];
   1309              }
   1310              else if ((mem_to_prt == true) && (mem_from_prt == false))
   1311              {
   1312                ((__LN_INPUT *)(base_target) + shift)->settings.control = ((__settings_for_INPUT *)(base_source) + shift)->control;
   1313                for (size_t i = 0; i < INPUT_SET_DELAYS; i++) ((__LN_INPUT *)(base_target) + shift)->settings.set_delay[i] = ((__settings_for_INPUT *)(base_source) + shift)->set_delay[i];
   1314              }
   1315              else if ((mem_to_prt == false) && (mem_from_prt == false))
   1316              {
   1317                ((__settings_for_INPUT *)(base_target) + shift)->control = ((__settings_for_INPUT *)(base_source) + shift)->control;
   1318                for (size_t i = 0; i < INPUT_SET_DELAYS; i++) ((__settings_for_INPUT *)(base_target) + shift)->set_delay[i] = ((__settings_for_INPUT *)(base_source) + shift)->set_delay[i];
   1319              }
   1320              else
   1321              {
   1322                //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
   1323                total_error_sw_fixed(90);
   1324              }
   1325            }
   1326          }
   1327          /*****************************************************/
   1328          
   1329          /*****************************************************/
   1330          //Встановлення мінімальних параметрів для дискретного виходу
   1331          /*****************************************************/
   1332          void min_settings_OUTPUT(unsigned int mem_to_prt, uintptr_t *base, size_t index_first, size_t index_last)
   1333          {
   1334            for (size_t shift = index_first; shift < index_last; shift++)
   1335            {
   1336              if (mem_to_prt == true) 
   1337              {
   1338                ((__LN_OUTPUT *)(base) + shift)->settings.control = 0;
   1339                for (size_t i = 0; i < OUTPUT_SIGNALS_IN; i++) ((__LN_OUTPUT *)(base) + shift)->settings.param[i] = 0;
   1340              }
   1341              else 
   1342              {
   1343                ((__settings_for_OUTPUT *)(base) + shift)->control = 0;
   1344                for (size_t i = 0; i < OUTPUT_SIGNALS_IN; i++) ((__settings_for_OUTPUT *)(base) + shift)->param[i] = 0;
   1345              }
   1346              
   1347              if (mem_to_prt == true)
   1348              {
   1349                for (size_t i = 0; i < DIV_TO_HIGHER(OUTPUT_SIGNALS_OUT, 8); i++)
   1350                {
   1351                  ((__LN_OUTPUT *)(base) + shift)->active_state[i] = 0;
   1352                }
   1353              }
   1354            }
   1355          }
   1356          /*****************************************************/
   1357          
   1358          /*****************************************************/
   1359          //Відновлення попередніх параметрів для дискретного виходу
   1360          /*****************************************************/
   1361          void copy_settings_OUTPUT(unsigned int mem_to_prt, unsigned int mem_from_prt, uintptr_t *base_target, uintptr_t *base_source, size_t index_target, size_t index_source)
   1362          {
   1363            for (size_t shift = index_target; shift < index_source; shift++)
   1364            {
   1365              if ((mem_to_prt == false) && (mem_from_prt == true))
   1366              {
   1367                ((__settings_for_OUTPUT *)(base_target) + shift)->control = ((__LN_OUTPUT *)(base_source) + shift)->settings.control;
   1368                for (size_t i = 0; i < OUTPUT_SIGNALS_IN; i++) ((__settings_for_OUTPUT *)(base_target) + shift)->param[i] = ((__LN_OUTPUT *)(base_source) + shift)->settings.param[i];
   1369              }
   1370              else if ((mem_to_prt == true) && (mem_from_prt == false))
   1371              {
   1372                ((__LN_OUTPUT *)(base_target) + shift)->settings.control = ((__settings_for_OUTPUT *)(base_source) + shift)->control;
   1373                for (size_t i = 0; i < OUTPUT_SIGNALS_IN; i++) ((__LN_OUTPUT *)(base_target) + shift)->settings.param[i] = ((__settings_for_OUTPUT *)(base_source) + shift)->param[i];
   1374              }
   1375              else if ((mem_to_prt == false) && (mem_from_prt == false))
   1376              {
   1377                ((__settings_for_OUTPUT *)(base_target) + shift)->control = ((__settings_for_OUTPUT *)(base_source) + shift)->control;
   1378                for (size_t i = 0; i < OUTPUT_SIGNALS_IN; i++) ((__settings_for_OUTPUT *)(base_target) + shift)->param[i] = ((__settings_for_OUTPUT *)(base_source) + shift)->param[i];
   1379              }
   1380              else
   1381              {
   1382                //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
   1383                total_error_sw_fixed(91);
   1384              }
   1385            }
   1386          }
   1387          /*****************************************************/
   1388          
   1389          /*****************************************************/
   1390          //Встановлення мінімальних параметрів для світлоіндикатора
   1391          /*****************************************************/
   1392          void min_settings_LED(unsigned int mem_to_prt, uintptr_t *base, size_t index_first, size_t index_last)
   1393          {
   1394            for (size_t shift = index_first; shift < index_last; shift++)
   1395            {
   1396              if (mem_to_prt == true) 
   1397              {
   1398                ((__LN_LED *)(base) + shift)->settings.control = 0;
   1399                for (size_t i = 0; i < LED_SIGNALS_IN; i++) ((__LN_LED *)(base) + shift)->settings.param[i] = 0;
   1400              }
   1401              else 
   1402              {
   1403                ((__settings_for_LED *)(base) + shift)->control = 0;
   1404                for (size_t i = 0; i < LED_SIGNALS_IN; i++) ((__settings_for_LED *)(base) + shift)->param[i] = 0;
   1405              }
   1406              
   1407              if (mem_to_prt == true)
   1408              {
   1409                for (size_t i = 0; i < DIV_TO_HIGHER(LED_SIGNALS_OUT, 8); i++)
   1410                {
   1411                  ((__LN_LED *)(base) + shift)->active_state[i] = 0;
   1412                }
   1413              }
   1414            }
   1415          }
   1416          /*****************************************************/
   1417          
   1418          /*****************************************************/
   1419          //Відновлення попередніх параметрів для світлоіндикатора
   1420          /*****************************************************/
   1421          void copy_settings_LED(unsigned int mem_to_prt, unsigned int mem_from_prt, uintptr_t *base_target, uintptr_t *base_source, size_t index_target, size_t index_source)
   1422          {
   1423            for (size_t shift = index_target; shift < index_source; shift++)
   1424            {
   1425              if ((mem_to_prt == false) && (mem_from_prt == true))
   1426              {
   1427                ((__settings_for_LED *)(base_target) + shift)->control = ((__LN_LED *)(base_source) + shift)->settings.control;
   1428                for (size_t i = 0; i < LED_SIGNALS_IN; i++) ((__settings_for_LED *)(base_target) + shift)->param[i] = ((__LN_LED *)(base_source) + shift)->settings.param[i];
   1429              }
   1430              else if ((mem_to_prt == true) && (mem_from_prt == false))
   1431              {
   1432                ((__LN_LED *)(base_target) + shift)->settings.control = ((__settings_for_LED *)(base_source) + shift)->control;
   1433                for (size_t i = 0; i < LED_SIGNALS_IN; i++) ((__LN_LED *)(base_target) + shift)->settings.param[i] = ((__settings_for_LED *)(base_source) + shift)->param[i];
   1434              }
   1435              else if ((mem_to_prt == false) && (mem_from_prt == false))
   1436              {
   1437                ((__settings_for_LED *)(base_target) + shift)->control = ((__settings_for_LED *)(base_source) + shift)->control;
   1438                for (size_t i = 0; i < LED_SIGNALS_IN; i++) ((__settings_for_LED *)(base_target) + shift)->param[i] = ((__settings_for_LED *)(base_source) + shift)->param[i];
   1439              }
   1440              else
   1441              {
   1442                //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
   1443                total_error_sw_fixed(92);
   1444              }
   1445            }
   1446          }
   1447          /*****************************************************/
   1448          
   1449          /*****************************************************/
   1450          //Встановлення мінімальних параметрів для елементу "СЗС"
   1451          /*****************************************************/
   1452          void min_settings_ALARM(unsigned int mem_to_prt, uintptr_t *base, size_t index_first, size_t index_last)
   1453          {
   1454            for (size_t shift = index_first; shift < index_last; shift++)
   1455            {
   1456              if (mem_to_prt == true) 
   1457              {
   1458                ((__LN_ALARM *)(base) + shift)->settings.set_delay[ALARM_SET_DELAY_PERIOD] = TIMEOUT_ALARM_PERIOD_MIN;
   1459                ((__LN_ALARM *)(base) + shift)->settings.control = 0;
   1460                for (size_t i = 0; i < ALARM_SIGNALS_IN; i++) ((__LN_ALARM *)(base) + shift)->settings.param[i] = 0;
   1461              }
   1462              else 
   1463              {
   1464                ((__settings_for_ALARM *)(base) + shift)->set_delay[ALARM_SET_DELAY_PERIOD] = TIMEOUT_ALARM_PERIOD_MIN;
   1465                ((__settings_for_ALARM *)(base) + shift)->control = 0;
   1466                for (size_t i = 0; i < ALARM_SIGNALS_IN; i++) ((__settings_for_ALARM *)(base) + shift)->param[i] = 0;
   1467              }
   1468              
   1469              if (mem_to_prt == true)
   1470              {
   1471                for (size_t i = 0; i < ALARM_WORK_DELAYS; i++) ((__LN_ALARM *)(base) + shift)->work_delay[i] = -1;
   1472                for (size_t i = 0; i < DIV_TO_HIGHER(ALARM_SIGNALS_OUT, 8); i++)
   1473                {
   1474                  ((__LN_ALARM *)(base) + shift)->active_state[i] = 0;
   1475                  ((__LN_ALARM *)(base) + shift)->trigger_state[i] = 0;
   1476                }
   1477              }
   1478            }
   1479          }
   1480          /*****************************************************/
   1481          
   1482          /*****************************************************/
   1483          //Відновлення попередніх параметрів для елементу "СЗС"
   1484          /*****************************************************/
   1485          void copy_settings_ALARM(unsigned int mem_to_prt, unsigned int mem_from_prt, uintptr_t *base_target, uintptr_t *base_source, size_t index_target, size_t index_source)
   1486          {
   1487            for (size_t shift = index_target; shift < index_source; shift++)
   1488            {
   1489              if ((mem_to_prt == false) && (mem_from_prt == true))
   1490              {
   1491                for (size_t i = 0; i < ALARM_SET_DELAYS; i++) ((__settings_for_ALARM *)(base_target) + shift)->set_delay[i] = ((__LN_ALARM *)(base_source) + shift)->settings.set_delay[i];
   1492                ((__settings_for_ALARM *)(base_target) + shift)->control = ((__LN_ALARM *)(base_source) + shift)->settings.control;
   1493                for (size_t i = 0; i < ALARM_SIGNALS_IN; i++) ((__settings_for_ALARM *)(base_target) + shift)->param[i] = ((__LN_ALARM *)(base_source) + shift)->settings.param[i];
   1494              }
   1495              else if ((mem_to_prt == true) && (mem_from_prt == false))
   1496              {
   1497                for (size_t i = 0; i < ALARM_SET_DELAYS; i++)((__LN_ALARM *)(base_target) + shift)->settings.set_delay[i] = ((__settings_for_ALARM *)(base_source) + shift)->set_delay[i];
   1498                ((__LN_ALARM *)(base_target) + shift)->settings.control = ((__settings_for_ALARM *)(base_source) + shift)->control;
   1499                for (size_t i = 0; i < ALARM_SIGNALS_IN; i++) ((__LN_ALARM *)(base_target) + shift)->settings.param[i] = ((__settings_for_ALARM *)(base_source) + shift)->param[i];
   1500              }
   1501              else if ((mem_to_prt == false) && (mem_from_prt == false))
   1502              {
   1503                for (size_t i = 0; i < ALARM_SET_DELAYS; i++)((__settings_for_ALARM *)(base_target) + shift)->set_delay[i] = ((__settings_for_ALARM *)(base_source) + shift)->set_delay[i];
   1504                ((__settings_for_ALARM *)(base_target) + shift)->control = ((__settings_for_ALARM *)(base_source) + shift)->control;
   1505                for (size_t i = 0; i < ALARM_SIGNALS_IN; i++) ((__settings_for_ALARM *)(base_target) + shift)->param[i] = ((__settings_for_ALARM *)(base_source) + shift)->param[i];
   1506              }
   1507              else
   1508              {
   1509                //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
   1510                total_error_sw_fixed(12);
   1511              }
   1512            }
   1513          }
   1514          /*****************************************************/
   1515          
   1516          /*****************************************************/
   1517          //Встановлення мінімальних параметрів для елементу "ШГС"
   1518          /*****************************************************/
   1519          void min_settings_GROUP_ALARM(unsigned int mem_to_prt, uintptr_t *base, size_t index_first, size_t index_last)
   1520          {
   1521            for (size_t shift = index_first; shift < index_last; shift++)
   1522            {
   1523              if (mem_to_prt == true) 
   1524              {
   1525                ((__LN_GROUP_ALARM *)(base) + shift)->settings.pickup[GROUP_ALARM_PICKUP_DELTA_I] = PICKUP_ALARM_DELTA_I_MIN;
   1526                ((__LN_GROUP_ALARM *)(base) + shift)->settings.set_delay[GROUP_ALARM_SET_DELAY_DELAY] = TIMEOUT_GROUP_ALARM_DELAY_MIN;
   1527                ((__LN_GROUP_ALARM *)(base) + shift)->settings.control = 0;
   1528                ((__LN_GROUP_ALARM *)(base) + shift)->settings.analog_input_control = 0;
   1529              }
   1530              else 
   1531              {
   1532                ((__settings_for_GROUP_ALARM *)(base) + shift)->pickup[GROUP_ALARM_PICKUP_DELTA_I] = PICKUP_ALARM_DELTA_I_MIN;
   1533                ((__settings_for_GROUP_ALARM *)(base) + shift)->set_delay[GROUP_ALARM_SET_DELAY_DELAY] = TIMEOUT_GROUP_ALARM_DELAY_MIN;
   1534                ((__settings_for_GROUP_ALARM *)(base) + shift)->control = 0;
   1535                ((__settings_for_GROUP_ALARM *)(base) + shift)->analog_input_control = 0;
   1536              }
   1537              
   1538              if (mem_to_prt == true)
   1539              {
   1540                for (size_t i = 0; i < GROUP_ALARM_WORK_DELAYS; i++) ((__LN_GROUP_ALARM *)(base) + shift)->work_delay[i] = -1;
   1541                for (size_t i = 0; i < DIV_TO_HIGHER(GROUP_ALARM_SIGNALS_OUT, 8); i++)
   1542                {
   1543                  ((__LN_GROUP_ALARM *)(base) + shift)->active_state[i] = 0;
   1544                  ((__LN_GROUP_ALARM *)(base) + shift)->trigger_state[i] = 0;
   1545                  ((__LN_GROUP_ALARM *)(base) + shift)->NNC = 0;
   1546                }
   1547              }
   1548            }
   1549          }
   1550          /*****************************************************/
   1551          
   1552          /*****************************************************/
   1553          //Відновлення попередніх параметрів для елементу "ШГС"
   1554          /*****************************************************/
   1555          void copy_settings_GROUP_ALARM(unsigned int mem_to_prt, unsigned int mem_from_prt, uintptr_t *base_target, uintptr_t *base_source, size_t index_target, size_t index_source)
   1556          {
   1557            for (size_t shift = index_target; shift < index_source; shift++)
   1558            {
   1559              if ((mem_to_prt == false) && (mem_from_prt == true))
   1560              {
   1561                for (size_t i = 0; i < GROUP_ALARM_PICKUPS; i++) ((__settings_for_GROUP_ALARM *)(base_target) + shift)->pickup[i] = ((__LN_GROUP_ALARM *)(base_source) + shift)->settings.pickup[i];
   1562                for (size_t i = 0; i < GROUP_ALARM_SET_DELAYS; i++) ((__settings_for_GROUP_ALARM *)(base_target) + shift)->set_delay[i] = ((__LN_GROUP_ALARM *)(base_source) + shift)->settings.set_delay[i];
   1563                ((__settings_for_GROUP_ALARM *)(base_target) + shift)->control = ((__LN_GROUP_ALARM *)(base_source) + shift)->settings.control;
   1564                ((__settings_for_GROUP_ALARM *)(base_target) + shift)->analog_input_control = ((__LN_GROUP_ALARM *)(base_source) + shift)->settings.analog_input_control;
   1565              }
   1566              else if ((mem_to_prt == true) && (mem_from_prt == false))
   1567              {
   1568                for (size_t i = 0; i < GROUP_ALARM_PICKUPS; i++)((__LN_GROUP_ALARM *)(base_target) + shift)->settings.pickup[i] = ((__settings_for_GROUP_ALARM *)(base_source) + shift)->pickup[i];
   1569                for (size_t i = 0; i < GROUP_ALARM_SET_DELAYS; i++)((__LN_GROUP_ALARM *)(base_target) + shift)->settings.set_delay[i] = ((__settings_for_GROUP_ALARM *)(base_source) + shift)->set_delay[i];
   1570                ((__LN_GROUP_ALARM *)(base_target) + shift)->settings.control = ((__settings_for_GROUP_ALARM *)(base_source) + shift)->control;
   1571                ((__LN_GROUP_ALARM *)(base_target) + shift)->settings.analog_input_control = ((__settings_for_GROUP_ALARM *)(base_source) + shift)->analog_input_control;
   1572              }
   1573              else if ((mem_to_prt == false) && (mem_from_prt == false))
   1574              {
   1575                for (size_t i = 0; i < GROUP_ALARM_PICKUPS; i++)((__settings_for_GROUP_ALARM *)(base_target) + shift)->pickup[i] = ((__settings_for_GROUP_ALARM *)(base_source) + shift)->pickup[i];
   1576                for (size_t i = 0; i < GROUP_ALARM_SET_DELAYS; i++)((__settings_for_GROUP_ALARM *)(base_target) + shift)->set_delay[i] = ((__settings_for_GROUP_ALARM *)(base_source) + shift)->set_delay[i];
   1577                ((__settings_for_GROUP_ALARM *)(base_target) + shift)->control = ((__settings_for_GROUP_ALARM *)(base_source) + shift)->control;
   1578                ((__settings_for_GROUP_ALARM *)(base_target) + shift)->analog_input_control = ((__settings_for_GROUP_ALARM *)(base_source) + shift)->analog_input_control;
   1579              }
   1580              else
   1581              {
   1582                //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
   1583                total_error_sw_fixed(32);
   1584              }
   1585            }
   1586          }
   1587          /*****************************************************/
   1588          
   1589          /*****************************************************/
   1590          //Встановлення мінімальних параметрів для елементу стандартної логіки "І"
   1591          /*****************************************************/
   1592          void min_settings_AND(unsigned int mem_to_prt, uintptr_t *base, size_t index_first, size_t index_last)
   1593          {
   1594            for (size_t shift = index_first; shift < index_last; shift++)
   1595            {
   1596              for (size_t i = 0; i < AND_SIGNALS_IN; i++)
   1597              {
   1598                if (mem_to_prt == true) ((__LN_AND *)(base) + shift)->settings.param[i] = 0;
   1599                else ((__settings_for_AND *)(base) + shift)->param[i] = 0;
   1600              }
   1601              
   1602              if (mem_to_prt == true)
   1603              {
   1604                for (size_t i = 0; i < DIV_TO_HIGHER(AND_SIGNALS_OUT, 8); i++)
   1605                {
   1606                  ((__LN_AND *)(base) + shift)->active_state[i] = 0;
   1607                  ((__LN_AND *)(base) + shift)->trigger_state[i] = 0;
   1608                }
   1609              }
   1610            }
   1611          }
   1612          /*****************************************************/
   1613          
   1614          /*****************************************************/
   1615          //Відновлення попередніх параметрів для елементу стандартної логіки "І"
   1616          /*****************************************************/
   1617          void copy_settings_AND(unsigned int mem_to_prt, unsigned int mem_from_prt, uintptr_t *base_target, uintptr_t *base_source, size_t index_target, size_t index_source)
   1618          {
   1619            for (size_t shift = index_target; shift < index_source; shift++)
   1620            {
   1621              for (size_t i = 0; i < AND_SIGNALS_IN; i++)
   1622              {
   1623                if ((mem_to_prt == false) && (mem_from_prt == true))
   1624                {
   1625                  ((__settings_for_AND *)(base_target) + shift)->param[i] = ((__LN_AND *)(base_source) + shift)->settings.param[i];
   1626                }
   1627                else if ((mem_to_prt == true) && (mem_from_prt == false))
   1628                {
   1629                  ((__LN_AND *)(base_target) + shift)->settings.param[i] = ((__settings_for_AND *)(base_source) + shift)->param[i];
   1630                }
   1631                else if ((mem_to_prt == false) && (mem_from_prt == false))
   1632                {
   1633                  ((__settings_for_AND *)(base_target) + shift)->param[i] = ((__settings_for_AND *)(base_source) + shift)->param[i];
   1634                }
   1635                else
   1636                {
   1637                  //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
   1638                  total_error_sw_fixed(93);
   1639                }
   1640              }
   1641            }
   1642          }
   1643          /*****************************************************/
   1644          
   1645          /*****************************************************/
   1646          //Встановлення мінімальних параметрів для елементу стандартної логіки "АБО"
   1647          /*****************************************************/
   1648          void min_settings_OR(unsigned int mem_to_prt, uintptr_t *base, size_t index_first, size_t index_last)
   1649          {
   1650            for (size_t shift = index_first; shift < index_last; shift++)
   1651            {
   1652              for (size_t i = 0; i < OR_SIGNALS_IN; i++)
   1653              {
   1654                if (mem_to_prt == true) ((__LN_OR *)(base) + shift)->settings.param[i] = 0;
   1655                else ((__settings_for_OR *)(base) + shift)->param[i] = 0;
   1656              }
   1657              
   1658              if (mem_to_prt == true)
   1659              {
   1660                for (size_t i = 0; i < DIV_TO_HIGHER(OR_SIGNALS_OUT, 8); i++)
   1661                {
   1662                  ((__LN_OR *)(base) + shift)->active_state[i] = 0;
   1663                  ((__LN_OR *)(base) + shift)->trigger_state[i] = 0;
   1664                }
   1665              }
   1666            }
   1667          }
   1668          /*****************************************************/
   1669          
   1670          /*****************************************************/
   1671          //Відновлення попередніх параметрів для елементу стандартної логіки "АБО"
   1672          /*****************************************************/
   1673          void copy_settings_OR(unsigned int mem_to_prt, unsigned int mem_from_prt, uintptr_t *base_target, uintptr_t *base_source, size_t index_target, size_t index_source)
   1674          {
   1675            for (size_t shift = index_target; shift < index_source; shift++)
   1676            {
   1677              for (size_t i = 0; i < OR_SIGNALS_IN; i++)
   1678              {
   1679                if ((mem_to_prt == false) && (mem_from_prt == true))
   1680                {
   1681                  ((__settings_for_OR *)(base_target) + shift)->param[i] = ((__LN_OR *)(base_source) + shift)->settings.param[i];
   1682                }
   1683                else if ((mem_to_prt == true) && (mem_from_prt == false))
   1684                {
   1685                  ((__LN_OR *)(base_target) + shift)->settings.param[i] = ((__settings_for_OR *)(base_source) + shift)->param[i];
   1686                }
   1687                else if ((mem_to_prt == false) && (mem_from_prt == false))
   1688                {
   1689                  ((__settings_for_OR *)(base_target) + shift)->param[i] = ((__settings_for_OR *)(base_source) + shift)->param[i];
   1690                }
   1691                else
   1692                {
   1693                  //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
   1694                  total_error_sw_fixed(94);
   1695                }
   1696              }
   1697            }
   1698          }
   1699          /*****************************************************/
   1700          
   1701          /*****************************************************/
   1702          //Встановлення мінімальних параметрів для елементу стандартної логіки "Викл.АБО"
   1703          /*****************************************************/
   1704          void min_settings_XOR(unsigned int mem_to_prt, uintptr_t *base, size_t index_first, size_t index_last)
   1705          {
   1706            for (size_t shift = index_first; shift < index_last; shift++)
   1707            {
   1708              for (size_t i = 0; i < 2; i++)
   1709              {
   1710                if (mem_to_prt == true) ((__LN_XOR *)(base) + shift)->settings.param[i] = 0;
   1711                else ((__settings_for_XOR *)(base) + shift)->param[i] = 0;
   1712              }
   1713              
   1714              if (mem_to_prt == true)
   1715              {
   1716                for (size_t i = 0; i < DIV_TO_HIGHER(XOR_SIGNALS_OUT, 8); i++)
   1717                {
   1718                  ((__LN_XOR *)(base) + shift)->active_state[i] = 0;
   1719                  ((__LN_XOR *)(base) + shift)->trigger_state[i] = 0;
   1720                }
   1721              }
   1722            }
   1723          }
   1724          /*****************************************************/
   1725          
   1726          /*****************************************************/
   1727          //Відновлення попередніх параметрів для елементу стандартної логіки "Викл.АБО"
   1728          /*****************************************************/
   1729          void copy_settings_XOR(unsigned int mem_to_prt, unsigned int mem_from_prt, uintptr_t *base_target, uintptr_t *base_source, size_t index_target, size_t index_source)
   1730          {
   1731            for (size_t shift = index_target; shift < index_source; shift++)
   1732            {
   1733              for (size_t i = 0; i < 2; i++)
   1734              {
   1735                if ((mem_to_prt == false) && (mem_from_prt == true))
   1736                {
   1737                  ((__settings_for_XOR *)(base_target) + shift)->param[i] = ((__LN_XOR *)(base_source) + shift)->settings.param[i];
   1738                }
   1739                else if ((mem_to_prt == true) && (mem_from_prt == false))
   1740                {
   1741                  ((__LN_XOR *)(base_target) + shift)->settings.param[i] = ((__settings_for_XOR *)(base_source) + shift)->param[i];
   1742                }
   1743                else if ((mem_to_prt == false) && (mem_from_prt == false))
   1744                {
   1745                  ((__settings_for_XOR *)(base_target) + shift)->param[i] = ((__settings_for_XOR *)(base_source) + shift)->param[i];
   1746                }
   1747                else
   1748                {
   1749                  //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
   1750                  total_error_sw_fixed(95);
   1751                }
   1752              }
   1753            }
   1754          }
   1755          /*****************************************************/
   1756          
   1757          /*****************************************************/
   1758          //Встановлення мінімальних параметрів для елементу стандартної логіки "НЕ"
   1759          /*****************************************************/
   1760          void min_settings_NOT(unsigned int mem_to_prt, uintptr_t *base, size_t index_first, size_t index_last)
   1761          {
   1762            for (size_t shift = index_first; shift < index_last; shift++)
   1763            {
   1764              if (mem_to_prt == true) ((__LN_NOT *)(base) + shift)->settings.param = 0;
   1765              else ((__settings_for_NOT *)(base) + shift)->param = 0;
   1766              
   1767              if (mem_to_prt == true)
   1768              {
   1769                for (size_t i = 0; i < DIV_TO_HIGHER(NOT_SIGNALS_OUT, 8); i++)
   1770                {
   1771                  ((__LN_NOT *)(base) + shift)->active_state[i] = 0;
   1772                  ((__LN_NOT *)(base) + shift)->trigger_state[i] = 0;
   1773                }
   1774              }
   1775            }
   1776          }
   1777          /*****************************************************/
   1778          
   1779          /*****************************************************/
   1780          //Відновлення попередніх параметрів для елементу стандартної логіки "НЕ"
   1781          /*****************************************************/
   1782          void copy_settings_NOT(unsigned int mem_to_prt, unsigned int mem_from_prt, uintptr_t *base_target, uintptr_t *base_source, size_t index_target, size_t index_source)
   1783          {
   1784            for (size_t shift = index_target; shift < index_source; shift++)
   1785            {
   1786              if ((mem_to_prt == false) && (mem_from_prt == true))
   1787              {
   1788                ((__settings_for_NOT *)(base_target) + shift)->param = ((__LN_NOT *)(base_source) + shift)->settings.param;
   1789              }
   1790              else if ((mem_to_prt == true) && (mem_from_prt == false))
   1791              {
   1792                ((__LN_NOT *)(base_target) + shift)->settings.param = ((__settings_for_NOT *)(base_source) + shift)->param;
   1793              }
   1794              else if ((mem_to_prt == false) && (mem_from_prt == false))
   1795              {
   1796                ((__settings_for_NOT *)(base_target) + shift)->param = ((__settings_for_NOT *)(base_source) + shift)->param;
   1797              }
   1798              else
   1799              {
   1800                //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
   1801                total_error_sw_fixed(96);
   1802              }
   1803            }
   1804          }
   1805          /*****************************************************/
   1806          
   1807          /*****************************************************/
   1808          //Встановлення мінімальних параметрів для елементу "Таймер"
   1809          /*****************************************************/
   1810          void min_settings_TIMER(unsigned int mem_to_prt, uintptr_t *base, size_t index_first, size_t index_last)
   1811          {
   1812            for (size_t shift = index_first; shift < index_last; shift++)
   1813            {
   1814              if (mem_to_prt == true) 
   1815              {
   1816                for (size_t i = 0; i < TIMER_SIGNALS_IN; i++) ((__LN_TIMER *)(base) + shift)->settings.param[i] = 0;
   1817                ((__LN_TIMER *)(base) + shift)->settings.set_delay[TIMER_SET_DELAY_PAUSE] = TIMEOUT_TIMER_PAUSE_MIN;
   1818                ((__LN_TIMER *)(base) + shift)->settings.set_delay[TIMER_SET_DELAY_WORK]  = TIMEOUT_TIMER_WORK_MIN;
   1819              }
   1820              else 
   1821              {
   1822                for (size_t i = 0; i < TIMER_SIGNALS_IN; i++) ((__settings_for_TIMER *)(base) + shift)->param[i] = 0;
   1823                ((__settings_for_TIMER *)(base) + shift)->set_delay[TIMER_SET_DELAY_PAUSE] = TIMEOUT_TIMER_PAUSE_MIN;
   1824                ((__settings_for_TIMER *)(base) + shift)->set_delay[TIMER_SET_DELAY_WORK]  = TIMEOUT_TIMER_WORK_MIN;
   1825              }
   1826              
   1827              if (mem_to_prt == true)
   1828              {
   1829                for (size_t i = 0; i < TIMER_WORK_DELAYS; i++) ((__LN_TIMER *)(base) + shift)->work_delay[i] = -1;
   1830                for (size_t i = 0; i < DIV_TO_HIGHER(TIMER_SIGNALS_OUT, 8); i++)
   1831                {
   1832                  ((__LN_TIMER *)(base) + shift)->active_state[i] = 0;
   1833                  ((__LN_TIMER *)(base) + shift)->trigger_state[i] = 0;
   1834                }
   1835              }
   1836            }
   1837          }
   1838          /*****************************************************/
   1839          
   1840          /*****************************************************/
   1841          //Відновлення попередніх параметрів для елементу "Таймер"
   1842          /*****************************************************/
   1843          void copy_settings_TIMER(unsigned int mem_to_prt, unsigned int mem_from_prt, uintptr_t *base_target, uintptr_t *base_source, size_t index_target, size_t index_source)
   1844          {
   1845            for (size_t shift = index_target; shift < index_source; shift++)
   1846            {
   1847              if ((mem_to_prt == false) && (mem_from_prt == true))
   1848              {
   1849                for (size_t i = 0; i < TIMER_SIGNALS_IN; i++) ((__settings_for_TIMER *)(base_target) + shift)->param[i] = ((__LN_TIMER *)(base_source) + shift)->settings.param[i];
   1850                for (size_t i = 0; i < TIMER_SET_DELAYS; i++) ((__settings_for_TIMER *)(base_target) + shift)->set_delay[i] = ((__LN_TIMER *)(base_source) + shift)->settings.set_delay[i];
   1851              }
   1852              else if ((mem_to_prt == true) && (mem_from_prt == false))
   1853              {
   1854                for (size_t i = 0; i < TIMER_SIGNALS_IN; i++) ((__LN_TIMER *)(base_target) + shift)->settings.param[i] = ((__settings_for_TIMER *)(base_source) + shift)->param[i];
   1855                for (size_t i = 0; i < TIMER_SET_DELAYS; i++)((__LN_TIMER *)(base_target) + shift)->settings.set_delay[i] = ((__settings_for_TIMER *)(base_source) + shift)->set_delay[i];
   1856              }
   1857              else if ((mem_to_prt == false) && (mem_from_prt == false))
   1858              {
   1859                for (size_t i = 0; i < TIMER_SIGNALS_IN; i++) ((__settings_for_TIMER *)(base_target) + shift)->param[i] = ((__settings_for_TIMER *)(base_source) + shift)->param[i];
   1860                for (size_t i = 0; i < TIMER_SET_DELAYS; i++)((__settings_for_TIMER *)(base_target) + shift)->set_delay[i] = ((__settings_for_TIMER *)(base_source) + shift)->set_delay[i];
   1861              }
   1862              else
   1863              {
   1864                //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
   1865                total_error_sw_fixed(97);
   1866              }
   1867            }
   1868          }
   1869          /*****************************************************/
   1870          
   1871          /*****************************************************/
   1872          //Встановлення мінімальних параметрів для елементу "Триґер"
   1873          /*****************************************************/
   1874          void min_settings_TRIGGER(unsigned int mem_to_prt, uintptr_t *base, size_t index_first, size_t index_last)
   1875          {
   1876            for (size_t shift = index_first; shift < index_last; shift++)
   1877            {
   1878              for (size_t i = 0; i < TRIGGER_SIGNALS_IN; i++)
   1879              {
   1880                if (mem_to_prt == true) ((__LN_TRIGGER *)(base) + shift)->settings.param[i] = 0;
   1881                else ((__settings_for_TRIGGER *)(base) + shift)->param[i] = 0;
   1882              }
   1883              
   1884              if (mem_to_prt == true)
   1885              {
   1886                for (size_t i = 0; i < DIV_TO_HIGHER(TRIGGER_SIGNALS_OUT, 8); i++)
   1887                {
   1888                  ((__LN_TRIGGER *)(base) + shift)->active_state[i] = 0;
   1889                  ((__LN_TRIGGER *)(base) + shift)->trigger_state[i] = 0;
   1890                }
   1891              }
   1892            }
   1893          }
   1894          /*****************************************************/
   1895          
   1896          /*****************************************************/
   1897          //Відновлення попередніх параметрів для елементу "Триґер"
   1898          /*****************************************************/
   1899          void copy_settings_TRIGGER(unsigned int mem_to_prt, unsigned int mem_from_prt, uintptr_t *base_target, uintptr_t *base_source, size_t index_target, size_t index_source)
   1900          {
   1901            for (size_t shift = index_target; shift < index_source; shift++)
   1902            {
   1903              for (size_t i = 0; i < TRIGGER_SIGNALS_IN; i++)
   1904              {
   1905                if ((mem_to_prt == false) && (mem_from_prt == true))
   1906                {
   1907                  ((__settings_for_TRIGGER *)(base_target) + shift)->param[i] = ((__LN_TRIGGER *)(base_source) + shift)->settings.param[i];
   1908                }
   1909                else if ((mem_to_prt == true) && (mem_from_prt == false))
   1910                {
   1911                  ((__LN_TRIGGER *)(base_target) + shift)->settings.param[i] = ((__settings_for_TRIGGER *)(base_source) + shift)->param[i];
   1912                }
   1913                else if ((mem_to_prt == false) && (mem_from_prt == false))
   1914                {
   1915                  ((__settings_for_TRIGGER *)(base_target) + shift)->param[i] = ((__settings_for_TRIGGER *)(base_source) + shift)->param[i];
   1916                }
   1917                else
   1918                {
   1919                  //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
   1920                  total_error_sw_fixed(98);
   1921                }
   1922              }
   1923            }
   1924          }
   1925          /*****************************************************/
   1926          
   1927          /*****************************************************/
   1928          //Встановлення мінімальних параметрів для функціоанльного блоку "Генератор періодичних сигналів"
   1929          /*****************************************************/
   1930          void min_settings_MEANDER(unsigned int mem_to_prt, uintptr_t *base, size_t index_first, size_t index_last)
   1931          {
   1932            for (size_t shift = index_first; shift < index_last; shift++)
   1933            {
   1934              if (mem_to_prt == true) 
   1935              {
   1936                ((__LN_MEANDER *)(base) + shift)->settings.set_delay[MEANDER_SET_DELAY_PERIOD] = TIMEOUT_MEANDER_PERIOD_MIN;
   1937              }
   1938              else 
   1939              {
   1940                ((__settings_for_MEANDER *)(base) + shift)->set_delay[MEANDER_SET_DELAY_PERIOD] = TIMEOUT_MEANDER_PERIOD_MIN;
   1941              }
   1942              
   1943              if (mem_to_prt == true)
   1944              {
   1945                for (size_t i = 0; i < MEANDER_WORK_DELAYS; i++) ((__LN_MEANDER *)(base) + shift)->work_delay[i] = -1;
   1946                for (size_t i = 0; i < DIV_TO_HIGHER(MEANDER_SIGNALS_OUT, 8); i++)
   1947                {
   1948                  ((__LN_MEANDER *)(base) + shift)->active_state[i] = 0;
   1949                }
   1950              }
   1951            }
   1952          }
   1953          /*****************************************************/
   1954          
   1955          /*****************************************************/
   1956          //Відновлення попередніх параметрів для функціоанльного блоку "Генератор періодичних сигналів"
   1957          /*****************************************************/
   1958          void copy_settings_MEANDER(unsigned int mem_to_prt, unsigned int mem_from_prt, uintptr_t *base_target, uintptr_t *base_source, size_t index_target, size_t index_source)
   1959          {
   1960            for (size_t shift = index_target; shift < index_source; shift++)
   1961            {
   1962              if ((mem_to_prt == false) && (mem_from_prt == true))
   1963              {
   1964                for (size_t i = 0; i < MEANDER_SET_DELAYS; i++) ((__settings_for_MEANDER *)(base_target) + shift)->set_delay[i] = ((__LN_MEANDER *)(base_source) + shift)->settings.set_delay[i];
   1965              }
   1966              else if ((mem_to_prt == true) && (mem_from_prt == false))
   1967              {
   1968                for (size_t i = 0; i < MEANDER_SET_DELAYS; i++) ((__LN_MEANDER *)(base_target) + shift)->settings.set_delay[i] = ((__settings_for_MEANDER *)(base_source) + shift)->set_delay[i];
   1969              }
   1970              else if ((mem_to_prt == false) && (mem_from_prt == false))
   1971              {
   1972                for (size_t i = 0; i < MEANDER_SET_DELAYS; i++) ((__settings_for_MEANDER *)(base_target) + shift)->set_delay[i] = ((__settings_for_MEANDER *)(base_source) + shift)->set_delay[i];
   1973              }
   1974              else
   1975              {
   1976                //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
   1977                total_error_sw_fixed(99);
   1978              }
   1979            }
   1980          }
   1981          /*****************************************************/
   1982          
   1983          /*****************************************************/
   1984          //Розмір у байтах всіх налаштувань (фіксованих і змінних)
   1985          /*****************************************************/
   1986          size_t size_all_settings(void)
   1987          {
   1988            size_t size = sizeof(__SETTINGS_FIX);
   1989            for (enum _id_fb i = _ID_FB_FIRST_VAR; i < _ID_FB_LAST_VAR; i++)
   1990            {
   1991              size_t size_block;
   1992              switch (i)
   1993              {
   1994              case ID_FB_INPUT:
   1995                {
   1996                  size_block = current_config.n_input*sizeof(__settings_for_INPUT);
   1997                  break;
   1998                }
   1999              case ID_FB_OUTPUT:
   2000                {
   2001                  size_block = current_config.n_output*sizeof(__settings_for_OUTPUT);
   2002                  break;
   2003                }
   2004              case ID_FB_LED:
   2005                {
   2006                  size_block = current_config.n_led*sizeof(__settings_for_LED);
   2007                  break;
   2008                }
   2009              case ID_FB_ALARM:
   2010                {
   2011                  size_block = current_config.n_alarm*sizeof(__settings_for_ALARM);
   2012                  break;
   2013                }
   2014              case ID_FB_GROUP_ALARM:
   2015                {
   2016                  size_block = current_config.n_group_alarm*sizeof(__settings_for_GROUP_ALARM);
   2017                  break;
   2018                }
   2019              case ID_FB_AND:
   2020                {
   2021                  size_block = current_config.n_and*sizeof(__settings_for_AND);
   2022                  break;
   2023                }
   2024              case ID_FB_OR:
   2025                {
   2026                  size_block = current_config.n_or*sizeof(__settings_for_OR);
   2027                  break;
   2028                }
   2029              case ID_FB_XOR:
   2030                {
   2031                  size_block = current_config.n_xor*sizeof(__settings_for_XOR);
   2032                  break;
   2033                }
   2034              case ID_FB_NOT:
   2035                {
   2036                  size_block = current_config.n_not*sizeof(__settings_for_NOT);
   2037                  break;
   2038                }
   2039              case ID_FB_TIMER:
   2040                {
   2041                  size_block = current_config.n_timer*sizeof(__settings_for_TIMER);
   2042                  break;
   2043                }
   2044              case ID_FB_TRIGGER:
   2045                {
   2046                  size_block = current_config.n_trigger*sizeof(__settings_for_TRIGGER);
   2047                  break;
   2048                }
   2049              case ID_FB_MEANDER:
   2050                {
   2051                  size_block = current_config.n_meander*sizeof(__settings_for_MEANDER);
   2052                  break;
   2053                }
   2054              default:
   2055                {
   2056                  //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
   2057                  total_error_sw_fixed(52);
   2058                } 
   2059              }
   2060              
   2061              size += size_block;
   2062            }
   2063            
   2064            return size;
   2065            
   2066          }
   2067          /*****************************************************/
   2068          
   2069          /*****************************************************/
   2070          //Відновлення налаштувань з контрольної версії
   2071          /*****************************************************/
   2072          void copy_settings(
   2073                               __CONFIG *source_conf, 
   2074          
   2075                               __SETTINGS_FIX *target_fix, 
   2076                               __SETTINGS_FIX *source_fix, 
   2077                               uintptr_t *target_dyn[], 
   2078                               uintptr_t *source_dyn[]
   2079                              )
   2080          {
   2081            *target_fix = *source_fix;
   2082            
   2083            for (enum _id_fb i = _ID_FB_FIRST_VAR; i < _ID_FB_LAST_VAR; i++)
   2084            {
   2085              if (source_dyn[i - _ID_FB_FIRST_VAR] != NULL)
   2086              {
   2087                uint32_t n_prev;
   2088                void (*copy_settings_LN)(unsigned int, unsigned int, uintptr_t *, uintptr_t *, size_t, size_t);
   2089                switch (i)
   2090                {
   2091                  case ID_FB_INPUT:
   2092                    {
   2093                      //Дискретний вхід
   2094                      n_prev = source_conf->n_input;
   2095                      copy_settings_LN = copy_settings_INPUT;
   2096          
   2097                      break;
   2098                    }
   2099                  case ID_FB_OUTPUT:
   2100                    {
   2101                      //Дискретний вихід
   2102                      n_prev = source_conf->n_output;
   2103                      copy_settings_LN = copy_settings_OUTPUT;
   2104          
   2105                      break;
   2106                    }
   2107                  case ID_FB_LED:
   2108                    {
   2109                      //Світлоіндимкатор
   2110                      n_prev = source_conf->n_led;
   2111                      copy_settings_LN = copy_settings_LED;
   2112          
   2113                      break;
   2114                    }
   2115                  case ID_FB_ALARM:
   2116                    {
   2117                      //Елемент "СЗС"
   2118                      n_prev = source_conf->n_alarm;
   2119                      copy_settings_LN = copy_settings_ALARM;
   2120          
   2121                      break;
   2122                    }
   2123                  case ID_FB_GROUP_ALARM:
   2124                    {
   2125                      //Елемент "ШГС"
   2126                      n_prev = source_conf->n_group_alarm;
   2127                      copy_settings_LN = copy_settings_GROUP_ALARM;
   2128          
   2129                      break;
   2130                    }
   2131                  case ID_FB_AND:
   2132                    {
   2133                      //Елемент "І"
   2134                      n_prev = source_conf->n_and;
   2135                      copy_settings_LN = copy_settings_AND;
   2136          
   2137                      break;
   2138                    }
   2139                  case ID_FB_OR:
   2140                    {
   2141                      //Елемент "АБО"
   2142                      n_prev = source_conf->n_or;
   2143                      copy_settings_LN = copy_settings_OR;
   2144          
   2145                      break;
   2146                    }
   2147                  case ID_FB_XOR:
   2148                    {
   2149                      //Елемент "Викл.АБО"
   2150                      n_prev = source_conf->n_xor;
   2151                      copy_settings_LN = copy_settings_XOR;
   2152          
   2153                      break;
   2154                    }
   2155                  case ID_FB_NOT:
   2156                    {
   2157                      //Елемент "НЕ"
   2158                      n_prev = source_conf->n_not;
   2159                      copy_settings_LN = copy_settings_NOT;
   2160          
   2161                      break;
   2162                    }
   2163                  case ID_FB_TIMER:
   2164                    {
   2165                      //Елемент "Таймер"
   2166                      n_prev = source_conf->n_timer;
   2167                      copy_settings_LN = copy_settings_TIMER;
   2168          
   2169                      break;
   2170                    }
   2171                  case ID_FB_TRIGGER:
   2172                    {
   2173                      //Елемент "Триґер"
   2174                      n_prev = source_conf->n_trigger;
   2175                      copy_settings_LN = copy_settings_TRIGGER;
   2176          
   2177                      break;
   2178                    }
   2179                  case ID_FB_MEANDER:
   2180                    {
   2181                      //Функціональний блок "Генератор періодичних сигналів"
   2182                      n_prev = source_conf->n_meander;
   2183                      copy_settings_LN = copy_settings_MEANDER;
   2184          
   2185                      break;
   2186                    }
   2187                  default:
   2188                    {
   2189                      //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
   2190                      total_error_sw_fixed(57);
   2191                    }
   2192                }
   2193                
   2194                if ((n_prev != 0) && (target_dyn[i - _ID_FB_FIRST_VAR] != NULL))
   2195                {
   2196                  //Викликаємо функцію повернення нових налаштувань у попередні значення
   2197                  (*copy_settings_LN)((target_dyn == spca_of_p_prt), (source_dyn == spca_of_p_prt), target_dyn[i - _ID_FB_FIRST_VAR], source_dyn[i - _ID_FB_FIRST_VAR], 0, n_prev);
   2198                }
   2199                else
   2200                {
   2201                  //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
   2202                  total_error_sw_fixed(59);
   2203                }
   2204              }
   2205            }
   2206          }
   2207          /*****************************************************/
   2208          
   2209          /*****************************************************/
   2210          /*
   2211          Виконання змін у кнофігурації і налаштуваннях
   2212          
   2213          Вхідна інформація
   2214          -----------------
   2215          direction:
   2216          1 - внести зміни у "для захистів" структурах і масивах
   2217          0 - відновити попердній стан по "для захисту" у стуктурах і масивах "контейнера" і "для редагування"
   2218          
   2219          source - елементи з перерахування enum __source_fix_changes
   2220          
   2221          
   2222          Вихідна інформація про помилку
   2223          -----------------
   2224          0 - успішее виконання опреації
   2225          1 - недостатньо пам'яті, але вдалося відновити попередній сатн по "для захисту"
   2226          2 - недостатньо пам'яті і не вдалося відновити попередній стан по "для захисту"
   2227          */
   2228          /*****************************************************/
   2229          unsigned int set_config_and_settings(unsigned int direction, unsigned int source)
   2230          {
   2231            unsigned int error = 0;
   2232            if (direction != 0)
   2233            {
   2234              unsigned int reconfiguration_RS_485 = false, reconfiguration_RS_485_with_reset_usart = false;
   2235                unsigned int set_password_USB = false, set_password_RS485 = false;
   2236              if (
   2237                  (settings_fix.baud_RS485 != settings_fix_prt.baud_RS485) ||
   2238                  (settings_fix.pare_bit_RS485 != settings_fix_prt.pare_bit_RS485) ||
   2239                  (settings_fix.number_stop_bit_RS485 != settings_fix_prt.number_stop_bit_RS485) ||
   2240                  (settings_fix.time_out_1_RS485 != settings_fix_prt.time_out_1_RS485)
   2241                 )
   2242              {
   2243                //Помічаємо, що треба переконфігурувати інтерфейс RS-485
   2244                reconfiguration_RS_485 = true;
   2245              
   2246                if (
   2247                    (settings_fix.baud_RS485 != settings_fix_prt.baud_RS485) ||
   2248                    (settings_fix.pare_bit_RS485 != settings_fix_prt.pare_bit_RS485) ||
   2249                    (settings_fix.number_stop_bit_RS485 != settings_fix_prt.number_stop_bit_RS485)
   2250                   )
   2251                {
   2252                  //Помічаємо, що треба переконфігурувати USART для інтерфейсу RS-485
   2253                  reconfiguration_RS_485_with_reset_usart = true;
   2254                }
   2255                
   2256                if (
   2257                    (settings_fix.password_interface_USB != settings_fix_prt.password_interface_USB) &&
   2258                    (settings_fix.password_interface_USB != 0)  
   2259                   )   
   2260                {
   2261                  set_password_USB = true;
   2262                }
   2263            
   2264                if (
   2265                    (settings_fix.password_interface_RS485 != settings_fix_prt.password_interface_RS485) &&
   2266                    (settings_fix.password_interface_RS485 != 0)  
   2267                   )   
   2268                {
   2269                  set_password_RS485 = true;
   2270                }
   2271              }
   2272          
   2273              __result_dym_mem_select result = DYN_MEM_SELECT_OK;
   2274              //Активація внесених змін
   2275              if (config_settings_modified & MASKA_CHANGED_CONFIGURATION)
   2276              {
   2277                __CONFIG current_config_tmp = current_config_prt;
   2278                __disable_interrupt();
   2279                result = allocate_dynamic_memory_for_settings(REMAKE_DYN_MEM, true, spca_of_p_prt, NULL, &current_config_prt, &current_config, &current_config_tmp);
   2280              }
   2281          
   2282              if (result == DYN_MEM_SELECT_OK)
   2283              {
   2284                if (config_settings_modified & MASKA_CHANGED_SETTINGS)
   2285                {
   2286                  //Відбувалися зміни у налаштуваннях
   2287                  __disable_interrupt(); /*конфігурація може записуватися, а може не записуватися, тому у цьому місці переривання вже можуть бути забороненими, або ще ні*/
   2288                  copy_settings(&current_config, &settings_fix_prt, &settings_fix, spca_of_p_prt, sca_of_p);
   2289                }
   2290                __enable_interrupt(); /*могла бути ситуація. що конфігурація змінювалася без зміни налаштувнь*/
   2291              }
   2292              else if (result == DYN_MEM_NO_ENOUGH_MEM) 
   2293              {
   2294                __enable_interrupt();
   2295                /*
   2296                при такому негативному резульаті зміни конфігурації все ж таки конфігурація повернулася 
   2297                до свого попереднього стану, тому можна відновити інших більш пріоритетних систем, зокрема,
   2298                системи захиств.
   2299                У іншому випадку цього робити не можна, бо ми не знаємо, у якому стані зараз масиви налаштувань,
   2300                які змінювалися у процесі зміни конфігурації
   2301                */
   2302              }
   2303              
   2304              
   2305              if (result == DYN_MEM_SELECT_OK)
   2306              {
   2307                /*
   2308                Дії по встановленню мінімальних налаштувань
   2309                */
   2310                if (source == DEFAULT_PARAMS_FIX_CHANGES)
   2311                {
   2312                  enum _menu2_levels temp_value_level = current_state_menu2.current_level;
   2313                  while(
   2314                        (temp_value_level >= __BEGIN_SETTINGS_MENU2_LEVEL) &&
   2315                        (temp_value_level <  __NEXT_AFTER_SETTINGS_MENU2_LEVEL)
   2316                       )
   2317                  {
   2318                    temp_value_level = previous_level_in_current_level_menu2[temp_value_level];
   2319                  }
   2320                  if (temp_value_level != current_state_menu2.current_level)
   2321                  {
   2322                    current_state_menu2.current_level = temp_value_level;
   2323                    new_level_menu();
   2324                  }
   2325                  reconfiguration_RS_485 = true;
   2326                  reconfiguration_RS_485_with_reset_usart = true;
   2327                  set_password_USB = true;
   2328                  set_password_RS485 = true;
   2329                }
   2330                /***/
   2331          
   2332                /*
   2333                Дії по зміні налаштувань RS-485
   2334                */
   2335                if (reconfiguration_RS_485 != 0)
   2336                {
   2337                  //Підраховуємо нову величину затримки у бітах, яка допускається між байтами у RS-485 згідно з визначеними настройками
   2338                  calculate_namber_bit_waiting_for_rs_485();
   2339                  //Виставляємо команду про переконфігурування RS-485
   2340                  if (reconfiguration_RS_485_with_reset_usart != 0) make_reconfiguration_RS_485 = 0xff;
   2341                }
   2342                if (set_password_USB   != false) password_set_USB   = 1;
   2343                if (set_password_RS485 != false) password_set_RS485 = 1;
   2344                /***/
   2345                
   2346                _SET_BIT(clear_diagnostyka, ERROR_NO_FREE_DYNAMIC_MEMORY_BIT);
   2347                
   2348                if (config_settings_modified & MASKA_CHANGED_CONFIGURATION)
   2349                {
   2350                  //Записуємо час останньої зміни конфігурації
   2351                  uint8_t *label_to_time_array;
   2352                  if (copying_time == 0) label_to_time_array = time;
   2353                  else label_to_time_array = time_copy;
   2354                  
   2355                  for (size_t i = 0; i < 7; i++) current_config_prt.time_config[i] = current_config.time_config[i] = current_config_edit.time_config[i] = *(label_to_time_array + i);
   2356                  current_config_prt.time_config[7] = current_config.time_config[7] = current_config_edit.time_config[7] = (uint8_t)(source & 0xff);
   2357                  
   2358                  _SET_BIT(control_i2c_taskes, TASK_START_WRITE_CONFIG_EEPROM_BIT);
   2359                  
   2360                  //Зміна конфігурції може змінити розміри налаштувань. а це може вплинути на розміщення триґерної інформації, тому її також записуємо
   2361          //        _SET_BIT(control_i2c_taskes, TASK_START_WRITE_TRG_FUNC_EEPROM_BIT);
   2362                }
   2363                
   2364                //Записуємо час останньої зміни конфігурації
   2365                uint8_t *label_to_time_array;
   2366                if (copying_time == 0) label_to_time_array = time;
   2367                else label_to_time_array = time_copy;
   2368                  
   2369                for (size_t i = 0; i < 7; i++) settings_fix_prt.time_setpoints[i] = settings_fix.time_setpoints[i] = settings_fix_edit.time_setpoints[i] = *(label_to_time_array + i);
   2370                settings_fix_prt.time_setpoints[7] = settings_fix.time_setpoints[7] = settings_fix_edit.time_setpoints[7] = (uint8_t)(source & 0xff);
   2371                
   2372                _SET_BIT(control_i2c_taskes, TASK_START_WRITE_SETTINGS_EEPROM_BIT);
   2373              }
   2374              else if (result == DYN_MEM_NO_ENOUGH_MEM) 
   2375              {
   2376                _SET_BIT(set_diagnostyka, ERROR_NO_FREE_DYNAMIC_MEMORY_BIT);
   2377                
   2378                error = 1;
   2379              }
   2380              else 
   2381              {
   2382                _SET_BIT(set_diagnostyka, ERROR_NO_FREE_DYNAMIC_MEMORY_BIT);
   2383                
   2384                error = 2;
   2385              }
   2386            }
   2387            
   2388            if (
   2389                (error == 1) ||
   2390                (direction == 0)
   2391               ) 
   2392            {
   2393              //Повернення до стану до редагування
   2394              if (
   2395                  (error == 1) ||
   2396                  (config_settings_modified & MASKA_CHANGED_CONFIGURATION)
   2397                 )   
   2398              {
   2399                //Відбувалися зміни у конфігурації
   2400          
   2401                //Необхідно по даних "для захистів" відновити дані у "контейнері" і "для редагування"
   2402                __result_dym_mem_select          result = allocate_dynamic_memory_for_settings(RESTORE_DYN_MEM, false, sca_of_p     , spca_of_p_prt, &current_config     , &current_config_prt, &current_config_prt);
   2403                if (result == DYN_MEM_SELECT_OK) result = allocate_dynamic_memory_for_settings(RESTORE_DYN_MEM, false, sca_of_p_edit, sca_of_p     , &current_config_edit, &current_config    , &current_config    );
   2404                
   2405                if (result != DYN_MEM_SELECT_OK) 
   2406                {
   2407                  _SET_BIT(set_diagnostyka, ERROR_NO_FREE_DYNAMIC_MEMORY_BIT);
   2408                  error = 2;
   2409                }
   2410                else if (error == 0)
   2411                {
   2412                  _SET_BIT(clear_diagnostyka, ERROR_NO_FREE_DYNAMIC_MEMORY_BIT);
   2413                }
   2414              }
   2415              
   2416              if (
   2417                  (error == 1) ||
   2418                  (config_settings_modified & MASKA_CHANGED_SETTINGS)
   2419                 )   
   2420              {
   2421                //Відновлюємо зміни у налаштуваннях
   2422                copy_settings(&current_config_prt, &settings_fix     , &settings_fix_prt, sca_of_p     , spca_of_p_prt);
   2423                copy_settings(&current_config    , &settings_fix_edit, &settings_fix    , sca_of_p_edit, sca_of_p     );
   2424              }
   2425                  
   2426            }
   2427            
   2428            return error;
   2429          }
   2430          /*****************************************************/
   2431          
   2432          /*****************************************************/
   2433          //Функція обновлення змінних при зміні конфігурації
   2434          /*****************************************************/
   2435          __result_dym_mem_select action_after_changing_of_configuration(void)
   2436          {
   2437            /*
   2438            Так, як функція allocate_dynamic_memory_for_settings встановлює нову конфінурацію і виділяє пам'ять під неї,
   2439            а ми вже значення у конфігурацї змінили у стурктурі для редагування current_config_edit,
   2440            то цю структуру спочатку копіюємо у тимчасову структуру, відновлюємо попереднє значення
   2441            і тоді вже функцією allocate_dynamic_memory_for_settings виконуємо дії по встановленні нової конфігурації і виділенні
   2442            динамічної пам'яті
   2443            */
   2444            __CONFIG current_config_tmp = current_config_edit;
   2445            current_config_edit = current_config;
   2446            __result_dym_mem_select result = allocate_dynamic_memory_for_settings(REMAKE_DYN_MEM, false, sca_of_p_edit, sca_of_p, &current_config_edit, &current_config_tmp , &current_config);
   2447            if (result == DYN_MEM_SELECT_OK) 
   2448            {
   2449              result = allocate_dynamic_memory_for_settings(REMAKE_DYN_MEM, false, sca_of_p, spca_of_p_prt, &current_config, &current_config_edit, &current_config_prt);
   2450              if (result == DYN_MEM_NO_ENOUGH_MEM)
   2451              {
   2452                //Треба відновити у пам'яті для редагування попередню конфігурацію
   2453                __result_dym_mem_select result_1 =  allocate_dynamic_memory_for_settings(RESTORE_DYN_MEM, false, sca_of_p_edit, sca_of_p, &current_config_edit, &current_config, &current_config);
   2454                if (result_1 == DYN_MEM_SELECT_OK) 
   2455                {
   2456                  //Відновлюємо зміни у налаштуваннях
   2457                  copy_settings(&current_config, &settings_fix_edit, &settings_fix, sca_of_p_edit, sca_of_p);
   2458                }
   2459                else result = DYN_MEM_TOTAL_ERROR;
   2460              }
   2461            }
   2462            if (result == DYN_MEM_SELECT_OK)
   2463            {
   2464              uint32_t number[NUMBER_ALL_BLOCKS] = {
   2465                                                    1,
   2466                                                    current_config.n_input, 
   2467                                                    current_config.n_output,
   2468                                                    current_config.n_led, 
   2469                                                    current_config.n_alarm,
   2470                                                    current_config.n_group_alarm,
   2471                                                    current_config.n_and,
   2472                                                    current_config.n_or,
   2473                                                    current_config.n_xor,
   2474                                                    current_config.n_not,
   2475                                                    current_config.n_timer,
   2476                                                    current_config.n_trigger,
   2477                                                    current_config.n_meander
   2478                                                   };
   2479              for (enum _id_fb i = _ID_FB_FIRST_VAR; i < _ID_FB_LAST_VAR; i++)
   2480              {
   2481                if (
   2482                    (i != ID_FB_GROUP_ALARM) &&
   2483                    (i != ID_FB_INPUT) &&
   2484                    (i != ID_FB_MEANDER)
   2485                   )
   2486                {
   2487                  uint32_t *p_param, *p_param_edit;
   2488                  intptr_t _n;
   2489                  unsigned int moveable_inputs = false;
   2490                  for (size_t j = 0; j < number[i - _ID_FB_FIRST_ALL]; j++)
   2491                  {
   2492                    switch (i)
   2493                    {
   2494                    case ID_FB_OUTPUT:
   2495                      {
   2496                        _n = OUTPUT_SIGNALS_IN;
   2497                        p_param      = (((__settings_for_OUTPUT*)sca_of_p[i - _ID_FB_FIRST_VAR])[j].param);
   2498                        p_param_edit = (((__settings_for_OUTPUT*)sca_of_p_edit[i - _ID_FB_FIRST_VAR])[j].param);
   2499                        break;
   2500                      }
   2501                    case ID_FB_LED:
   2502                      {
   2503                        _n = LED_SIGNALS_IN;
   2504                        p_param      = (((__settings_for_LED*)sca_of_p[i - _ID_FB_FIRST_VAR])[j].param);
   2505                        p_param_edit = (((__settings_for_LED*)sca_of_p_edit[i - _ID_FB_FIRST_VAR])[j].param);
   2506                        break;
   2507                      }
   2508                    case ID_FB_ALARM:
   2509                      {
   2510                        _n = ALARM_SIGNALS_IN;
   2511                        p_param      = (((__settings_for_ALARM*)sca_of_p[i - _ID_FB_FIRST_VAR])[j].param);
   2512                        p_param_edit = (((__settings_for_ALARM*)sca_of_p_edit[i - _ID_FB_FIRST_VAR])[j].param);
   2513                        break;
   2514                      }
   2515                    case ID_FB_AND:
   2516                      {
   2517                        _n = AND_SIGNALS_IN;
   2518                        moveable_inputs = true;
   2519                        p_param      = (((__settings_for_AND*)sca_of_p[i - _ID_FB_FIRST_VAR])[j].param);
   2520                        p_param_edit = (((__settings_for_AND*)sca_of_p_edit[i - _ID_FB_FIRST_VAR])[j].param);
   2521                        break;
   2522                      }
   2523                    case ID_FB_OR:
   2524                      {
   2525                        _n = OR_SIGNALS_IN;
   2526                        moveable_inputs = true;
   2527                        p_param      = (((__settings_for_OR*)sca_of_p[i - _ID_FB_FIRST_VAR])[j].param);
   2528                        p_param_edit = (((__settings_for_OR*)sca_of_p_edit[i - _ID_FB_FIRST_VAR])[j].param);
   2529                        break;
   2530                      }
   2531                    case ID_FB_XOR:
   2532                      {
   2533                        _n = 2;
   2534                        moveable_inputs = true;
   2535                        p_param      = (((__settings_for_XOR*)sca_of_p[i - _ID_FB_FIRST_VAR])[j].param);
   2536                        p_param_edit = (((__settings_for_XOR*)sca_of_p_edit[i - _ID_FB_FIRST_VAR])[j].param);
   2537                        break;
   2538                      }
   2539                    case ID_FB_NOT:
   2540                      {
   2541                        _n = 1;
   2542                        p_param      = &(((__settings_for_NOT*)sca_of_p[i - _ID_FB_FIRST_VAR])[j].param);
   2543                        p_param_edit = &(((__settings_for_NOT*)sca_of_p_edit[i - _ID_FB_FIRST_VAR])[j].param);
   2544                        break;
   2545                      }
   2546                    case ID_FB_TIMER:
   2547                      {
   2548                        _n = TIMER_SIGNALS_IN;
   2549                        p_param      = (((__settings_for_TIMER*)sca_of_p[i - _ID_FB_FIRST_VAR])[j].param);
   2550                        p_param_edit = (((__settings_for_TIMER*)sca_of_p_edit[i - _ID_FB_FIRST_VAR])[j].param);
   2551                        break;
   2552                      }
   2553                    case ID_FB_TRIGGER:
   2554                      {
   2555                        _n = TRIGGER_SIGNALS_IN;
   2556                        p_param      = (((__settings_for_TRIGGER*)sca_of_p[i - _ID_FB_FIRST_VAR])[j].param);
   2557                        p_param_edit = (((__settings_for_TRIGGER*)sca_of_p_edit[i - _ID_FB_FIRST_VAR])[j].param);
   2558                        break;
   2559                      }
   2560                    default:
   2561                      {
   2562                        //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
   2563                        total_error_sw_fixed(76);
   2564                      }
   2565                    }
   2566                  
   2567                    intptr_t shift = 0;
   2568                    for (intptr_t k = 0; k < _n; k++)
   2569                    {
   2570                      uint32_t param_input = *(p_param + k - shift);
   2571                      unsigned int id_input   = (param_input >> SFIFT_PARAM_ID ) & MASKA_PARAM_ID ;
   2572                      unsigned int n_input    = (param_input >> SFIFT_PARAM_N  ) & MASKA_PARAM_N  ;
   2573          //            unsigned int out_input  = (param_input >> SFIFT_PARAM_OUT) & MASKA_PARAM_OUT;
   2574                    
   2575                      //Робимо зміщення параметрування, щоб не було пропусків
   2576                      if (n_input > number[id_input - _ID_FB_FIRST_ALL])
   2577                      {
   2578                        *(p_param + k - shift) = *(p_param_edit + k - shift) = 0;
   2579                      
   2580                        if (
   2581                            (_n > 1) &&
   2582                            (moveable_inputs != false)  
   2583                           )
   2584                        {
   2585                          for (intptr_t l = (k + 1); l < _n; l++)
   2586                          {
   2587                            *(p_param + (l - 1) - shift) = *(p_param_edit + (l - 1) - shift) = *(p_param + l - shift);
   2588                          }
   2589                          *(p_param + (_n - 1) - shift) = *(p_param_edit + (_n - 1) - shift) = 0;
   2590                          
   2591                          shift++;
   2592                        }
   2593                      }
   2594                    }
   2595                  }
   2596                }
   2597              }
   2598            }
   2599            
   2600            return result;
   2601          }
   2602          /*****************************************************/
   2603          
   2604          /*****************************************************/
   2605          /*****************************************************/
   2606          //
   2607          /*****************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     168   action_after_changing_of_configuration
       168   -> __aeabi_memcpy4
       168   -> allocate_dynamic_memory_for_settings
       168   -> copy_settings
       168   -> total_error_sw_fixed
      64   allocate_dynamic_memory_for_settings
        64   -- Indirect call
        64   -> free
        64   -> realloc
        64   -> total_error_sw_fixed
       0   calculate_namber_bit_waiting_for_rs_485
      68   changing_diagnostyka_state
      16   control_config
      16   control_info_rejestrator
      48   control_settings
        48   -> total_error_sw_fixed
      20   control_ustuvannja
      48   copy_settings
        48   -- Indirect call
        48   -> __aeabi_memcpy4
        48   -> total_error_sw_fixed
      32   copy_settings_ALARM
        32   -> total_error_sw_fixed
      40   copy_settings_AND
        40   -> total_error_sw_fixed
      32   copy_settings_GROUP_ALARM
        32   -> total_error_sw_fixed
      32   copy_settings_INPUT
        32   -> total_error_sw_fixed
      32   copy_settings_LED
        32   -> total_error_sw_fixed
      32   copy_settings_MEANDER
        32   -> total_error_sw_fixed
      32   copy_settings_NOT
        32   -> total_error_sw_fixed
      40   copy_settings_OR
        40   -> total_error_sw_fixed
      32   copy_settings_OUTPUT
        32   -> total_error_sw_fixed
      32   copy_settings_TIMER
        32   -> total_error_sw_fixed
      40   copy_settings_TRIGGER
        40   -> total_error_sw_fixed
      40   copy_settings_XOR
        40   -> total_error_sw_fixed
      12   count_number_set_bit
      16   min_settings_ALARM
      16   min_settings_AND
      16   min_settings_GROUP_ALARM
      16   min_settings_INPUT
      16   min_settings_LED
      16   min_settings_MEANDER
      16   min_settings_NOT
      16   min_settings_OR
      16   min_settings_OUTPUT
      16   min_settings_TIMER
      16   min_settings_TRIGGER
      16   min_settings_XOR
     112   set_config_and_settings
       112   -> __aeabi_memcpy4
       112   -> allocate_dynamic_memory_for_settings
       112   -> calculate_namber_bit_waiting_for_rs_485
       112   -> copy_settings
       112   -> new_level_menu
      16   size_all_settings
        16   -> total_error_sw_fixed
       0   str_to_int_DATE_Mmm


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable10
       4  ??DataTable10_1
       4  ??DataTable10_10
       4  ??DataTable10_11
       4  ??DataTable10_12
       4  ??DataTable10_13
       4  ??DataTable10_14
       4  ??DataTable10_15
       4  ??DataTable10_16
       4  ??DataTable10_17
       4  ??DataTable10_18
       4  ??DataTable10_19
       4  ??DataTable10_2
       4  ??DataTable10_20
       4  ??DataTable10_21
       4  ??DataTable10_22
       4  ??DataTable10_23
       4  ??DataTable10_24
       4  ??DataTable10_25
       4  ??DataTable10_26
       4  ??DataTable10_27
       4  ??DataTable10_28
       4  ??DataTable10_29
       4  ??DataTable10_3
       4  ??DataTable10_30
       4  ??DataTable10_31
       4  ??DataTable10_32
       4  ??DataTable10_33
       4  ??DataTable10_4
       4  ??DataTable10_5
       4  ??DataTable10_6
       4  ??DataTable10_7
       4  ??DataTable10_8
       4  ??DataTable10_9
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
       4  ??DataTable6
       4  ??DataTable6_1
       4  ??DataTable6_10
       4  ??DataTable6_11
       4  ??DataTable6_12
       4  ??DataTable6_13
       4  ??DataTable6_14
       4  ??DataTable6_15
       4  ??DataTable6_16
       4  ??DataTable6_17
       4  ??DataTable6_18
       4  ??DataTable6_19
       4  ??DataTable6_2
       4  ??DataTable6_20
       4  ??DataTable6_21
       4  ??DataTable6_22
       4  ??DataTable6_23
       4  ??DataTable6_24
       4  ??DataTable6_25
       4  ??DataTable6_26
       4  ??DataTable6_27
       4  ??DataTable6_28
       4  ??DataTable6_3
       4  ??DataTable6_4
       4  ??DataTable6_5
       4  ??DataTable6_6
       4  ??DataTable6_7
       4  ??DataTable6_8
       4  ??DataTable6_9
      12  ?_0
      52  ?_1
    1092  action_after_changing_of_configuration
    1570  allocate_dynamic_memory_for_settings
     128  calculate_namber_bit_waiting_for_rs_485
    1062  changing_diagnostyka_state
     114  control_config
      48  control_info_rejestrator
     966  control_settings
     170  control_ustuvannja
     380  copy_settings
     296  copy_settings_ALARM
     140  copy_settings_AND
     330  copy_settings_GROUP_ALARM
     180  copy_settings_INPUT
     216  copy_settings_LED
     148  copy_settings_MEANDER
      96  copy_settings_NOT
     140  copy_settings_OR
     216  copy_settings_OUTPUT
     242  copy_settings_TIMER
     140  copy_settings_TRIGGER
     140  copy_settings_XOR
      42  count_number_set_bit
     162  min_settings_ALARM
      96  min_settings_AND
     166  min_settings_GROUP_ALARM
      98  min_settings_INPUT
     114  min_settings_LED
      90  min_settings_MEANDER
      68  min_settings_NOT
      96  min_settings_OR
     114  min_settings_OUTPUT
     170  min_settings_TIMER
      92  min_settings_TRIGGER
      92  min_settings_XOR
      36  month_names
    1030  set_config_and_settings
     224  size_all_settings
     108  str_to_int_DATE_Mmm

 
    100 bytes in section .rodata
 10 876 bytes in section .text
 
 10 876 bytes of CODE  memory
    100 bytes of CONST memory

Errors: none
Warnings: none
