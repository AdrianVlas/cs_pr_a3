###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       24/Mar/2017  12:55:00
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\v_A_shm\Shematic.cpp
#    Command line =  
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\v_A_shm\Shematic.cpp" -D USE_STDPERIPH_DRIVER -D STM32F2XX -D
#        USE_USB_OTG_FS -D SYSTEM_VIEWER_ENABLE -lc
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List" -lB
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List" --remarks -o
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --enable_multibytes --fpu=None
#        --dlib_config G:\PRG\IAR7_50_2\arm\INC\c\DLib_Config_Full.h -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\usb\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_OTG_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Core\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\"
#        -I "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\Config\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\OS\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\SEGGER\" -On --eec++ -I
#        G:\PRG\IAR7_50_2\arm\CMSIS\Include\ -D ARM_MATH_CM3
#    List file    =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List\Shematic.lst
#    Object file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj\Shematic.o
#
###############################################################################

G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working files\v_A_shm\Shematic.cpp
      1          #ifdef VISUAL_STUDIO
      2          #include "StdAfx.h"
      3          #endif
      4          #include <stdlib.h>
      5          #include "Shematic.h"
      6          //#include "StructElem.h"
      7          #include "BaseInPoint.h"
      8          #include "InPoint.h"
      9          #include "ExtPoint.h"
     10          #include "LUBase.h"
     11          #include "LUNot_1_1.h"
     12          #include "LUDInput_0_1.h"
     13          #include "LUDout_1_0.h"
     14          #include "LUDInput_0_1.h"
     15          #include "LULed.h"
     16          #include "LUAnd_8_1.h"
     17          #include "LUOr_8_1.h"
     18          #include "LUXor_8_1.h"
     19          #include "Mft.h"
     20          
     21          //#include <conio.h>
     22          #include <string.h>
     23          #include <ctime>
     24          #include "stng.h"
     25          __CONFIG_CPP preSetUP = {
     26              0, //uint32_t device_id;
     27              10, 10, 10,
     28              1, //uint32_t n_and;
     29              1, //uint32_t n_or;
     30              1, //uint32_t n_xor;
     31              1, //uint32_t n_not;
     32              1, //uint32_t n_timers;
     33              1, //uint32_t n_triggers;
     34              1, //uint32_t n_alarms;
     35              1, //uint32_t n_meanders;
     36              2, 2, 2, 2, 2, 2, 2, 2//uint8_t time_config[7+1];
     37          
     38          };
     39          
     40          long long LL_CryaCrya @ "NonZeroIniVars_RAM1" = 15;
     41          
     42          UNN_LogicUnitArea gLUAreaMem @ "NonZeroIniVars_RAM1" = {
     43          
     44          };
     45          
     46          LUAreaAuxVar gblLUAreaAuxVar  = {
     47              0, //.short shAmountPlacedLogicUnit;//counter placed
     48              0, //.short shIdxLUAreaListElem;    //Index LU Area List Elem
     49              (SIZE_MEM_BLK - sizeof (LUAreaListElem)), sizeof (LUAreaListElem), //.long  lAmountFreeMem, lAmountUsedMem;
     50               static_cast<void*>( &(gLUAreaMem.chArRamPrgEvt[((SIZE_MEM_BLK) - 1)])),
     51          	static_cast<void*>(0)
     52          
     53          };
     54          
     55          
     56          
     57          /*
     58          //Declare 5 Points & 1 struct element
     59          InPoint ar5Points[TOTAL_POINTS];
     60          StructElem s3And = StructElem(3);
     61           */
     62          
     63          UNN_LogicUnitArea lcUArea;
     64          short shAmountTotalElem = 0;
     65          long lAmountOccupyMem = 0;
     66          //long lIdxHead
     67          //long lIdxTail
     68          short shIdxLUnit = 0;
     69          //Next List Header
     70          //Prev List Header
     71          //Insert function
     72          //Delete function
     73          /*
     74          *	Main Object
     75          *
     76          */
     77          Shematic sh;
     78          char chGblGround = 0;
     79          char chGblVcc    = 1;
     80          
     81          Shematic::Shematic(void) {
     82              //Debug Code
     83              ar_n_Output_Dsc[0].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_OrdNumOut
     84                      = ar_n__Output_Dsc[0].bfInfo_OrdNumOut;
     85              ar_n_Output_Dsc[0].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_OrdNumStng
     86                      = ar_n__Output_Dsc[0].bfInfo_OrdNumStng;
     87              ar_n_Output_Dsc[0].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_IdLUStng
     88                      = ar_n__Output_Dsc[0].bfInfo_IdLUStng;
     89              //Debug Code 
     90          	LL_CryaCrya++;
     91              chInitTerminated = 0;
     92              
     93          }
     94          
     95          void Shematic::Init(void) {
     96          Init2();
     97          chInitTerminated = 1;
     98          }
     99          
    100          void Shematic::DoCalc(void) {
    101          
    102              register long i, j;
    103              register void* pv;
    104          
    105              struct {
    106                  //long lId,lsizeobj;
    107                  short shAmountCalcLU, shRes;
    108                  void *pV;
    109                  LUAreaListElem* arrLUAreaListElem;
    110                  CLUBase* pCLUBase;
    111              } sLV;
    112              sLV.shAmountCalcLU = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
    113              sLV.arrLUAreaListElem = &gLUAreaMem.headLUAreaList;
    114              i = 0;
    115              if(chInitTerminated == 0)
    116                  return;
    117              //j = ar_n_Output_Dsc[0].UN_BitFld_LUInInfo.lArUrgData[0];
    118              //j+= ar_n__Output_Dsc[0].bfInfo_OrdNumOut;
    119              //j+= ghj.UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_IdLUStng;
    120              while (sLV.shAmountCalcLU--) {
    121                  pv = reinterpret_cast<void*>( &sLV.arrLUAreaListElem[i]);
    122                  sLV.pCLUBase = reinterpret_cast<CLUBase*>( (reinterpret_cast<LUAreaListElem*> (pv))->pvLU);//(CLUBase*)
    123                  pv = reinterpret_cast<void*>( sLV.pCLUBase); //->LogicFunc;
    124                  if ((reinterpret_cast<CLUBase*>( pv))->shShemasOrdNumStng != 0 //&&
    125                          ) {
    126                      j = (reinterpret_cast<CLUBase*>( pv))->shShemasIdLUStng;
    127                      switch (j) {
    128                          case STNG_EXTENDED:
    129                              break;
    130                          default:
    131                          {
    132                              if (j > STNG_EXTENDED && j < STNG_LU_UPPER_BOUND) {
    133                                  if ((reinterpret_cast<CLUBase*>( pv))->LogicFunc != Null_OP) {
    134                                      (reinterpret_cast<CLUBase*>( pv))->LogicFunc( reinterpret_cast<void*>(sLV.pCLUBase));
    135                                  }
    136          
    137                              }
    138                          }
    139                      }
    140          
    141                  }
    142                  i++;
    143              }
    144          }
    145          
    146          Shematic::~Shematic(void) {
    147          }
    148          
    149          void Shematic::printResult(void) {
    150              /*    int c = 0;
    151                  long lIdxPoint = NUM_IN_POINTS;
    152                  char chAmtInitPoints = NUM_OUT_POINTS-1;
    153                  InPoint*pInPont = &ar5Points[lIdxPoint];
    154                  printf("Result schematic:\n");
    155                  do{
    156                      printf("State ar5Points[");printf("%hhX %s",lIdxPoint,"]=");
    157                      putchar((int)pInPont ->chState+0x30);printf(" \n");
    158                      lIdxPoint++;
    159                      pInPont = &ar5Points[lIdxPoint];//Next Pointer
    160          
    161                  }while(chAmtInitPoints--);
    162                  pInPont = &ar5Points[lIdxPoint];
    163          
    164                  c = getch();*/
    165          
    166          }
    167          
    168          void Shematic::PrintPointsState(void) {
    169              //Print state All Points which Shematic Use
    170              //Name Logic Unit
    171          }
    172          
    173          void Shematic::PrintShematicElemPointsState(void) {
    174              //Print Only Points Using?
    175          }
    176          
    177          //void Shematic::SetupCircutLinks(void *pv) {
    178          //    //register long ik;
    179          //    Init2LcVarArea& rsLV  = *((Init2LcVarArea*)pv);
    180          //    rsLV.arrLUAreaListElem = &gLUAreaMem.headLUAreaList;
    181          //}
    182          //#ifdef RAND_MAX
    183          // #define RAND_MAX 256
    184          //#endif
    185          //static long first_value,last_value;
    186          //random_number = first_value + rand() % last_value;
    187          static long arNum[300] @ "ZeroInivars_RAM1";
    188          static short shCounterCalls_GLB;
    189          long Shematic::GetTrueOrderNum(void) {
    190              register long i, j;
    191          
    192              struct {
    193                  char chNeedAnotherNumber, chCtrCalls;
    194              } sLV;
    195              volatile long random_number;
    196              sLV.chNeedAnotherNumber = 0;
    197              srand(time(0));
    198              //i = (long) rand() % 255; //255 Max diapason
    199              i = static_cast<long>(rand() % 255); //255 Max diapason
    200          
    201              random_number = i + 1; //1 - min diapason
    202              sLV.chCtrCalls = 0;
    203              do {
    204          
    205                  for (j = 0; j < 300 && arNum[j] != 0; j++) {
    206          
    207                      if (random_number == arNum[j]) {
    208                          j = 300;
    209                          sLV.chNeedAnotherNumber = 1;
    210                          break;
    211                      }
    212                      if(arNum[j+1] == 0){
    213                          sLV.chNeedAnotherNumber = 0;
    214                          break;
    215                      }
    216                  }
    217                  //Another Number
    218                  if (sLV.chNeedAnotherNumber) {
    219                      sLV.chCtrCalls++;
    220                      i = static_cast<long>( rand() % 255); //255 Max diapason
    221                      random_number = i + 1;
    222                  }
    223              } while (sLV.chNeedAnotherNumber && sLV.chCtrCalls < 250);
    224              if (sLV.chCtrCalls >= 250) {
    225                  //Clr Mem
    226                  for (j = 0; j < 300; j++)
    227                      arNum[j] = 0;
    228                  shCounterCalls_GLB = 0;
    229              }
    230              i = shCounterCalls_GLB;
    231              arNum[i] = random_number;
    232              shCounterCalls_GLB = i+1;
    233          
    234              return random_number;
    235          }
    236          
    237          void Shematic::CreateTestSchema(void) {
    238              /*
    239              register long i,j;
    240              void* pv;
    241              struct
    242                  {
    243                      //short shAmtLU,shIdxLUOut;//
    244                              long lOrderNumber;
    245                      short shAmtLUDsc,shIdx;
    246                              short shIdxLUOutDsc, shIdxLU;
    247                              //SBitFld_LUInInfo locSBitFld;
    248          		 
    249                  } sLV;
    250          
    251          		
    252                      //sLV.locSBitFldCRefInfo = 
    253                      //SetUP DOUT
    254                      //Form Additional Info
    255                      sLV.shAmtLUDsc = preSetUP.n_and;
    256                      sLV.shIdxLUOutDsc = sLV.shIdxLU = sLV.shIdx = 0;// 
    257                      sLV.shIdxLUOutDsc = MAX_AMOUNT_LU_OUTPUT+MAX_AMOUNT_LU_LED;
    258                      //SetUP Led
    259                      //SetUP And
    260                      while(sLV.shIdx < sLV.shAmtLUDsc){
    261          		
    262                              sLV.lOrderNumber = GetTrueOrderNum();//Take OrdNum F-Block From Taras Area
    263                              locSBitFldCRefInfo.bfInfo_OrdNumOut  = 1;//Now use All ones
    264                              locSBitFldCRefInfo.bfInfo_IdLUStng   = STNG_LU_INPUT;
    265                              locSBitFldCRefInfo.bfInfo_BaseID     = sLV.lOrderNumber;
    266                              for (long j = 0; j < 8 ; j++){//Create data for each Input
    267                                      locSBitFldCRefInfo.bfInfo_OrdNumStng = ORD_INPUT_01+j;
    268                                      arrSBitFldCRefInfo[sLV.shIdxLUOutDsc+j] = locSBitFldCRefInfo;
    269                              }
    270                              //locSBitFld.bfInfo_OrdNumOut 
    271                              //locSBitFld.bfInfo_OrdNumStng
    272                              //locSBitFld.bfInfo_IdLUStng  
    273                      }
    274          
    275          	
    276                      //SetUP OR
    277                      sLV.shIdxLUOutDsc = MAX_AMOUNT_LU_OUTPUT+MAX_AMOUNT_LU_LED
    278                      +(MAX_AMOUNT_LU_AND*8);
    279                      sLV.shAmtLUDsc = preSetUP.n_or;sLV.shIdx = 0;
    280                      while(sLV.shIdx < sLV.shAmtLUDsc){
    281          		
    282                              sLV.lOrderNumber = GetTrueOrderNum();//Take OrdNum F-Block From Taras Area
    283                              locSBitFldCRefInfo.bfInfo_OrdNumOut  = 1;//Now use All ones
    284                              locSBitFldCRefInfo.bfInfo_IdLUStng   = STNG_LU_INPUT;
    285                              locSBitFldCRefInfo.bfInfo_BaseID     = sLV.lOrderNumber;
    286                              for (long j = 0; j < 8 ; j++){//Create data for each Input
    287                                      locSBitFldCRefInfo.bfInfo_OrdNumStng = ORD_INPUT_01+j;
    288                                      arrSBitFldCRefInfo[sLV.shIdxLUOutDsc+j] = locSBitFldCRefInfo;
    289                              }
    290                              //locSBitFld.bfInfo_OrdNumOut 
    291                              //locSBitFld.bfInfo_OrdNumStng
    292                              //locSBitFld.bfInfo_IdLUStng  
    293                      }
    294                      //SetUP XOR
    295                      sLV.shIdxLUOutDsc = MAX_AMOUNT_LU_OUTPUT+MAX_AMOUNT_LU_LED
    296                      +(MAX_AMOUNT_LU_AND*8)+(MAX_AMOUNT_LU_OR*8 );
    297                      sLV.shAmtLUDsc = preSetUP.n_xor;sLV.shIdx = 0;
    298                      while(sLV.shIdx < sLV.shAmtLUDsc){
    299          		
    300                              sLV.lOrderNumber = GetTrueOrderNum();//Take OrdNum F-Block From Taras Area
    301                              locSBitFldCRefInfo.bfInfo_OrdNumOut  = 1;//Now use All ones
    302                              locSBitFldCRefInfo.bfInfo_IdLUStng   = STNG_LU_INPUT;
    303                              locSBitFldCRefInfo.bfInfo_BaseID     = sLV.lOrderNumber;
    304                              for (long j = 0; j < 8 ; j++){//Create data for each Input
    305                                      locSBitFldCRefInfo.bfInfo_OrdNumStng = ORD_INPUT_01+j;
    306                                      arrSBitFldCRefInfo[sLV.shIdxLUOutDsc+j] = locSBitFldCRefInfo;
    307                              }
    308                              //locSBitFld.bfInfo_OrdNumOut 
    309                              //locSBitFld.bfInfo_OrdNumStng
    310                              //locSBitFld.bfInfo_IdLUStng  
    311                      }
    312                      //SetUP NOT
    313                      sLV.shIdxLUOutDsc = MAX_AMOUNT_LU_OUTPUT+MAX_AMOUNT_LU_LED
    314                      +(MAX_AMOUNT_LU_AND*8)+(MAX_AMOUNT_LU_OR*8 )+(MAX_AMOUNT_LU_XOR*2);
    315                      sLV.shAmtLUDsc = preSetUP.n_not;sLV.shIdx = 0;
    316                      while(sLV.shIdx < sLV.shAmtLUDsc){
    317          		
    318                              sLV.lOrderNumber = GetTrueOrderNum();//Take OrdNum F-Block From Taras Area
    319                              locSBitFldCRefInfo.bfInfo_OrdNumOut  = 1;//Now use All ones
    320                              locSBitFldCRefInfo.bfInfo_IdLUStng   = STNG_LU_INPUT;
    321                              locSBitFldCRefInfo.bfInfo_BaseID     = sLV.lOrderNumber;
    322                              for (long j = 0; j < 8 ; j++){//Create data for each Input
    323                                      locSBitFldCRefInfo.bfInfo_OrdNumStng = ORD_INPUT_01+j;
    324                                      arrSBitFldCRefInfo[sLV.shIdxLUOutDsc+j] = locSBitFldCRefInfo;
    325                              }
    326                              //locSBitFld.bfInfo_OrdNumOut 
    327                              //locSBitFld.bfInfo_OrdNumStng
    328                              //locSBitFld.bfInfo_IdLUStng  
    329                      }
    330               */
    331          }
    332          
    333          struct GlobalObjectMap_tag {
    334          
    335              CLUDInput_0_1 *arPCLUDInput_0_1[MAX_AMOUNT_LU_INPUT]; //NUM_STNG_IN
    336              CLUDout_1_0   *arPCLUDout_1_0  [MAX_AMOUNT_LU_OUTPUT]; //NUM_STNG_OUT
    337              CLULed        *arPCLULed       [MAX_AMOUNT_LU_LED]; //NUM_STNG_LED
    338              CLUNot_1_1    *arPCLUNot_1_1   [MAX_AMOUNT_LU_NOT];
    339              CLUOr_8_1     *arPCLUOr_8_1    [MAX_AMOUNT_LU_OR];
    340              CLUAnd_8_1    *arPCLUAnd_8_1   [MAX_AMOUNT_LU_AND];
    341              CLUXor_8_1    *arPCLUXor_8_1   [MAX_AMOUNT_LU_XOR];
    342          	CMft          *arCMft          [MAX_AMOUNT_LU_TIMERS];
    343          } GlobalObjectMap @ "variables_RAM1";
    344          //Place 3 Unit
    345          
    346          void Shematic::Init1(void) {
    347              long i, j;
    348              void* pv;
    349              //char **pCh;
    350          
    351              struct {
    352                  char* pCh;
    353                  char** arrPchIn;
    354                  LUAreaListElem* arrLUAreaListElem;
    355                  CLUBase *pCLUBase, *pCLURef;
    356                  void *pV;
    357                  long lId, lsizeobj;
    358                  short shAmtLU, shIdxLUOut; //
    359                  short shAmtLUDsc, shIdx;
    360                  short shIdxLUOutDsc, shIdxLU; //shCountCmd;
    361                  char chVal, chErrCount, chBrk1, chBrk2;
    362                  //unsigned char uchVal;
    363              } sLV;
    364              sLV.shIdx = sLV.shIdxLU = 0;
    365              sLV.chVal = static_cast<char> (preSetUP.n_input);
    366              sLV.arrLUAreaListElem = &gLUAreaMem.headLUAreaList;
    367              sLV.chErrCount = sLV.chBrk1 = sLV.chBrk2 = 0;
    368              sLV.shIdxLUOutDsc = 1;
    369              DetectCircutLinks();
    370              if (sLV.chVal) {
    371          
    372                  CLUDInput_0_1 locCLUDInput_0_1(10, 0); // = CLUDInput_0_1(0,10);
    373                  j = i = 0;
    374                  do {
    375                      j = InsertLU(LU_INPUT, static_cast<void*> (&locCLUDInput_0_1));
    376          
    377                      if (j) {//Success Bield
    378                          //Additional Obj SetUP
    379          
    380                          i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
    381                          pv = static_cast<void*>( &sLV.arrLUAreaListElem[i - 1]);
    382                          sLV.pCLUBase = static_cast<CLUBase*>( ( static_cast<LUAreaListElem*>(pv) )->pvLU);
    383                          sLV.pCLUBase->shShemasIdLUStng = STNG_LU_INPUT;
    384                          //sLV.uchVal = arrSBitFldCRefInfo[sLV.shIdxLUOutDsc-1].bfInfo_BaseID;
    385                          sLV.pCLUBase->shShemasOrdNumStng = static_cast<unsigned char>(arrSBitFldCRefInfo[sLV.shIdxLUOutDsc-1].bfInfo_BaseID);
    386                              sLV.shIdxLUOutDsc++; //Temporary Numeration Discass It!!!!;
    387                          CLUDInput_0_1* locPCLUDInput_0_1 = static_cast<CLUDInput_0_1*>(sLV.pCLUBase);
    388                          locPCLUDInput_0_1->pOut = static_cast<void*>( locPCLUDInput_0_1->arrOut);
    389                          CLUDInput_0_1& locRef_CLUDInput_0_1 = *(static_cast<CLUDInput_0_1*>(sLV.pCLUBase));
    390                          locRef_CLUDInput_0_1.chTypeLogicFunction = LU_OP_READ_DI;
    391                          locRef_CLUDInput_0_1.LogicFunc = READ_DI_Op; //???
    392          
    393                          GlobalObjectMap.arPCLUDInput_0_1[sLV.shIdx++] = static_cast<CLUDInput_0_1*>(sLV.pCLUBase);
    394                          sLV.shIdxLU++;
    395                      }//Else Error
    396          
    397                  } while (sLV.shIdxLU < preSetUP.n_input && j);
    398                  //Check State j
    399              }
    400              sLV.shIdx = 0;
    401              if (preSetUP.n_output != 0) {
    402                  sLV.shIdxLU = 0;
    403                  j = 0;
    404                  CLUDout_1_0 locCLUDout_1_0(10, 0); // = CLUDout_1_0(0,10);
    405                  do {
    406                      j = InsertLU(LU_OUTPUT, static_cast<void*> (&locCLUDout_1_0));
    407                      if (j) {//Success Bield
    408                          //Additional Obj SetUP
    409                          i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
    410                          pv = static_cast<void*>(&sLV.arrLUAreaListElem[i - 1]);
    411                          sLV.pCLUBase = static_cast<CLUBase*>( 
    412                                  (static_cast<LUAreaListElem*>(pv))->pvLU);
    413                          sLV.pCLUBase->shShemasIdLUStng = STNG_LU_OUTPUT;
    414                          sLV.pCLUBase->shShemasOrdNumStng = arrSBitFldCRefInfo[sLV.shIdxLUOutDsc-1].bfInfo_BaseID;
    415                                  sLV.shIdxLUOutDsc++; //Temporary Numeration Discass It!!!!;
    416                          CLUDout_1_0* locPCLUDout_1_0 = static_cast<CLUDout_1_0*>(sLV.pCLUBase);
    417                          locPCLUDout_1_0->pIn = static_cast<void*> (locPCLUDout_1_0->arrPchIn);
    418                          locPCLUDout_1_0->chTypeLogicFunction = LU_OP_SET_OUT;
    419                          locPCLUDout_1_0->LogicFunc = SET_OUT_Op; //???
    420          
    421                          GlobalObjectMap.arPCLUDout_1_0[sLV.shIdx++] = static_cast<CLUDout_1_0*>(sLV.pCLUBase);
    422                          sLV.shIdxLU++;
    423                      }
    424          
    425                  } while (sLV.shIdxLU < preSetUP.n_output && j);
    426              }
    427              sLV.shIdx = 0;
    428              if (preSetUP.n_led != 0) {
    429                  volatile short shIdxLU = 0;
    430                  j = 0; //sLV.shIdxLU = 0;
    431                  CLULed locCLULed(10, 0); // = CLULed(0,10);
    432                  do {
    433                      j = InsertLU(LU_LED, static_cast<void*>(&locCLULed));
    434                      //sLV.shIdxLU++;
    435                      if (j) {//Success Bield
    436                          //Additional Obj SetUP
    437                          i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
    438                          //pv = (void*) &sLV.arrLUAreaListElem[i - 1];
    439                          //sLV.pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
    440          				pv = static_cast<void*>( &sLV.arrLUAreaListElem[i - 1]);
    441                          sLV.pCLUBase = static_cast<CLUBase*>( ( static_cast<LUAreaListElem*>(pv) )->pvLU);
    442                          sLV.pCLUBase->shShemasIdLUStng = STNG_LU_LED;
    443                          sLV.pCLUBase->shShemasOrdNumStng = arrSBitFldCRefInfo[sLV.shIdxLUOutDsc-1].bfInfo_BaseID;
    444                                  sLV.shIdxLUOutDsc++; //Temporary Numeration Discass It!!!!;
    445                          CLULed* locPCLULed = static_cast<CLULed*>(sLV.pCLUBase);
    446                          locPCLULed->pIn = static_cast<void*>(locPCLULed->arrPchIn);
    447                          CLULed& locRef_CLULed = *(static_cast<CLULed*>(sLV.pCLUBase));
    448                          locRef_CLULed.chTypeLogicFunction = LU_OP_SET_LED;
    449                          locRef_CLULed.LogicFunc = SET_LED_Op; //???
    450                          GlobalObjectMap.arPCLULed[sLV.shIdx++] = static_cast<CLULed*>(sLV.pCLUBase);
    451                          shIdxLU++; //
    452                      }
    453          
    454                  } while (shIdxLU < preSetUP.n_led && j);
    455              }
    456              sLV.shIdx = 0;
    457              if (preSetUP.n_and != 0) {
    458                  sLV.shIdxLU = 0;
    459                  j = 0;
    460                  CLUAnd_8_1 locCLUAnd_8_1(10, 0); // = CLUAnd_8_1(0,10);
    461                  do {
    462                      j = InsertLU(LU_AND, static_cast<void*>(&locCLUAnd_8_1));
    463                      if (j) {//Success Bield
    464                          //Additional Obj SetUP
    465                          i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
    466                          //pv = (void*) &sLV.arrLUAreaListElem[i - 1];
    467                          //sLV.pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
    468          				pv = static_cast<void*>( &sLV.arrLUAreaListElem[i - 1]);
    469                          sLV.pCLUBase = static_cast<CLUBase*>( ( static_cast<LUAreaListElem*>(pv) )->pvLU);
    470                          sLV.pCLUBase->shShemasIdLUStng = STNG_LU_AND;
    471                          sLV.pCLUBase->shShemasOrdNumStng = arrSBitFldCRefInfo[sLV.shIdxLUOutDsc-1].bfInfo_BaseID;
    472                                  sLV.shIdxLUOutDsc++; //Temporary Numeration Discass It!!!!;
    473                          CLUAnd_8_1* locPCLUAnd_8_1 = static_cast<CLUAnd_8_1*>(sLV.pCLUBase);
    474                          locPCLUAnd_8_1->pOut = static_cast<void*>(locPCLUAnd_8_1->arrOut  );
    475                          locPCLUAnd_8_1->pIn  = static_cast<void*>(locPCLUAnd_8_1->arrPchIn);
    476                          CLUAnd_8_1& locRef_CLUAnd_8_1 = *(static_cast<CLUAnd_8_1*>(sLV.pCLUBase));
    477                          locRef_CLUAnd_8_1.chTypeLogicFunction = LU_OP_AND; //
    478                          locRef_CLUAnd_8_1.LogicFunc = AND_Op_8_1; //???
    479          
    480                          GlobalObjectMap.arPCLUAnd_8_1[sLV.shIdx++] = static_cast<CLUAnd_8_1*>(sLV.pCLUBase);
    481                          sLV.shIdxLU++;
    482                      }
    483          
    484                  } while (sLV.shIdxLU < preSetUP.n_and && j);
    485              }
    486          
    487              if (preSetUP.n_or != 0) {
    488                  sLV.shIdx = sLV.shIdxLU = 0;
    489                  j = 0;
    490                  CLUOr_8_1 locCLUOr_8_1(10, 0); // = CLUOr_8_1(0,10);
    491                  do {
    492                      j = InsertLU(LU_OR, static_cast<void*>(&locCLUOr_8_1));
    493                      if (j) {//Success Bield
    494                          //Additional Obj SetUP
    495                          i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
    496                          //pv = (void*) &sLV.arrLUAreaListElem[i - 1];
    497                          //sLV.pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
    498          				pv = static_cast<void*>( &sLV.arrLUAreaListElem[i - 1]);
    499                          sLV.pCLUBase = static_cast<CLUBase*>( ( static_cast<LUAreaListElem*>(pv) )->pvLU);
    500                          sLV.pCLUBase->shShemasIdLUStng = STNG_LU_OR;
    501                          sLV.pCLUBase->shShemasOrdNumStng =
    502                                  sLV.shIdxLUOutDsc++; //Temporary Numeration Discass It!!!!;
    503                          CLUOr_8_1* locPCLUOr_8_1 = static_cast<CLUOr_8_1*>(sLV.pCLUBase);
    504                          locPCLUOr_8_1->pOut = static_cast<void*>(locPCLUOr_8_1->arrOut  );
    505                          locPCLUOr_8_1->pIn  = static_cast<void*>(locPCLUOr_8_1->arrPchIn);
    506                          CLUOr_8_1& locRef_CLUOr_8_1 = *(static_cast<CLUOr_8_1*>(sLV.pCLUBase));
    507                          locRef_CLUOr_8_1.LogicFunc(sLV.pCLUBase);
    508                          GlobalObjectMap.arPCLUOr_8_1[sLV.shIdx++] = static_cast<CLUOr_8_1*>(sLV.pCLUBase);
    509                          sLV.shIdxLU++;
    510                      }
    511          
    512                  } while (sLV.shIdxLU < preSetUP.n_or && j);
    513              }
    514              if (preSetUP.n_xor != 0) {
    515                  sLV.shIdx = sLV.shIdxLU = 0;
    516                  j = 0;
    517                  CLUXor_8_1 locCLUXor_8_1(10, 0); // = CLUXor_8_1(0,10);
    518                  do {
    519                      j = InsertLU(LU_XOR, static_cast<void*>(&locCLUXor_8_1));
    520                      if (j) {//Success Bield
    521                          //Additional Obj SetUP
    522                          i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
    523                          //pv = (void*) &sLV.arrLUAreaListElem[i - 1];
    524                          //sLV.pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
    525          				pv = static_cast<void*>( &sLV.arrLUAreaListElem[i - 1]);
    526                          sLV.pCLUBase = static_cast<CLUBase*>( ( static_cast<LUAreaListElem*>(pv) )->pvLU);
    527                          sLV.pCLUBase->shShemasIdLUStng = STNG_LU_XOR;
    528                          sLV.pCLUBase->shShemasOrdNumStng =
    529                                  sLV.shIdxLUOutDsc++; //Temporary Numeration Discass It!!!!;
    530                          CLUXor_8_1* locPCLUXor_8_1 = static_cast<CLUXor_8_1*>(sLV.pCLUBase);
    531                          locPCLUXor_8_1->pOut =  static_cast<void*>(locPCLUXor_8_1->arrOut  );
    532                          locPCLUXor_8_1->pIn  =  static_cast<void*>(locPCLUXor_8_1->arrPchIn);
    533                          CLUXor_8_1& locRef_CLUXor_8_1 = *(static_cast<CLUXor_8_1*>(sLV.pCLUBase));
    534                          locRef_CLUXor_8_1.LogicFunc(sLV.pCLUBase);
    535                          GlobalObjectMap.arPCLUXor_8_1[sLV.shIdx++] = static_cast<CLUXor_8_1*>(sLV.pCLUBase);
    536                          sLV.shIdxLU++;
    537                      }
    538          
    539                  } while (sLV.shIdxLU < preSetUP.n_xor && j);
    540              }
    541              if (preSetUP.n_not != 0) {
    542                  sLV.shIdx = sLV.shIdxLU = 0;
    543                  j = 0;
    544                  CLUNot_1_1 locCLUNot_1_1(10, 0); // = CLUNot_1_1(0,10);
    545                  do {
    546                      j = InsertLU(LU_NOT, static_cast<void*>(&locCLUNot_1_1));
    547                      if (j) {//Success Bield
    548                          //Additional Obj SetUP
    549                          i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
    550                          //pv = (void*) &sLV.arrLUAreaListElem[i - 1];
    551                          //sLV.pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
    552          				pv = static_cast<void*>( &sLV.arrLUAreaListElem[i - 1]);
    553                          sLV.pCLUBase = static_cast<CLUBase*>( ( static_cast<LUAreaListElem*>(pv) )->pvLU);
    554                          sLV.pCLUBase->shShemasIdLUStng = STNG_LU_NOT;
    555                          sLV.pCLUBase->shShemasOrdNumStng =
    556                                  sLV.shIdxLUOutDsc++; //Temporary Numeration Discass It!!!!;
    557                          CLUNot_1_1* locPCLUNot_1_1 = static_cast<CLUNot_1_1*>(sLV.pCLUBase);
    558                          locPCLUNot_1_1->pOut = static_cast<void*>(locPCLUNot_1_1->arrOut  );
    559                          locPCLUNot_1_1->pIn  = static_cast<void*>(locPCLUNot_1_1->arrPchIn);
    560                          CLUNot_1_1& locRef_CLUNot_1_1 = *(static_cast<CLUNot_1_1*>(sLV.pCLUBase));
    561                          locRef_CLUNot_1_1.LogicFunc(sLV.pCLUBase);
    562                          GlobalObjectMap.arPCLUNot_1_1[sLV.shIdx++] = static_cast<CLUNot_1_1*>(sLV.pCLUBase);
    563                          sLV.shIdxLU++;
    564                      }
    565          
    566                  } while (sLV.shIdxLU < preSetUP.n_not && j);
    567              }
    568          
    569              //1 Place points In MemArea
    570              //Place Unit
    571              //If I try delete operation It shold move all data for efficiently
    572              //memory Use
    573          
    574              //SetUP Links
    575              sLV.arrLUAreaListElem = &gLUAreaMem.headLUAreaList;
    576              //Find 1st DO
    577              i = j = sLV.shIdxLUOutDsc = sLV.shIdxLU = 0;
    578              sLV.lId = 0;
    579              pv = static_cast<void*>(&sLV.arrLUAreaListElem[i]); //Last Elem
    580              sLV.shAmtLU = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
    581              sLV.shAmtLUDsc = 10 + 10 + 8 * 1; //Demo Variant
    582              while (sLV.shAmtLUDsc && sLV.chBrk2 == 0) {
    583                  while (sLV.shIdxLU < sLV.shAmtLU && sLV.chBrk1 == 0) {
    584                      i = sLV.shIdxLU;
    585                      pv = static_cast<void*>(&sLV.arrLUAreaListElem[i]);
    586                      sLV.pCLUBase = static_cast<CLUBase*>( (static_cast<LUAreaListElem*>(pv))->pvLU);
    587                      j = sLV.shIdxLUOutDsc;
    588                      if (sLV.pCLUBase->shShemasIdLUStng == ar_n_output_CRDsc[j].shBaseIdLUStng &&
    589                              sLV.pCLUBase->shShemasOrdNumStng == ar_n_output_CRDsc[j].shBaseOrdNumStng) {
    590                          sLV.pV = pv; //save pv
    591                          sLV.chVal = sLV.pCLUBase->chNumOutput;
    592                          for (sLV.shIdx = 0; sLV.shIdx < sLV.pCLUBase->chNumInput; sLV.shIdx++) {//sLV.pCLUBase->chNumOutput
    593                              //Find
    594                              //,,pv = (void*)&sLV.arrLUAreaListElem[0];//Last Elem
    595                              sLV.chVal = 0;
    596                              i = 0;
    597                              sLV.pCh = static_cast<char*>(0);
    598                              j = sLV.shIdxLUOutDsc + sLV.shIdx;
    599                              while (i < sLV.shAmtLU) {
    600                                  pv = static_cast<void*>(&sLV.arrLUAreaListElem[i]);
    601                                  sLV.pCLURef = static_cast<CLUBase*>( (static_cast<LUAreaListElem*>(pv))->pvLU);
    602                                  if ((sLV.pCLURef->shShemasIdLUStng == ar_n_output_CRDsc[j].shRefIdLUStng) &&
    603                                          (sLV.pCLURef->shShemasOrdNumStng == ar_n_output_CRDsc[j].shRefOrdNumStng)
    604                                          && (sLV.shIdx == (ar_n_output_CRDsc[j].chRefOrdNumOut - 1))) {
    605                                      sLV.pCh = static_cast<char*>(sLV.pCLURef->pOut);
    606                                      sLV.pCh += ar_n_output_CRDsc[j].chRefOrdNumOut - 1;
    607                                      sLV.chVal++; //Counter success
    608                                      break;
    609                                  }
    610                                  i++;
    611                              }
    612                              if (sLV.pCh) {
    613                                  sLV.arrPchIn = static_cast<char**>(sLV.pCLUBase->pIn);
    614                                  sLV.arrPchIn[sLV.shIdx] = sLV.pCh;
    615                                  j++;
    616                                  //Check Next Statment
    617                                  if (sLV.pCLUBase->shShemasIdLUStng != ar_n_output_CRDsc[j].shBaseIdLUStng
    618                                          || sLV.pCLUBase->shShemasOrdNumStng != ar_n_output_CRDsc[j].shBaseOrdNumStng
    619                                          ) {
    620                                      sLV.shIdx = sLV.pCLUBase->chNumInput;
    621                                      break; //goto ;//Break For
    622                                  }
    623                              }
    624                          }
    625                          if (sLV.chVal) {//Succes SetUP
    626                              if (sLV.shAmtLUDsc >= sLV.chVal) {
    627                                  sLV.shAmtLUDsc -= sLV.chVal;
    628                                  sLV.shIdxLUOutDsc += sLV.chVal;
    629                                  //goto;
    630                              } else {
    631                                  //Fix Error
    632                                  sLV.chErrCount++; //Wrong Setup Val
    633                                  sLV.chBrk2 |= 1; //goto;Stop Execution
    634                              }
    635          
    636                          } else {
    637                              sLV.chErrCount++; //Fix Error
    638                              //Not Found Out Elem Situation
    639                              //sLV.chBrk2 |= ;//goto;
    640                              sLV.lId |= 2;
    641                          }
    642                          sLV.chBrk1 |= 1;
    643                      }
    644                      //.if(sLV.chBrk1==0){
    645                      //.
    646                      //.}Next Iteration while(sLV.shIdxLU<sLV.shAmtLU)
    647                      sLV.shIdxLU++;
    648                  }
    649                  sLV.shIdxLU = 0;
    650                  sLV.chBrk1 = 0;
    651                  //Check Error
    652                  if (sLV.lId & 2) {
    653                      //Not Found Out Elem Situation
    654                      sLV.shAmtLUDsc -= 1;
    655                      sLV.shIdxLUOutDsc += 1;
    656                      sLV.lId &= ~2;
    657                  }
    658              }
    659              //Scan Info on Leds
    660          
    661          
    662          }
    663          
    664          long Shematic::EvalSizeObj(long lId) {
    665              long lsizeObj;
    666              switch (lId) {
    667                  case BASE_POINT:
    668                      lsizeObj = SIZE_BASE_IN_POINT;
    669                      break;
    670                  case POINT:
    671                      lsizeObj = SIZE_IN_POINT;
    672                      break;
    673                  case EXTENDED:
    674                      lsizeObj = sizeof (ExtPoint);
    675                      break;
    676                  case LU_AND:
    677                      lsizeObj = sizeof (CLUAnd_8_1);
    678                      break;
    679                  case LU_OR:
    680                      lsizeObj = sizeof (CLUOr_8_1);
    681                      break;
    682                  case LU_XOR:
    683                      lsizeObj = sizeof (CLUXor_8_1);
    684                      break;
    685                  case LU_NOT:
    686                      lsizeObj = sizeof (CLUNot_1_1);
    687                      break;
    688                  case LU_MFT:
    689                      lsizeObj = sizeof (CMft);
    690                      break;
    691                  //case LU_TIMERS:
    692                      //case LU_TRIGGERS:
    693                      //case LU_ALARMS:
    694                      //case LU_MEANDERS:
    695          
    696                  case LU_INPUT:
    697                      lsizeObj = sizeof (CLUDInput_0_1);
    698                      break;
    699                  case LU_OUTPUT:
    700                      lsizeObj = sizeof (CLUDout_1_0);
    701                      break;
    702                  case LU_LED:
    703                      lsizeObj = sizeof (CLULed);
    704                      break;
    705          
    706                  default:
    707                      lsizeObj = 0;
    708              }
    709              //ExitEval
    710              return lsizeObj;
    711          }
    712          
    713          long Shematic::InsertLU(long lId, void*pvObjImage) {
    714              register long i;
    715              register void* pv;
    716          
    717              struct {
    718                  long lId, lsizeobj;
    719                  void *pV;
    720                  LUAreaListElem* arrLUAreaListElem;
    721                  CLUBase* pCLUBase;
    722              } sLV;
    723              //check Id
    724              sLV.lsizeobj = 0;
    725              i = EvalSizeObj(lId);
    726              if (i) {
    727          
    728                  //Check pvObjImage
    729                  if (pvObjImage != 0) {
    730                      //check Free Memory
    731                      pv = static_cast<void*>(&gblLUAreaAuxVar);
    732                      if ((static_cast<LUAreaAuxVar*>(pv))->lAmountFreeMem >=
    733                              static_cast<long>(i + SIZE_LU_AREA_LIST_ITEM)) {
    734                          sLV.lId = lId; //Save Id
    735                          sLV.lsizeobj = i;
    736                          sLV.pV = pv;
    737                          sLV.arrLUAreaListElem = &gLUAreaMem.headLUAreaList;
    738                          i = (static_cast<LUAreaAuxVar*>(pv))->shAmountPlacedLogicUnit; //Now Index in LUAreaListElem
    739          
    740                          if (i) {
    741                              i--; //Detect Head
    742                              pv = static_cast<void*>(&sLV.arrLUAreaListElem[i]); //Last Elem
    743                              //Mem Area
    744                              lId = reinterpret_cast<long>(( static_cast<LUAreaListElem*>(pv))->pvLU);
    745                              //Add size
    746                              lId -= sLV.lsizeobj; //((LUAreaListElem*)pv)->shSizeLU;
    747                              //gblLUAreaAuxVar.pvHead -= ((LUAreaListElem*)pv)->shSizeLU
    748                              memcpy(reinterpret_cast<void*>(lId), pvObjImage, sLV.lsizeobj);
    749                              pv = static_cast<void*>(&sLV.arrLUAreaListElem[i + 1]); //Next
    750                              (static_cast<LUAreaListElem*>(pv))->shSizeLU = static_cast<short>(sLV.lsizeobj);
    751                              (static_cast<LUAreaListElem*>(pv))->shIdLU   = static_cast<short>(sLV.lId);
    752                              (static_cast<LUAreaListElem*>(pv))->pvLU     = reinterpret_cast<void*>(lId);
    753                              gblLUAreaAuxVar.pvHead = reinterpret_cast<void*>(lId); // (lId - sLV.lId);//For check Only
    754                              //sLV.pCLUBase = ((LUAreaListElem*) pv)->pvLU;
    755                              sLV.pCLUBase = static_cast<CLUBase*> (
    756                                      (static_cast<LUAreaListElem*> (pv))->pvLU);
    757                          } else {
    758                              pv = static_cast<void*>(&gLUAreaMem.headLUAreaList);
    759          
    760                              //First Init
    761                              lId = reinterpret_cast<long>(&gLUAreaMem.chArRamPrgEvt[SIZE_MEM_BLK]);
    762                              lId -= (sLV.lsizeobj);
    763                              (static_cast<LUAreaListElem*>(pv))->pvLU = reinterpret_cast<void*>(lId);
    764                              memcpy(reinterpret_cast<void*>(lId), pvObjImage, sLV.lsizeobj);
    765                              (static_cast<LUAreaListElem*>(pv) )->shSizeLU = static_cast<short>(sLV.lsizeobj);
    766                              (static_cast<LUAreaListElem*>(pv) )->shIdLU =   static_cast<short>(sLV.lId);
    767                              gblLUAreaAuxVar.pvHead = gblLUAreaAuxVar.pvTail =
    768                                      (static_cast<LUAreaListElem*> (pv))->pvLU;
    769                              //sLV.pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
    770                              sLV.pCLUBase = static_cast<CLUBase*> (
    771                                      (static_cast<LUAreaListElem*> (pv))->pvLU);
    772                          }
    773                          //Bield Obj in Mem
    774          
    775          
    776                          //((LUAreaAuxVar*)pv)-> pvHead
    777                          sLV.pCLUBase->SetOrderNumber(); //((LUAreaAuxVar*)pv)->shAmountPlacedLogicUnit += 1;
    778                          pv = static_cast<void*>(&gblLUAreaAuxVar);
    779                          //?!!!((LUAreaAuxVar*) pv)->lAmountFreeMem -= ((short) sLV.lsizeobj + SIZE_LU_AREA_LIST_ITEM);
    780                          //?!!!((LUAreaAuxVar*) pv)->lAmountUsedMem += ((short) sLV.lsizeobj + SIZE_LU_AREA_LIST_ITEM);
    781                          (static_cast<LUAreaAuxVar*> (pv))->lAmountFreeMem -= (sLV.lsizeobj + SIZE_LU_AREA_LIST_ITEM);
    782                          (static_cast<LUAreaAuxVar*>(pv))->lAmountUsedMem += ( sLV.lsizeobj + SIZE_LU_AREA_LIST_ITEM);
    783          				
    784                      } else sLV.lsizeobj = 0;
    785                  }
    786                  return static_cast<long>(sLV.lsizeobj);
    787              }
    788          
    789          
    790          
    791              return 0; //AmountObj
    792          }
    793          
    794          void Shematic::DetectCircutLinks(void) {
    795              //Register Data In CrossRef Array
    796              long i, j;
    797              //    char **pCh;
    798          
    799              struct {
    800                  short shAmtLU, shIdx;
    801                  short shCounterScanedObj;
    802                  long lBaseOrdNumStng;
    803                  SBitFld_LUInInfo locSBitFld;
    804              } sLV;
    805          
    806              sLV.shIdx = sLV.shAmtLU = 0;
    807              if (preSetUP.n_input != 0) {
    808                  //Detect Number Input
    809                  sLV.shCounterScanedObj = 0;
    810                  sLV.shAmtLU = preSetUP.n_input;
    811                  sLV.lBaseOrdNumStng = 0;
    812                  j = i = 0;
    813                  ResetarNum();
    814                  do {
    815                      //Get Obj by Index
    816                      GetHIDLU(&sLV.lBaseOrdNumStng, sLV.shCounterScanedObj); //HashIdLU
    817                      //In test read data from External Storage
    818                      if (sLV.lBaseOrdNumStng) {//Element present
    819                          // i = sLV.shCounterScanedObj; 
    820                          arrSBitFldCRefInfo[i+ j].bfInfo_BaseID = sLV.lBaseOrdNumStng;
    821                          arrSBitFldCRefInfo[i+ j].bfInfo_OrdNumIn = 1;
    822                          arrSBitFldCRefInfo[i+ j].sBitLUInputInfo = ar_n__Output_Dsc[j];
    823                          j++;
    824                      }
    825                  } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
    826              }
    827              if (preSetUP.n_output != 0) {
    828                  //Detect Number Input
    829                  sLV.shCounterScanedObj = 0;
    830                  sLV.shAmtLU = preSetUP.n_output;
    831                  j = 0; //Idx in OutPut for Test
    832                  sLV.shIdx += preSetUP.n_input;
    833                  i = sLV.shIdx;//Offset Output
    834                  ResetarNum();
    835                  do {
    836                      //Get Obj
    837                      GetHIDLU(&sLV.lBaseOrdNumStng, sLV.shCounterScanedObj);
    838                      //In test read data from External Storage
    839                      if (sLV.lBaseOrdNumStng) {//Element present
    840                          i = sLV.shCounterScanedObj+sLV.shIdx;
    841                          arrSBitFldCRefInfo[i].bfInfo_BaseID = sLV.lBaseOrdNumStng;
    842                          arrSBitFldCRefInfo[i].bfInfo_OrdNumIn = 1;
    843                          arrSBitFldCRefInfo[i].sBitLUInputInfo = ar_n__Output_Dsc[j];//Take data from Taras
    844                          j++;
    845                      }
    846                  } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
    847              }
    848              if (preSetUP.n_led != 0) {
    849                  //Detect Number Input
    850                  sLV.shCounterScanedObj = 0;
    851                  sLV.shAmtLU = preSetUP.n_led;
    852                  j = 0; //Idx in OutPut for Test
    853                  sLV.shIdx += preSetUP.n_output*shCLUDout_1_0_AmtIn;
    854                  ResetarNum();
    855                  do {
    856                      //Get Obj
    857                      GetHIDLU(&sLV.lBaseOrdNumStng, sLV.shCounterScanedObj); //HashIdLU
    858                      //In test read data from External Storage
    859                      if (sLV.lBaseOrdNumStng) {//Element present
    860                           i = sLV.shCounterScanedObj+sLV.shIdx;
    861                          arrSBitFldCRefInfo[i].bfInfo_BaseID = sLV.lBaseOrdNumStng;
    862                          arrSBitFldCRefInfo[i].bfInfo_OrdNumIn = 1;
    863                          arrSBitFldCRefInfo[i].sBitLUInputInfo = ar_n__Output_Dsc[j];
    864                          j++;
    865                      }
    866          
    867                  } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
    868              }
    869              if (preSetUP.n_and != 0) {
    870                  //Detect Number Input
    871                  sLV.shCounterScanedObj = 0;
    872                  sLV.shAmtLU = preSetUP.n_and;
    873                  j = 0; //Idx in OutPut for Test
    874                  sLV.shIdx += preSetUP.n_led*shCLULed_1_0_AmtIn;
    875                  i = sLV.shIdx;
    876                  ResetarNum();
    877                  do {
    878                      //Get Obj
    879                      GetHIDLU(&sLV.lBaseOrdNumStng, sLV.shCounterScanedObj); //HashIdLU
    880                      //In test read data from External Storage
    881                      if (sLV.lBaseOrdNumStng) {//Element present
    882                           i = sLV.shCounterScanedObj*shCLUAnd_8_1_AmtIn+sLV.shIdx;
    883                          SBitFld_LUInInfo locSBitFld_LUInInfo;//LUInInfoDsc locLUInInfoDsc; 
    884                          for (long ik = 0; ik < shCLUAnd_8_1_AmtIn; ik++) {
    885                              arrSBitFldCRefInfo[i+ik].bfInfo_BaseID = sLV.lBaseOrdNumStng;
    886                              arrSBitFldCRefInfo[i+ik].bfInfo_OrdNumIn = 1+ik;
    887                              
    888                              locSBitFld_LUInInfo.bfInfo_OrdNumOut  = ar_n_And_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_OrdNumOut;
    889                              locSBitFld_LUInInfo.bfInfo_IdLUStng   = ar_n_And_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_IdLUStng;
    890                              locSBitFld_LUInInfo.bfInfo_OrdNumStng = ar_n_And_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_OrdNumStng;
    891                              arrSBitFldCRefInfo[i+ik].sBitLUInputInfo = locSBitFld_LUInInfo;
    892                                      //ar_n_And_Dsc[j+i+ik].UN_BitFld_LUInInfo.sBitFld_LUInInfo;
    893                              j++;//Can take change in any aviable way
    894                              
    895                          }
    896          
    897                          
    898                      }
    899          
    900                  } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
    901              }
    902              if (preSetUP.n_or != 0) {
    903                  //Detect Number Input
    904                  sLV.shCounterScanedObj = 0;
    905                  sLV.shAmtLU = preSetUP.n_or;
    906                   j = 0; //Idx in OutPut for Test
    907                  sLV.shIdx += preSetUP.n_and*shCLUAnd_8_1_AmtIn;
    908                  i = sLV.shIdx;
    909                  ResetarNum();
    910                  do {
    911                      //Get Obj
    912                      GetHIDLU(&sLV.lBaseOrdNumStng, sLV.shCounterScanedObj);
    913                      //In test read data from External Storage
    914                      if (sLV.lBaseOrdNumStng) {//Element present
    915                           i = sLV.shCounterScanedObj*shCLUOr_8_1_AmtIn+sLV.shIdx;
    916                          SBitFld_LUInInfo locSBitFld_LUInInfo;//LUInInfoDsc locLUInInfoDsc; 
    917                          for (long ik = 0; ik < shCLUOr_8_1_AmtIn; ik++) {
    918                              arrSBitFldCRefInfo[i+ik].bfInfo_BaseID = sLV.lBaseOrdNumStng;
    919                              arrSBitFldCRefInfo[i+ik].bfInfo_OrdNumIn = 1+ik;
    920                              
    921                              locSBitFld_LUInInfo.bfInfo_OrdNumOut  = ar_n_Or_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_OrdNumOut;
    922                              locSBitFld_LUInInfo.bfInfo_IdLUStng   = ar_n_Or_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_IdLUStng;
    923                              locSBitFld_LUInInfo.bfInfo_OrdNumStng = ar_n_Or_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_OrdNumStng;
    924                              arrSBitFldCRefInfo[i+ik].sBitLUInputInfo = locSBitFld_LUInInfo;
    925                                   
    926                              j++;//Can take change in any aviable way
    927                          }
    928                      }
    929                  } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
    930              }
    931              if (preSetUP.n_xor != 0) {
    932                  //Detect Number Input
    933                  sLV.shCounterScanedObj = 0;
    934                  sLV.shAmtLU = preSetUP.n_xor;
    935                   j = 0; //Idx in OutPut for Test
    936                  sLV.shIdx += preSetUP.n_or*shCLUOr_8_1_AmtIn;
    937                  i = sLV.shIdx;
    938                  ResetarNum();
    939                  do {
    940                      //Get Obj
    941                      GetHIDLU(&sLV.lBaseOrdNumStng, sLV.shCounterScanedObj);
    942                      //In test read data from External Storage
    943                      if (sLV.lBaseOrdNumStng) {//Element present
    944                           i = sLV.shCounterScanedObj*shCLUXor_2_1_AmtIn+sLV.shIdx;
    945                          SBitFld_LUInInfo locSBitFld_LUInInfo;//LUInInfoDsc locLUInInfoDsc; 
    946                          for (long ik = 0; ik < shCLUXor_2_1_AmtIn; ik++) {
    947                              arrSBitFldCRefInfo[i+ik].bfInfo_BaseID = sLV.lBaseOrdNumStng;
    948                              arrSBitFldCRefInfo[i+ik].bfInfo_OrdNumIn = 1+ik;
    949                              
    950                              locSBitFld_LUInInfo.bfInfo_OrdNumOut  = ar_n_Xor_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_OrdNumOut;
    951                              locSBitFld_LUInInfo.bfInfo_IdLUStng   = ar_n_Xor_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_IdLUStng;
    952                              locSBitFld_LUInInfo.bfInfo_OrdNumStng = ar_n_Xor_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_OrdNumStng;
    953                              arrSBitFldCRefInfo[i+ik].sBitLUInputInfo = locSBitFld_LUInInfo;
    954                                   
    955                              j++;//Can take change in any aviable way
    956                          }
    957                      }
    958          
    959                  } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
    960              }
    961              if (preSetUP.n_not != 0) {
    962                  //Detect Number Input
    963                  sLV.shCounterScanedObj = 0;
    964                  sLV.shAmtLU = preSetUP.n_not;
    965                   j = 0; //Idx in OutPut for Test
    966                  sLV.shIdx += preSetUP.n_xor*shCLUXor_2_1_AmtIn;
    967                  i = sLV.shIdx;
    968                  ResetarNum();
    969                  do {
    970                      //Get Obj
    971                      GetHIDLU(&sLV.lBaseOrdNumStng, sLV.shCounterScanedObj);
    972                      //In test read data from External Storage
    973                      if (sLV.lBaseOrdNumStng) {//Element present
    974                           i = sLV.shCounterScanedObj*shCLUNot_1_1_AmtIn+sLV.shIdx;
    975                          SBitFld_LUInInfo locSBitFld_LUInInfo;//LUInInfoDsc locLUInInfoDsc; 
    976                          for (long ik = 0; ik < shCLUNot_1_1_AmtIn; ik++) {
    977                              arrSBitFldCRefInfo[i+ik].bfInfo_BaseID = sLV.lBaseOrdNumStng;
    978                              arrSBitFldCRefInfo[i+ik].bfInfo_OrdNumIn = 1+ik;
    979                              
    980                              locSBitFld_LUInInfo.bfInfo_OrdNumOut  = ar_n_Not_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_OrdNumOut;
    981                              locSBitFld_LUInInfo.bfInfo_IdLUStng   = ar_n_Not_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_IdLUStng;
    982                              locSBitFld_LUInInfo.bfInfo_OrdNumStng = ar_n_Not_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_OrdNumStng;
    983                              arrSBitFldCRefInfo[i+ik].sBitLUInputInfo = locSBitFld_LUInInfo;
    984                                   
    985                              j++;//Can take change in any aviable way
    986                          }
    987                      }
    988                  } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
    989              }
    990              sLV.shIdx = 0;
    991          //Set Actual Links
    992              if (preSetUP.n_input != 0) {
    993                  //Detect Number Input
    994                  sLV.shCounterScanedObj = 0;
    995                  sLV.shAmtLU = preSetUP.n_input;
    996                  sLV.lBaseOrdNumStng = 0;
    997                  j = i = 0;
    998                  SBitFld_LUInInfo locSBitFld_LUInInfo;
    999                  short shRelativeNumber = 0;
   1000                  short shIdLUStng       = 0;
   1001                  short shIdx_arrSBitFldCRefInfo = 0;
   1002                  do {
   1003                      //Change offset on real Number 
   1004                      i = sLV.shCounterScanedObj; //
   1005                      locSBitFld_LUInInfo = arrSBitFldCRefInfo[i].sBitLUInputInfo;
   1006                      shIdLUStng          = locSBitFld_LUInInfo.bfInfo_IdLUStng;
   1007                      //Get Index in LU sequence
   1008                      switch (shIdLUStng) {
   1009                          case STNG_LU_AND:
   1010                              shIdx_arrSBitFldCRefInfo = preSetUP.n_input
   1011                               + preSetUP.n_output + preSetUP.n_led;
   1012                              break;
   1013                              
   1014                          case STNG_LU_OR:
   1015                               shIdx_arrSBitFldCRefInfo = preSetUP.n_input
   1016                               + preSetUP.n_output + preSetUP.n_led + shCLUAnd_8_1_AmtIn*preSetUP.n_and;
   1017                              break;
   1018                              
   1019                          case STNG_LU_XOR:
   1020                              shIdx_arrSBitFldCRefInfo = preSetUP.n_input
   1021                               + preSetUP.n_output + preSetUP.n_led + shCLUAnd_8_1_AmtIn*preSetUP.n_and
   1022                               + shCLUOr_8_1_AmtIn*preSetUP.n_or ;
   1023                              break;
   1024                              
   1025                          case STNG_LU_INPUT:
   1026                              shIdx_arrSBitFldCRefInfo = 0;
   1027                              break;
   1028                              
   1029                          case STNG_LU_OUTPUT:
   1030                              shIdx_arrSBitFldCRefInfo = preSetUP.n_input;
   1031                              break;
   1032                              
   1033                          case STNG_LU_LED:
   1034                              shIdx_arrSBitFldCRefInfo = preSetUP.n_input
   1035                                  +preSetUP.n_output;
   1036                              break;
   1037                              
   1038                          case STNG_LU_NOT:
   1039                                 shIdx_arrSBitFldCRefInfo = preSetUP.n_input
   1040                               + preSetUP.n_output + preSetUP.n_led + shCLUAnd_8_1_AmtIn*preSetUP.n_and
   1041                               + shCLUOr_8_1_AmtIn*preSetUP.n_or + shCLUXor_2_1_AmtIn*preSetUP.n_xor ;
   1042                              break;
   1043                              
   1044                              
   1045                          default:
   1046                              shIdx_arrSBitFldCRefInfo = -1;
   1047                      }
   1048                       
   1049                      shRelativeNumber = locSBitFld_LUInInfo.bfInfo_OrdNumStng;
   1050                      if(shIdx_arrSBitFldCRefInfo!= (-1)){
   1051                      //Find Element
   1052                              j = shIdx_arrSBitFldCRefInfo + shRelativeNumber-1;//Only Now
   1053                              locSBitFld_LUInInfo.bfInfo_OrdNumStng = arrSBitFldCRefInfo[j].bfInfo_BaseID; //sLV.lBaseOrdNumStng
   1054                              arrSBitFldCRefInfo[i].sBitLUInputInfo.bfInfo_OrdNumStng
   1055                                      = locSBitFld_LUInInfo.bfInfo_OrdNumStng;
   1056                      }
   1057                      
   1058                  } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
   1059                  sLV.shIdx += preSetUP.n_input;
   1060              }
   1061              
   1062              if (preSetUP.n_output != 0) {
   1063                  sLV.shCounterScanedObj = 0;
   1064                  sLV.shAmtLU = preSetUP.n_output;
   1065                  sLV.lBaseOrdNumStng = 0;
   1066                  do {
   1067                      i = sLV.shIdx + sLV.shCounterScanedObj;
   1068                      ChangeStngOrdnumRelOnBase(i);
   1069                  } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
   1070                  sLV.shIdx += sLV.shCounterScanedObj;
   1071              }
   1072              if (preSetUP.n_led != 0) {
   1073                  sLV.shCounterScanedObj = 0;
   1074                  sLV.shAmtLU = preSetUP.n_led;
   1075                  sLV.lBaseOrdNumStng = 0;
   1076                  do {
   1077                      i = sLV.shIdx + sLV.shCounterScanedObj;
   1078                      ChangeStngOrdnumRelOnBase(i);
   1079                  } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
   1080                  sLV.shIdx += sLV.shCounterScanedObj;
   1081              }
   1082              if (preSetUP.n_and != 0) {
   1083                  sLV.shCounterScanedObj = 0;
   1084                  sLV.shAmtLU = preSetUP.n_and;
   1085                  sLV.lBaseOrdNumStng = 0;
   1086                  do {
   1087                      i = sLV.shIdx + shCLUAnd_8_1_AmtIn*sLV.shCounterScanedObj;
   1088                      for(long ik = 0; ik < shCLUAnd_8_1_AmtIn; ik++){
   1089                          ChangeStngOrdnumRelOnBase(i+ik);
   1090                      }
   1091                  } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
   1092                  sLV.shIdx += shCLUAnd_8_1_AmtIn*sLV.shCounterScanedObj;
   1093              }
   1094              if (preSetUP.n_or != 0) {
   1095                  sLV.shCounterScanedObj = 0;
   1096                  sLV.shAmtLU = preSetUP.n_or;
   1097                  sLV.lBaseOrdNumStng = 0;
   1098                  do {
   1099                      i = sLV.shIdx + shCLUOr_8_1_AmtIn*sLV.shCounterScanedObj;
   1100                      for(long ik = 0; ik < shCLUOr_8_1_AmtIn; ik++){
   1101                          ChangeStngOrdnumRelOnBase(i+ik);
   1102                      }
   1103                  } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
   1104                  sLV.shIdx += shCLUOr_8_1_AmtIn*sLV.shCounterScanedObj;
   1105              }
   1106              if (preSetUP.n_xor != 0) {
   1107                  sLV.shCounterScanedObj = 0;
   1108                  sLV.shAmtLU = preSetUP.n_xor;
   1109                  sLV.lBaseOrdNumStng = 0;
   1110                  do {
   1111                      i = sLV.shIdx + shCLUXor_2_1_AmtIn*sLV.shCounterScanedObj;
   1112                      for(long ik = 0; ik < shCLUXor_2_1_AmtIn; ik++){
   1113                          ChangeStngOrdnumRelOnBase(i+ik);
   1114                      }
   1115                  } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
   1116                  sLV.shIdx += shCLUXor_2_1_AmtIn*sLV.shCounterScanedObj;
   1117              }
   1118              if (preSetUP.n_not != 0) {
   1119                  sLV.shCounterScanedObj = 0;
   1120                  sLV.shAmtLU = preSetUP.n_not;
   1121                  sLV.lBaseOrdNumStng = 0;
   1122                  do {
   1123                      i = sLV.shIdx + shCLUNot_1_1_AmtIn*sLV.shCounterScanedObj;
   1124                      for(long ik = 0; ik < shCLUNot_1_1_AmtIn; ik++){
   1125                          ChangeStngOrdnumRelOnBase(i+ik);
   1126                      }
   1127                  } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
   1128                  sLV.shIdx += shCLUNot_1_1_AmtIn*sLV.shCounterScanedObj;
   1129              }
   1130              
   1131          }
   1132          void Shematic::ChangeRelativeOnEvalLinks(void){
   1133          
   1134          //Scan OutPut
   1135          
   1136             
   1137          
   1138          
   1139          }
   1140          
   1141          void Shematic::ChangeStngOrdnumRelOnBase(long lIdxScanedObj) {
   1142              register long i,j;
   1143              SBitFld_LUInInfo locSBitFld_LUInInfo;
   1144              short shRelativeNumber = 0;
   1145              short shIdLUStng       = 0;
   1146              short shIdx_arrSBitFldCRefInfo = 0;
   1147              i = j = 0;
   1148           //   do {
   1149                      //Change offset on real Number 
   1150                      i = lIdxScanedObj; //i = sLV.shCounterScanedObj; //
   1151              locSBitFld_LUInInfo = arrSBitFldCRefInfo[i].sBitLUInputInfo;
   1152              shIdLUStng = locSBitFld_LUInInfo.bfInfo_IdLUStng;
   1153              //Get Index in LU sequence
   1154              switch (shIdLUStng) {
   1155                  case STNG_LU_AND:
   1156                      shIdx_arrSBitFldCRefInfo = preSetUP.n_input
   1157                              + preSetUP.n_output + preSetUP.n_led;
   1158                      break;
   1159          
   1160                  case STNG_LU_OR:
   1161                      shIdx_arrSBitFldCRefInfo = preSetUP.n_input
   1162                              + preSetUP.n_output + preSetUP.n_led + shCLUAnd_8_1_AmtIn * preSetUP.n_and;
   1163                      break;
   1164          
   1165                  case STNG_LU_XOR:
   1166                      shIdx_arrSBitFldCRefInfo = preSetUP.n_input
   1167                              + preSetUP.n_output + preSetUP.n_led + shCLUAnd_8_1_AmtIn * preSetUP.n_and
   1168                              + shCLUOr_8_1_AmtIn * preSetUP.n_or;
   1169                      break;
   1170          
   1171                  case STNG_LU_INPUT:
   1172                      shIdx_arrSBitFldCRefInfo = 0;
   1173                      break;
   1174          
   1175                  case STNG_LU_OUTPUT:
   1176                      shIdx_arrSBitFldCRefInfo = preSetUP.n_input;
   1177                      break;
   1178          
   1179                  case STNG_LU_LED:
   1180                      shIdx_arrSBitFldCRefInfo = preSetUP.n_input
   1181                              + preSetUP.n_output;
   1182                      break;
   1183          
   1184                  case STNG_LU_NOT:
   1185                      shIdx_arrSBitFldCRefInfo = preSetUP.n_input
   1186                              + preSetUP.n_output + preSetUP.n_led + shCLUAnd_8_1_AmtIn * preSetUP.n_and
   1187                              + shCLUOr_8_1_AmtIn * preSetUP.n_or + shCLUXor_2_1_AmtIn * preSetUP.n_xor;
   1188                      break;
   1189          
   1190          
   1191                  default:
   1192                      shIdx_arrSBitFldCRefInfo = -1;
   1193              }
   1194          
   1195              shRelativeNumber = locSBitFld_LUInInfo.bfInfo_OrdNumStng;
   1196              if (shIdx_arrSBitFldCRefInfo != (-1)) {
   1197                  //Find Element
   1198                  j = shIdx_arrSBitFldCRefInfo + shRelativeNumber - 1; //Only Now
   1199                  locSBitFld_LUInInfo.bfInfo_OrdNumStng = arrSBitFldCRefInfo[j].bfInfo_BaseID; //sLV.lBaseOrdNumStng
   1200                  arrSBitFldCRefInfo[i].sBitLUInputInfo.bfInfo_OrdNumStng
   1201                          = locSBitFld_LUInInfo.bfInfo_OrdNumStng;
   1202              }
   1203              
   1204          //        } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
   1205              
   1206          }
   1207          
   1208          void Shematic::Init2(void) {
   1209              register long  j;
   1210          //    register void* pv;  
   1211              Init2LcVarArea lsLcVarArea;//lsLc -local struct Local Area
   1212              lsLcVarArea.arrLUAreaListElem = &gLUAreaMem.headLUAreaList;
   1213              DetectCircutLinks();
   1214              lsLcVarArea.shCounterInitCLUObj = 1;
   1215              if( preSetUP.n_input ){
   1216                  CLUDInput_0_1 locCLUDInput_0_1(10, 0); // = CLUDInput_0_1(0,10);
   1217                  short shLC__n_input = preSetUP.n_input;
   1218                  short shCounterInitCLUDIn = 0;
   1219                  lsLcVarArea.shIdxGlobalObjectMapPointers = 0;
   1220                  j = 0;
   1221                  do {
   1222                      j = InsertLU(LU_INPUT, static_cast<void*>(&locCLUDInput_0_1));
   1223                      
   1224                      if (j) {//Success Bield
   1225                          SetupCLUDInput_0_1StngParam(static_cast<void*>(&lsLcVarArea));
   1226                          shCounterInitCLUDIn++;
   1227                      }//Else Error
   1228                      
   1229                  } while (shCounterInitCLUDIn < shLC__n_input && j);
   1230              }
   1231              if (preSetUP.n_output != 0) {
   1232                  CLUDout_1_0 locCLUDout_1_0(10, 0);
   1233                  short shLC__n_output = preSetUP.n_output;
   1234                  short shCounterInitCLUDout = 0;
   1235                  lsLcVarArea.shIdxGlobalObjectMapPointers = 0;
   1236                  j = 0;
   1237                  do {
   1238                      j = InsertLU(LU_OUTPUT, static_cast<void*>(&locCLUDout_1_0));
   1239                      
   1240                      if (j) {//Success Bield
   1241                          SetupCLUDout_1_0StngParam(static_cast<void*>(&lsLcVarArea));
   1242                          shCounterInitCLUDout++;
   1243                      }//Else Error
   1244                  } while (shCounterInitCLUDout < shLC__n_output && j);
   1245              }
   1246              if (preSetUP.n_led != 0) {
   1247                  CLULed locCLULed(10, 0);
   1248                  short shLC__n_led = preSetUP.n_led;
   1249                  short shCounterInitCLULed = 0;
   1250                  lsLcVarArea.shIdxGlobalObjectMapPointers = 0;
   1251                  j = 0;
   1252                  do {
   1253                      j = InsertLU(LU_LED, static_cast<void*>(&locCLULed));
   1254                  if (j) {//Success Bield
   1255                          SetupCLULedStngParam(static_cast<void*>(&lsLcVarArea));
   1256                          shCounterInitCLULed++;
   1257                      }//Else Error
   1258                  } while (shCounterInitCLULed < shLC__n_led && j);
   1259              }
   1260              if (preSetUP.n_and != 0) {
   1261                  CLUAnd_8_1 locCLUAnd_8_1(10, 0);
   1262                  short shLC__n_and = preSetUP.n_and;
   1263                  short shCounterInitCLUAnd = 0;
   1264                  lsLcVarArea.shIdxGlobalObjectMapPointers = 0;
   1265                  j = 0;
   1266                  do {
   1267                      j = InsertLU(LU_AND, static_cast<void*>(&locCLUAnd_8_1));
   1268                  if (j) {//Success Bield
   1269                          SetupCLUAnd_8_1StngParam(static_cast<void*>(&lsLcVarArea));
   1270                          shCounterInitCLUAnd++;
   1271                      }//Else Error
   1272                  } while (shCounterInitCLUAnd < shLC__n_and && j);
   1273              }
   1274              if (preSetUP.n_or != 0) {
   1275                  CLUOr_8_1 locCLUOr_8_1(10, 0);
   1276                  short shLC__n_or = preSetUP.n_or;
   1277                  short shCounterInitCLUOr = 0;
   1278                  lsLcVarArea.shIdxGlobalObjectMapPointers = 0;
   1279                  j = 0;
   1280                  do {
   1281                      j = InsertLU(LU_OR, static_cast<void*>(&locCLUOr_8_1));
   1282                  if (j) {//Success Bield
   1283                          SetupCLUOr_8_1StngParam(static_cast<void*>(&lsLcVarArea));
   1284                          shCounterInitCLUOr++;
   1285                      }//Else Error
   1286                  } while (shCounterInitCLUOr < shLC__n_or && j);
   1287              }
   1288              if (preSetUP.n_xor != 0) {
   1289                  CLUXor_8_1 locCLUXor_8_1(10, 0);
   1290                  short shLC__n_xor = preSetUP.n_xor;
   1291                  short shCounterInitCLUXor = 0;
   1292                  lsLcVarArea.shIdxGlobalObjectMapPointers = 0;
   1293                  j = 0;
   1294                  do {
   1295                      j = InsertLU(LU_XOR, static_cast<void*>(&locCLUXor_8_1));
   1296                  if (j) {//Success Bield
   1297                          SetupCLUXor_8_1StngParam(static_cast<void*>(&lsLcVarArea));
   1298                          shCounterInitCLUXor++;
   1299                      }//Else Error
   1300                  } while (shCounterInitCLUXor < shLC__n_xor && j);
   1301              }
   1302              if (preSetUP.n_not != 0) {
   1303                  CLUNot_1_1 locCLUNot_1_1(10, 0);
   1304                  short shLC__n_not = preSetUP.n_not;
   1305                  short shCounterInitCLUNot = 0;
   1306                  lsLcVarArea.shIdxGlobalObjectMapPointers = 0;
   1307                  j = 0;
   1308                  do {
   1309                      j = InsertLU(LU_NOT, static_cast<void*>(&locCLUNot_1_1));
   1310                  if (j) {//Success Bield
   1311                          SetupCLUNot_1_1StngParam(static_cast<void*>(&lsLcVarArea));
   1312                          shCounterInitCLUNot++;
   1313                      }//Else Error
   1314                  } while (shCounterInitCLUNot < shLC__n_not && j);
   1315              }
   1316              if (preSetUP.n_timers != 0) {
   1317                  CMft locCMft(10, 0);
   1318                  short shLC__n_timers = preSetUP.n_timers;
   1319                  short shCounterInitCMft = 0;
   1320                  lsLcVarArea.shIdxGlobalObjectMapPointers = 0;
   1321                  j = 0;
   1322                  do {
   1323                      j = InsertLU(LU_MFT, static_cast<void*>(&locCMft));
   1324                  if (j) {//Success Bield
   1325                          SetupCLUMft_2_1StngParam(static_cast<void*>(&lsLcVarArea));
   1326                          shCounterInitCMft++;
   1327                      }//Else Error
   1328                  } while (shCounterInitCMft < shLC__n_timers && j);
   1329              }
   1330              
   1331          SetupCircutLinks(static_cast<void*>(&lsLcVarArea));
   1332          
   1333          }
   1334          
   1335          void Shematic::SetupCLUDInput_0_1StngParam(void *pv){
   1336              register long i;
   1337              register Init2LcVarArea *pInit2LcVarArea = static_cast<Init2LcVarArea*>(pv);
   1338              i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
   1339              pv = static_cast<void*>(&(pInit2LcVarArea->arrLUAreaListElem[i-1]));
   1340              //pInit2LcVarArea->pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
   1341              pInit2LcVarArea->pCLUBase = static_cast<CLUBase*>( 
   1342                                  (static_cast<LUAreaListElem*>(pv))->pvLU);
   1343          	
   1344              pInit2LcVarArea->pCLUBase->shShemasIdLUStng = STNG_LU_INPUT;
   1345              i = pInit2LcVarArea->shCounterInitCLUObj-1; //sLV.shIdxLUOutDsc-1
   1346              pInit2LcVarArea->pCLUBase->shShemasOrdNumStng = static_cast<unsigned char>(
   1347              arrSBitFldCRefInfo[i].bfInfo_BaseID);
   1348              pInit2LcVarArea->shCounterInitCLUObj++;// sLV.shIdxLUOutDsc++;
   1349              CLUDInput_0_1* locPCLUDInput_0_1 = static_cast<CLUDInput_0_1*>(pInit2LcVarArea->pCLUBase);
   1350              locPCLUDInput_0_1->pOut = static_cast<void*>(locPCLUDInput_0_1->arrOut);
   1351              CLUDInput_0_1& locRef_CLUDInput_0_1 =
   1352                      *(static_cast<CLUDInput_0_1*>(pInit2LcVarArea->pCLUBase));
   1353              locRef_CLUDInput_0_1.chTypeLogicFunction = LU_OP_READ_DI;
   1354              locRef_CLUDInput_0_1.LogicFunc = READ_DI_Op; //???
   1355              i = pInit2LcVarArea->shIdxGlobalObjectMapPointers;//
   1356                      
   1357              GlobalObjectMap.arPCLUDInput_0_1[i] = static_cast<CLUDInput_0_1*>(
   1358                      pInit2LcVarArea->pCLUBase); //sLV.pCLUBase;
   1359              pInit2LcVarArea->shIdxGlobalObjectMapPointers++;//sLV.shIdx++           
   1360          }
   1361          void Shematic::SetupCLUDout_1_0StngParam(void *pv){
   1362              register long i,j;
   1363              register Init2LcVarArea *pInit2LcVarArea = static_cast<Init2LcVarArea*>(pv);
   1364              i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
   1365              pv = static_cast<void*>(&(pInit2LcVarArea->arrLUAreaListElem[i-1]));
   1366              //pInit2LcVarArea->pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
   1367              pInit2LcVarArea->pCLUBase = static_cast<CLUBase*>( 
   1368          	(static_cast<LUAreaListElem*>(pv))->pvLU);
   1369              pInit2LcVarArea->pCLUBase->shShemasIdLUStng =  STNG_LU_OUTPUT;
   1370              i = pInit2LcVarArea->shCounterInitCLUObj - 1;
   1371              pInit2LcVarArea->pCLUBase->shShemasOrdNumStng = static_cast<unsigned char>(
   1372              arrSBitFldCRefInfo[i].bfInfo_BaseID);
   1373              pInit2LcVarArea->shCounterInitCLUObj++;// sLV.shIdxLUOutDsc++;
   1374              CLUDout_1_0* locPCLUDout_1_0 = static_cast<CLUDout_1_0*>(pInit2LcVarArea->pCLUBase);
   1375              locPCLUDout_1_0->pIn = static_cast<void*>(locPCLUDout_1_0->arrPchIn);
   1376              locPCLUDout_1_0->arrPchIn[0] = &chGblGround;
   1377              locPCLUDout_1_0->chTypeLogicFunction = LU_OP_SET_OUT;
   1378              locPCLUDout_1_0->LogicFunc = SET_OUT_Op; //???
   1379              j = pInit2LcVarArea->shIdxGlobalObjectMapPointers;
   1380              GlobalObjectMap.arPCLUDout_1_0[j] = static_cast<CLUDout_1_0*>(
   1381                 pInit2LcVarArea->pCLUBase);
   1382              pInit2LcVarArea->shIdxGlobalObjectMapPointers++;//sLV.shIdx++           
   1383          }
   1384          void Shematic::SetupCLULedStngParam(void *pv){
   1385              register long i,j;
   1386              register Init2LcVarArea *pInit2LcVarArea = static_cast<Init2LcVarArea*>(pv);
   1387              i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
   1388              pv = static_cast<void*>(&(pInit2LcVarArea->arrLUAreaListElem[i-1]));
   1389              //pInit2LcVarArea->pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
   1390              pInit2LcVarArea->pCLUBase = static_cast<CLUBase*>( 
   1391                                  (static_cast<LUAreaListElem*>(pv))->pvLU);
   1392              pInit2LcVarArea->pCLUBase->shShemasIdLUStng =  STNG_LU_LED;
   1393              i = pInit2LcVarArea->shCounterInitCLUObj - 1;
   1394              pInit2LcVarArea->pCLUBase->shShemasOrdNumStng = static_cast<unsigned char>(
   1395              arrSBitFldCRefInfo[i].bfInfo_BaseID);
   1396              pInit2LcVarArea->shCounterInitCLUObj++;// sLV.shIdxLUOutDsc++;
   1397              CLULed* locPCLULed = static_cast<CLULed*>(pInit2LcVarArea->pCLUBase);
   1398              locPCLULed->pIn = static_cast<void*>(locPCLULed->arrPchIn);
   1399              CLULed& locRef_CLULed = *(static_cast<CLULed*>(pInit2LcVarArea->pCLUBase));
   1400              locRef_CLULed.arrPchIn[0] = &chGblGround;
   1401              locRef_CLULed.chTypeLogicFunction = LU_OP_SET_LED;
   1402              locRef_CLULed.LogicFunc = SET_LED_Op; //???
   1403              j = pInit2LcVarArea->shIdxGlobalObjectMapPointers;
   1404              
   1405              GlobalObjectMap.arPCLULed[j] = static_cast<CLULed*>(
   1406                pInit2LcVarArea->pCLUBase);
   1407              pInit2LcVarArea->shIdxGlobalObjectMapPointers++;//sLV.shIdx++          
   1408          }
   1409          void Shematic::SetupCLUAnd_8_1StngParam(void *pv){
   1410              register long i,j;
   1411              register Init2LcVarArea *pInit2LcVarArea = static_cast<Init2LcVarArea*>(pv);
   1412              i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
   1413              pv = static_cast<void*>(&(pInit2LcVarArea->arrLUAreaListElem[i-1]));
   1414              //pInit2LcVarArea->pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
   1415          	pInit2LcVarArea->pCLUBase = static_cast<CLUBase*>( 
   1416                                  (static_cast<LUAreaListElem*>(pv))->pvLU);
   1417              pInit2LcVarArea->pCLUBase->shShemasIdLUStng =  STNG_LU_AND;
   1418              i = pInit2LcVarArea->shCounterInitCLUObj - 1;
   1419              pInit2LcVarArea->pCLUBase->shShemasOrdNumStng = static_cast<unsigned char>(
   1420              arrSBitFldCRefInfo[i].bfInfo_BaseID);
   1421              pInit2LcVarArea->shCounterInitCLUObj++;// sLV.shIdxLUOutDsc++;
   1422              CLUAnd_8_1* locPCLUAnd_8_1 = static_cast<CLUAnd_8_1*>(pInit2LcVarArea->pCLUBase);
   1423              locPCLUAnd_8_1->pOut = static_cast<void*>(locPCLUAnd_8_1->arrOut);
   1424              locPCLUAnd_8_1->pIn  = static_cast<void*>(locPCLUAnd_8_1->arrPchIn);
   1425              CLUAnd_8_1& locRef_CLUAnd_8_1 = *(static_cast<CLUAnd_8_1*>(pInit2LcVarArea->pCLUBase));
   1426              locRef_CLUAnd_8_1.chTypeLogicFunction = LU_OP_AND; //
   1427               for(i = 0; i < locRef_CLUAnd_8_1.chNumInput;i++)
   1428              locRef_CLUAnd_8_1.arrPchIn[i] = &chGblVcc;
   1429              locRef_CLUAnd_8_1.LogicFunc = AND_Op_8_1; //???
   1430          
   1431              j = pInit2LcVarArea->shIdxGlobalObjectMapPointers;
   1432              
   1433              GlobalObjectMap.arPCLUAnd_8_1[j] = static_cast<CLUAnd_8_1*>(pInit2LcVarArea->pCLUBase);
   1434              pInit2LcVarArea->shIdxGlobalObjectMapPointers++;//sLV.shIdx++          
   1435          }
   1436          void Shematic::SetupCLUOr_8_1StngParam(void *pv){
   1437              register long i,j;
   1438              register Init2LcVarArea *pInit2LcVarArea = static_cast<Init2LcVarArea*>(pv);
   1439              i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
   1440              pv = static_cast<void*>(&(pInit2LcVarArea->arrLUAreaListElem[i-1]));
   1441              //pInit2LcVarArea->pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
   1442          	pInit2LcVarArea->pCLUBase = static_cast<CLUBase*>( 
   1443                                  (static_cast<LUAreaListElem*>(pv))->pvLU);
   1444              pInit2LcVarArea->pCLUBase->shShemasIdLUStng =  STNG_LU_OR;
   1445              i = pInit2LcVarArea->shCounterInitCLUObj - 1;
   1446              pInit2LcVarArea->pCLUBase->shShemasOrdNumStng = static_cast<unsigned char>(
   1447              arrSBitFldCRefInfo[i].bfInfo_BaseID);
   1448              pInit2LcVarArea->shCounterInitCLUObj++;// sLV.shIdxLUOutDsc++;
   1449              CLUOr_8_1* locPCLUOr_8_1 = static_cast<CLUOr_8_1*>(pInit2LcVarArea->pCLUBase);
   1450              locPCLUOr_8_1->pOut = static_cast<void*>(locPCLUOr_8_1->arrOut);
   1451              locPCLUOr_8_1->pIn  = static_cast<void*>(locPCLUOr_8_1->arrPchIn);
   1452              CLUOr_8_1& locRef_CLUOr_8_1 = *(static_cast<CLUOr_8_1*>(pInit2LcVarArea->pCLUBase));
   1453              for(i = 0; i < locRef_CLUOr_8_1.chNumInput;i++)
   1454              locRef_CLUOr_8_1.arrPchIn[i] = &chGblGround;
   1455              locRef_CLUOr_8_1.LogicFunc(pInit2LcVarArea->pCLUBase);
   1456              j = pInit2LcVarArea->shIdxGlobalObjectMapPointers;
   1457              
   1458              GlobalObjectMap.arPCLUOr_8_1[j] = 
   1459                static_cast<CLUOr_8_1*>(pInit2LcVarArea->pCLUBase);
   1460              pInit2LcVarArea->shIdxGlobalObjectMapPointers++;//sLV.shIdx++          
   1461          }
   1462          void Shematic::SetupCLUXor_8_1StngParam(void *pv){
   1463              register long i,j;
   1464              register Init2LcVarArea *pInit2LcVarArea = static_cast<Init2LcVarArea*>(pv);
   1465              i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
   1466              pv = static_cast<void*>(&(pInit2LcVarArea->arrLUAreaListElem[i-1]));
   1467              //pInit2LcVarArea->pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
   1468          	pInit2LcVarArea->pCLUBase = static_cast<CLUBase*>( 
   1469                                  (static_cast<LUAreaListElem*>(pv))->pvLU);
   1470              pInit2LcVarArea->pCLUBase->shShemasIdLUStng =  STNG_LU_XOR;
   1471              i = pInit2LcVarArea->shCounterInitCLUObj - 1;
   1472              pInit2LcVarArea->pCLUBase->shShemasOrdNumStng = static_cast<unsigned char>(
   1473              arrSBitFldCRefInfo[i].bfInfo_BaseID);
   1474              pInit2LcVarArea->shCounterInitCLUObj++;// sLV.shIdxLUOutDsc++;
   1475              CLUXor_8_1* locPCLUXor_8_1 = static_cast<CLUXor_8_1*>(pInit2LcVarArea->pCLUBase);
   1476              locPCLUXor_8_1->pOut = static_cast<void*>(locPCLUXor_8_1->arrOut);
   1477              locPCLUXor_8_1->pIn  = static_cast<void*>(locPCLUXor_8_1->arrPchIn);
   1478              CLUXor_8_1& locRef_CLUXor_8_1 = *(static_cast<CLUXor_8_1*>(pInit2LcVarArea->pCLUBase));
   1479              for(i = 0; i < locRef_CLUXor_8_1.chNumInput;i++)
   1480              locRef_CLUXor_8_1.arrPchIn[i] = &chGblGround;
   1481              locRef_CLUXor_8_1.LogicFunc(pInit2LcVarArea->pCLUBase);
   1482              j = pInit2LcVarArea->shIdxGlobalObjectMapPointers;
   1483              
   1484              GlobalObjectMap.arPCLUXor_8_1[j] = 
   1485                static_cast<CLUXor_8_1*>(pInit2LcVarArea->pCLUBase);
   1486              pInit2LcVarArea->shIdxGlobalObjectMapPointers++;//sLV.shIdx++          
   1487          }
   1488          void Shematic::SetupCLUNot_1_1StngParam(void *pv){
   1489              register long i,j;
   1490              register Init2LcVarArea *pInit2LcVarArea = static_cast<Init2LcVarArea*>(pv);
   1491              i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
   1492              pv = static_cast<void*>(&(pInit2LcVarArea->arrLUAreaListElem[i-1]));
   1493              //pInit2LcVarArea->pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
   1494          	pInit2LcVarArea->pCLUBase = static_cast<CLUBase*>( 
   1495                                  (static_cast<LUAreaListElem*>(pv))->pvLU);
   1496              pInit2LcVarArea->pCLUBase->shShemasIdLUStng =  STNG_LU_NOT;
   1497              i = pInit2LcVarArea->shCounterInitCLUObj - 1;
   1498              pInit2LcVarArea->pCLUBase->shShemasOrdNumStng = static_cast<unsigned char>(
   1499              arrSBitFldCRefInfo[i].bfInfo_BaseID);
   1500              pInit2LcVarArea->shCounterInitCLUObj++;// sLV.shIdxLUOutDsc++;
   1501              CLUNot_1_1* locPCLUNot_1_1 = static_cast<CLUNot_1_1*>(pInit2LcVarArea->pCLUBase);
   1502              locPCLUNot_1_1->pOut = static_cast<void*>(locPCLUNot_1_1->arrOut);
   1503              locPCLUNot_1_1->pIn  = static_cast<void*>(locPCLUNot_1_1->arrPchIn);
   1504              CLUNot_1_1& locRef_CLUNot_1_1 = *(static_cast<CLUNot_1_1*>(pInit2LcVarArea->pCLUBase));
   1505              locRef_CLUNot_1_1.LogicFunc(pInit2LcVarArea->pCLUBase);
   1506              for(i = 0; i < locRef_CLUNot_1_1.chNumInput;i++)
   1507              locRef_CLUNot_1_1.arrPchIn[i] = &chGblGround;
   1508              j = pInit2LcVarArea->shIdxGlobalObjectMapPointers;
   1509              
   1510              GlobalObjectMap.arPCLUNot_1_1[j] = 
   1511                static_cast<CLUNot_1_1*>(pInit2LcVarArea->pCLUBase);
   1512              pInit2LcVarArea->shIdxGlobalObjectMapPointers++;//sLV.shIdx++          
   1513          }
   1514          void Shematic::SetupCLUMft_2_1StngParam(void *pv){
   1515              register long i,j;
   1516              register Init2LcVarArea *pInit2LcVarArea = static_cast<Init2LcVarArea*>(pv);
   1517              i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
   1518              pv = static_cast<void*>(&(pInit2LcVarArea->arrLUAreaListElem[i-1]));
   1519              //pInit2LcVarArea->pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
   1520              pInit2LcVarArea->pCLUBase = static_cast<CLUBase*> (
   1521                      (static_cast<LUAreaListElem*> (pv))->pvLU);
   1522              pInit2LcVarArea->pCLUBase->shShemasIdLUStng =  STNG_LU_MFT;
   1523              i = pInit2LcVarArea->shCounterInitCLUObj - 1;
   1524              pInit2LcVarArea->pCLUBase->shShemasOrdNumStng = static_cast<unsigned char>(
   1525              arrSBitFldCRefInfo[i].bfInfo_BaseID);
   1526              pInit2LcVarArea->shCounterInitCLUObj++;// sLV.shIdxLUOutDsc++;
   1527              //CLUNot_1_1* locPCLUNot_1_1 = static_cast<CLUNot_1_1*>(pInit2LcVarArea->pCLUBase);
   1528              //locPCLUNot_1_1->pOut = static_cast<void*>(locPCLUNot_1_1->arrOut);
   1529              //locPCLUNot_1_1->pIn  = static_cast<void*>(locPCLUNot_1_1->arrPchIn);
   1530              CMft& rCMft = *(static_cast<CMft*>(pInit2LcVarArea->pCLUBase));
   1531              for(i = 0; i < rCMft.chNumInput;i++)
   1532              rCMft.arrPchIn[i] = &chGblGround;
   1533              
   1534              rCMft.UpdateCMft();
   1535              i = rCMft.LinkMftTimers();
   1536              if(i==3 ){
   1537                 rCMft.chTypeLogicFunction = LU_OP_MFT; //
   1538                 rCMft.LogicFunc = Mft_Op;  
   1539              }
   1540              rCMft.LogicFunc(pInit2LcVarArea->pCLUBase);
   1541              //???
   1542              j = pInit2LcVarArea->shIdxGlobalObjectMapPointers;
   1543              
   1544              GlobalObjectMap.arCMft[j] = 
   1545                static_cast<CMft*>(pInit2LcVarArea->pCLUBase);
   1546              pInit2LcVarArea->shIdxGlobalObjectMapPointers++;//sLV.shIdx++          
   1547          }
   1548          
   1549          
   1550          void GetHIDLU(void*pv, long lIdxLUinStng) {
   1551              register long i;
   1552              i = Shematic::GetTrueOrderNum();
   1553              *(static_cast<long*>(pv)) = i;
   1554          	//Aux OP
   1555          	LL_CryaCrya += lIdxLUinStng>>16;
   1556          }
   1557          
   1558          void ResetarNum(void) {
   1559              for (long j = 0; j < 300; j++)
   1560                  arNum[j] = 0;
   1561          	shCounterCalls_GLB = 0;	
   1562          }
   1563          
   1564          long  Shematic::EvalIdxibnarrSBitFldCRefInfo(long lLUStng) {
   1565              register long j;
   1566              switch (lLUStng) {
   1567                  case STNG_LU_AND:
   1568                      j = preSetUP.n_input
   1569                       + preSetUP.n_output + preSetUP.n_led;
   1570                      break;
   1571          
   1572                  case STNG_LU_OR:
   1573                       j = preSetUP.n_input
   1574                       + preSetUP.n_output + preSetUP.n_led + shCLUAnd_8_1_AmtIn*preSetUP.n_and;
   1575                      break;
   1576          
   1577                  case STNG_LU_XOR:
   1578                      j = preSetUP.n_input
   1579                       + preSetUP.n_output + preSetUP.n_led + shCLUAnd_8_1_AmtIn*preSetUP.n_and
   1580                       + shCLUOr_8_1_AmtIn*preSetUP.n_or ;
   1581                      break;
   1582          
   1583                  case STNG_LU_INPUT:
   1584                      j = 0;
   1585                      break;
   1586          
   1587                  case STNG_LU_OUTPUT:
   1588                      j = preSetUP.n_input;
   1589                      break;
   1590          
   1591                  case STNG_LU_LED:
   1592                      j = preSetUP.n_input
   1593                          +preSetUP.n_output;
   1594                      break;
   1595          
   1596                  case STNG_LU_NOT:
   1597                      j = preSetUP.n_input
   1598                              + preSetUP.n_output + preSetUP.n_led 
   1599                              + shCLUAnd_8_1_AmtIn * preSetUP.n_and
   1600                              + shCLUOr_8_1_AmtIn  * preSetUP.n_or 
   1601                              + shCLUXor_2_1_AmtIn * preSetUP.n_xor;
   1602                      break;
   1603                  case STNG_LU_MFT:
   1604                      j = preSetUP.n_input
   1605                              + preSetUP.n_output + preSetUP.n_led
   1606                              + shCLUAnd_8_1_AmtIn * preSetUP.n_and
   1607                              + shCLUOr_8_1_AmtIn  * preSetUP.n_or 
   1608                              + shCLUXor_2_1_AmtIn * preSetUP.n_xor
   1609                              + shCLUNot_1_1_AmtIn * preSetUP.n_not;
   1610                      break;
   1611          
   1612                  default:
   1613                      j = -1;
   1614              }
   1615                return j;       
   1616                      
   1617          }
   1618          long  Shematic::EvalIdxinarrLUAreaListElem(long lLUStng) {
   1619              register long j;
   1620              switch (lLUStng) {
   1621                  case STNG_LU_AND:
   1622                      j = preSetUP.n_input
   1623                       + preSetUP.n_output + preSetUP.n_led;
   1624                      break;
   1625          
   1626                  case STNG_LU_OR:
   1627                       j = preSetUP.n_input
   1628                       + preSetUP.n_output + preSetUP.n_led + preSetUP.n_and;
   1629                      break;
   1630          
   1631                  case STNG_LU_XOR:
   1632                      j = preSetUP.n_input
   1633                       + preSetUP.n_output + preSetUP.n_led + preSetUP.n_and
   1634                       + preSetUP.n_or ;
   1635                      break;
   1636          
   1637                  case STNG_LU_INPUT:
   1638                      j = 0;
   1639                      break;
   1640          
   1641                  case STNG_LU_OUTPUT:
   1642                      j = preSetUP.n_input;
   1643                      break;
   1644          
   1645                  case STNG_LU_LED:
   1646                      j = preSetUP.n_input
   1647                          +preSetUP.n_output;
   1648                      break;
   1649          
   1650                  case STNG_LU_NOT:
   1651                         j = preSetUP.n_input
   1652                       + preSetUP.n_output + preSetUP.n_led + preSetUP.n_and
   1653                       + preSetUP.n_or + preSetUP.n_xor ;
   1654                      break;
   1655                  case STNG_LU_MFT:
   1656                         j = preSetUP.n_input
   1657                       + preSetUP.n_output + preSetUP.n_led + preSetUP.n_and
   1658                       + preSetUP.n_or + preSetUP.n_xor + preSetUP.n_not;
   1659                      break;
   1660          
   1661                  default:
   1662                      j = -1;
   1663              }
   1664                return j;       
   1665                      
   1666          }
   1667          long  Shematic::EvalAmtIn_arrLUAreaListElem(long lLUStng) {
   1668              register long j;
   1669              switch (lLUStng) {
   1670                  case STNG_LU_AND:
   1671                      j = preSetUP.n_and;
   1672                      break;
   1673          
   1674                  case STNG_LU_OR:
   1675                       j = preSetUP.n_or;
   1676                      break;
   1677          
   1678                  case STNG_LU_XOR:
   1679                      j = preSetUP.n_xor;
   1680                      break;
   1681          
   1682                  case STNG_LU_INPUT:
   1683                      j = preSetUP.n_input;
   1684                      break;
   1685          
   1686                  case STNG_LU_OUTPUT:
   1687                      j = preSetUP.n_output;
   1688                      break;
   1689          
   1690                  case STNG_LU_LED:
   1691                      j = preSetUP.n_led;
   1692                      break;
   1693          
   1694                  case STNG_LU_NOT:
   1695                         j = preSetUP.n_not;
   1696                      break;
   1697                  case STNG_LU_MFT:
   1698                         j = preSetUP.n_timers;
   1699                      break;
   1700          
   1701                  default:
   1702                      j = -1;
   1703              }
   1704                return j;       
   1705                      
   1706          }
   1707          
   1708          
   1709          long  Shematic::FillSBitFld_LUInInfo(void *pvIn,void *pvOut){
   1710              //Now use Index in ordered CrCRefInfo
   1711          register long i,j;
   1712          volatile CLUBase* plcCLUBase;
   1713          //i =  
   1714          
   1715          plcCLUBase = (static_cast<LUCRefExchParam*>( pvIn))->pCLUBase;
   1716                  
   1717          j = plcCLUBase->shShemasIdLUStng;
   1718          i = EvalIdxibnarrSBitFldCRefInfo(j);
   1719          j = (static_cast<LUCRefExchParam*>( pvIn))->shLU_ObjScanIndex;
   1720          j *= plcCLUBase->chNumInput;
   1721          i += j;
   1722          i += (static_cast<LUCRefExchParam*>( pvIn))->chLU_OrdNumIn;
   1723          *(static_cast<SBitFld_LUInInfo*>(pvOut) ) = arrSBitFldCRefInfo[i].sBitLUInputInfo;  
   1724              return 0;
   1725          //Alternative Variant?
   1726              //Use ((CLUBase*)plcCLUBase)->shShemasIdLUStng && shShemasIdLUStng
   1727              //to Find Record
   1728              //then Use ((LUCRefExchParam*) pvIn)->chLU_OrdNumIn to fix Input
   1729          }
   1730          void Shematic::SetupCircutLinks(void *pv) {
   1731              register long i,j;
   1732              
   1733          //	short shAmtPlacedLU;
   1734          //	short shAmtLUDscElem;//SBitFldCRefInfo Elem
   1735          	
   1736          struct {
   1737          	short shAmtLU, shIdx;
   1738                  short shCounterScanedObj,shCounterFindObj;
   1739                  short shAmtLookObj;
   1740                  long lBaseOrdNumStng;
   1741                  SBitFldCRefInfo *pSBitFldCRefInfo;
   1742                  LUCrossRefDsc lcLUCrossRefData;
   1743                  CLUBase  *pCLURef;//*pCLUBase,
   1744          } sLV;
   1745          SBitFld_LUInInfo locSBitFld;
   1746          LUCRefExchParam lcLUCRefExchParam;
   1747          Init2LcVarArea& rsLV = *(static_cast<Init2LcVarArea*>(pv));
   1748              i = j = 0;
   1749          
   1750              sLV.shIdx = sLV.shAmtLU = 0;
   1751          //    rsLV = *((Init2LcVarArea*) pv);
   1752              sLV.pSBitFldCRefInfo = &arrSBitFldCRefInfo[0]; //Table Links
   1753              rsLV.arrLUAreaListElem = &gLUAreaMem.headLUAreaList;
   1754          	
   1755          
   1756              if (preSetUP.n_output != 0) {
   1757                  sLV.shCounterScanedObj = 0;
   1758                  sLV.shAmtLU = preSetUP.n_output;
   1759                  j = 0; //Idx in OutPut for Test
   1760                  sLV.shIdx += preSetUP.n_input;
   1761                  i = sLV.shIdx; //Offset Output
   1762                  do {
   1763                      //Type Obj == STNG_LU_OUTPUT order num == sLV.shCounterScanedObj+sLV.shIdx
   1764                      i = sLV.shCounterScanedObj + sLV.shIdx;
   1765                      pv = static_cast<void*>(&rsLV.arrLUAreaListElem[i]);
   1766                      //rsLV.pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
   1767                      rsLV.pCLUBase = static_cast<CLUBase*> (
   1768                              (static_cast<LUAreaListElem*> (pv))->pvLU);
   1769                      
   1770                      //Take info 2 Possible Variants
   1771                      //1-st STNG_LU_OUTPUT And shShemasOrdNumStng
   1772                      //2-nd use Index in ordered CrCRefInfo
   1773                      for (long ik = 0; ik < rsLV.pCLUBase->chNumInput; ik++) {
   1774                          lcLUCRefExchParam.shLU_ObjScanIndex = sLV.shCounterScanedObj;
   1775                          lcLUCRefExchParam.chLU_OrdNumIn = ik;// + 1; in function use as Idx
   1776                          lcLUCRefExchParam.pCLUBase = rsLV.pCLUBase;
   1777                          FillSBitFld_LUInInfo( static_cast<void*>(&lcLUCRefExchParam), 
   1778          				static_cast<void*>(&locSBitFld) );
   1779                          //Have OutPut Param               
   1780                          sLV.lcLUCrossRefData.shRefIdLUStng   = locSBitFld.bfInfo_IdLUStng;
   1781                          sLV.lcLUCrossRefData.shRefOrdNumStng = locSBitFld.bfInfo_OrdNumStng;
   1782                          sLV.lcLUCrossRefData.chRefOrdNumOut  = locSBitFld.bfInfo_OrdNumOut;
   1783                           //Find Obj
   1784                          j = EvalIdxinarrLUAreaListElem(sLV.lcLUCrossRefData.shRefIdLUStng);
   1785                          if(j!=(-1)){
   1786                              sLV.shCounterFindObj = 0;
   1787                              sLV.shAmtLookObj = EvalAmtIn_arrLUAreaListElem(sLV.lcLUCrossRefData.shRefIdLUStng);
   1788                              if(sLV.shAmtLookObj == (-1))
   1789                                  sLV.shAmtLookObj = gblLUAreaAuxVar.shAmountPlacedLogicUnit-j;//Test Only
   1790                              //i = j+sLV.shCounterFindObj;
   1791                              rsLV.chVal = 0;rsLV.pCh = static_cast<char*>(0);
   1792                              while ((sLV.shCounterFindObj)<sLV.shAmtLookObj && rsLV.chVal!=1) {
   1793                                  i = j+sLV.shCounterFindObj;
   1794                                  pv = static_cast<void*>(&rsLV.arrLUAreaListElem[i]);
   1795                                  //sLV.pCLURef = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
   1796                                  sLV.pCLURef = static_cast<CLUBase*> (
   1797                                          (static_cast<LUAreaListElem*> (pv))->pvLU);
   1798                                  if ((sLV.pCLURef->shShemasIdLUStng == sLV.lcLUCrossRefData.shRefIdLUStng) &&
   1799                                          (sLV.pCLURef->shShemasOrdNumStng == sLV.lcLUCrossRefData.shRefOrdNumStng)
   1800                                      ){//Set UP Logic
   1801                                      rsLV.pCh = static_cast<char*>(sLV.pCLURef->pOut);
   1802                                      rsLV.pCh += sLV.lcLUCrossRefData.chRefOrdNumOut -1;//As Idx
   1803                                      rsLV.chVal = 1;
   1804                                      break;
   1805                                  }
   1806                              sLV.shCounterFindObj++;
   1807                              }
   1808                              if (rsLV.pCh) {
   1809                                  rsLV.arrPchIn = static_cast<char**>(rsLV.pCLUBase->pIn);
   1810                                  rsLV.arrPchIn[ik] = rsLV.pCh;
   1811                                 
   1812                              }
   1813                              if(rsLV.chVal != 1)
   1814                                  rsLV.chErrCount++;//Is need?
   1815                          }
   1816                      }
   1817                  } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
   1818              }
   1819              if (preSetUP.n_led != 0) {
   1820                  sLV.shCounterScanedObj = 0;
   1821                  sLV.shAmtLU = preSetUP.n_led;
   1822                  j = 0; //Idx in OutPut for Test
   1823                  sLV.shIdx += preSetUP.n_output;
   1824                  rsLV.shIdx = sLV.shIdx; rsLV.pV = static_cast<void*>(&sLV.shCounterScanedObj);
   1825                  do{
   1826                      SetupCLUInternalRef(static_cast<void*>(&rsLV));
   1827                  
   1828                  }while (++sLV.shCounterScanedObj < sLV.shAmtLU); 
   1829              }
   1830              if (preSetUP.n_and != 0) {
   1831                  sLV.shCounterScanedObj = 0;
   1832                  sLV.shAmtLU = preSetUP.n_and;
   1833                  j = 0; //Idx in OutPut for Test
   1834                  sLV.shIdx += preSetUP.n_led;
   1835                  rsLV.shIdx = sLV.shIdx; rsLV.pV = static_cast<void*>(&sLV.shCounterScanedObj);
   1836                  do {
   1837                      SetupCLUInternalRef(static_cast<void*>(&rsLV));
   1838                  } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
   1839              }
   1840              if (preSetUP.n_or != 0) {
   1841                  sLV.shCounterScanedObj = 0;
   1842                  sLV.shAmtLU = preSetUP.n_or;
   1843                  j = 0;
   1844                  sLV.shIdx += preSetUP.n_and;
   1845                  rsLV.shIdx = sLV.shIdx; rsLV.pV = static_cast<void*>(&sLV.shCounterScanedObj);
   1846                  do {
   1847                      SetupCLUInternalRef(static_cast<void*>(&rsLV));
   1848                  } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
   1849              }
   1850              if (preSetUP.n_xor != 0) {
   1851          	sLV.shCounterScanedObj = 0;
   1852                  sLV.shAmtLU = preSetUP.n_xor;
   1853                  j = 0; //Idx in OutPut for Test
   1854                  sLV.shIdx += preSetUP.n_or;
   1855                  rsLV.shIdx = sLV.shIdx; rsLV.pV = static_cast<void*>(&sLV.shCounterScanedObj);
   1856                  do {
   1857                      SetupCLUInternalRef(static_cast<void*>(&rsLV));
   1858                  } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
   1859              }
   1860              if (preSetUP.n_not != 0) {
   1861          	sLV.shCounterScanedObj = 0;
   1862                  sLV.shAmtLU = preSetUP.n_not;
   1863                  j = 0; //Idx in OutPut for Test
   1864                  sLV.shIdx += preSetUP.n_xor;
   1865                  rsLV.shIdx = sLV.shIdx; rsLV.pV = static_cast<void*>(&sLV.shCounterScanedObj);
   1866                  do {
   1867                      SetupCLUInternalRef(static_cast<void*>(&rsLV));
   1868                  } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
   1869              }
   1870          	
   1871          }
   1872          	
   1873          //	while (shAmtLUDscElem 
   1874          //	&& sLV.chBreakScanLUDscLoop == 0) {
   1875          //		//Get Reference on Link Data
   1876          //		//sLV.shIdxFldCRefInfo =0;?
   1877          //		//
   1878          //		while(sLV.shIdxLU < shAmtPlacedLU
   1879          //		&& sLV.chBreakScanPlacedLULoop == 0){
   1880          //			i = sLV.shIdxLU;
   1881          //			pv = (void*) &rsLV.arrLUAreaListElem[i];
   1882          //			rsLV.pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
   1883          //			
   1884          //			j = sLV.shIdxFldCRefInfo;
   1885          //			if (rsLV.pCLUBase->shShemasIdLUStng == ar_n_output_CRDsc[j].shBaseIdLUStng &&
   1886          //                    rsLV.pCLUBase->shShemasOrdNumStng == ar_n_output_CRDsc[j].shBaseOrdNumStng) {
   1887          //						
   1888          //						
   1889          //			}
   1890          //		}
   1891          //	
   1892          //	}
   1893          	
   1894          void Shematic::SetupLULinks(void *pv) {
   1895          //	register long i,j;
   1896          	//First Param Index in CrrefArray
   1897          	//Second Param Id & Type LU
   1898          	pv = static_cast<void*>(&LL_CryaCrya);
   1899          	*(static_cast<short*>(pv)) = 1000;
   1900          }
   1901          
   1902          
   1903          void Shematic::SetupCLUInternalRef(void *pv){
   1904              register long i,j;
   1905          //   register Init2LcVarArea *pInit2LcVarArea = (Init2LcVarArea *)pv;
   1906          	SBitFld_LUInInfo locSBitFld;
   1907              LUCRefExchParam lcLUCRefExchParam;
   1908              register Init2LcVarArea& rsLV = *(static_cast<Init2LcVarArea*>(pv));
   1909              volatile short& shCounterScanedObj = *(static_cast<short*>(rsLV.pV));
   1910              
   1911          
   1912              i = shCounterScanedObj + rsLV.shIdx;
   1913              pv = static_cast<void*>(&rsLV.arrLUAreaListElem[i]);
   1914              //rsLV.pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;static_cast<CLUBase*>( 
   1915              rsLV.pCLUBase = static_cast<CLUBase*>((static_cast<LUAreaListElem*>(pv))->pvLU);
   1916              for (long ik = 0; ik < rsLV.pCLUBase->chNumInput; ik++) {
   1917                  lcLUCRefExchParam.shLU_ObjScanIndex = shCounterScanedObj;
   1918                  lcLUCRefExchParam.chLU_OrdNumIn = ik;// + 1; in function use as Idx
   1919                  lcLUCRefExchParam.pCLUBase = rsLV.pCLUBase;
   1920                  FillSBitFld_LUInInfo(static_cast<void*>(&lcLUCRefExchParam), static_cast<void*>(&locSBitFld));
   1921                  //Have OutPut Param               
   1922                  //-lcLUCRefExchParam.shRefIdLUStng   = locSBitFld.bfInfo_IdLUStng;
   1923                  //-lcLUCRefExchParam.shRefOrdNumStng = locSBitFld.bfInfo_OrdNumStng;
   1924                  //-lcLUCRefExchParam.chRefOrdNumOut  = locSBitFld.bfInfo_OrdNumOut;
   1925                   //Find Obj
   1926                  j = EvalIdxinarrLUAreaListElem(static_cast<long>(locSBitFld.bfInfo_IdLUStng));
   1927                  if(j!=(-1)){
   1928                       short shCounterFindObj = 0;
   1929                       short shAmtLookObj = 0;
   1930                      
   1931                      shAmtLookObj = static_cast<short>(EvalAmtIn_arrLUAreaListElem(static_cast<long>(locSBitFld.bfInfo_IdLUStng)));
   1932                      if(shAmtLookObj == (-1))
   1933                          shAmtLookObj = gblLUAreaAuxVar.shAmountPlacedLogicUnit-j;
   1934                      
   1935                      rsLV.chVal = 0;rsLV.pCh = static_cast<char*>(0);
   1936                      while ((shCounterFindObj) < shAmtLookObj && rsLV.chVal != 1) {
   1937                          i = j + shCounterFindObj;
   1938                          pv = static_cast<void*>(&rsLV.arrLUAreaListElem[i]);
   1939                          //rsLV.pCLURef = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
   1940                          rsLV.pCLURef = static_cast<CLUBase*>((static_cast<LUAreaListElem*>(pv))->pvLU);
   1941                          if ((rsLV.pCLURef->shShemasIdLUStng == static_cast<short>(locSBitFld.bfInfo_IdLUStng)) &&
   1942                                  (rsLV.pCLURef->shShemasOrdNumStng == static_cast<short>(locSBitFld.bfInfo_OrdNumStng))
   1943                                  ) {//Set UP Logic
   1944                              rsLV.pCh = static_cast<char*>(rsLV.pCLURef->pOut);
   1945                              rsLV.pCh += static_cast<unsigned char>(locSBitFld.bfInfo_OrdNumOut - 1); //As Idx
   1946                              rsLV.chVal = 1;
   1947                              break;
   1948                          }
   1949                          shCounterFindObj++;
   1950                      }
   1951                      if (rsLV.pCh) {
   1952                          rsLV.arrPchIn = static_cast<char**>(rsLV.pCLUBase->pIn);
   1953                          rsLV.arrPchIn[ik] = rsLV.pCh;
   1954                      }
   1955                      if(rsLV.chVal != 1)
   1956                          rsLV.chErrCount++;//Is need?
   1957                  }
   1958              }
   1959          }
   1960          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   1961          //``````````````````````````````````````````````````````````````````````````````````
   1962          //==================================================================================
   1963          //--- 			 Interface function for CPP Schematic     -----------
   1964          //==================================================================================
   1965          //..................................................................................
   1966          //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
   1967          long InitSchematic(void){
   1968          sh.Init();
   1969          return 1;
   1970          }
   1971          
   1972          void DoCalcWrp(void){
   1973          sh.DoCalc();
   1974          }
   1975          
   1976          
   1977          
   1978          
   1979          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   DoCalcWrp
         8   -> Shematic::DoCalc()
      16   GetHIDLU(void *, long)
        16   -> Shematic::GetTrueOrderNum()
       8   InitSchematic
         8   -> Shematic::Init()
       0   ResetarNum()
       0   Shematic::ChangeRelativeOnEvalLinks()
      20   Shematic::ChangeStngOrdnumRelOnBase(long)
       0   Shematic::CreateTestSchema()
      40   Shematic::DetectCircutLinks()
        40   -> GetHIDLU(void *, long)
        40   -> ResetarNum()
        40   -> Shematic::ChangeStngOrdnumRelOnBase(long)
      40   Shematic::DoCalc()
        40   -- Indirect call
       0   Shematic::EvalAmtIn_arrLUAreaListElem(long)
       4   Shematic::EvalIdxibnarrSBitFldCRefInfo(long)
       4   Shematic::EvalIdxinarrLUAreaListElem(long)
       0   Shematic::EvalSizeObj(long)
      32   Shematic::FillSBitFld_LUInInfo(void *, void *)
        32   -> Shematic::EvalIdxibnarrSBitFldCRefInfo(long)
      24   Shematic::GetTrueOrderNum()
        24   -> __time32
        24   -> rand
        24   -> srand
       8   Shematic::Init()
         8   -> Shematic::Init2()
     432   Shematic::Init1()
       432   -- Indirect call
       432   -> CLUAnd_8_1::CLUAnd_8_1(char, char)
       432   -> CLUAnd_8_1::~CLUAnd_8_1()
       432   -> CLUDInput_0_1::CLUDInput_0_1(char, char)
       432   -> CLUDInput_0_1::~CLUDInput_0_1()
       432   -> CLUDout_1_0::CLUDout_1_0(char, char)
       432   -> CLUDout_1_0::~CLUDout_1_0()
       432   -> CLULed::CLULed(char, char)
       432   -> CLULed::~CLULed()
       432   -> CLUNot_1_1::CLUNot_1_1(char, char)
       432   -> CLUNot_1_1::~CLUNot_1_1()
       432   -> CLUOr_8_1::CLUOr_8_1(char, char)
       432   -> CLUOr_8_1::~CLUOr_8_1()
       432   -> CLUXor_8_1::CLUXor_8_1(char, char)
       432   -> CLUXor_8_1::~CLUXor_8_1()
       432   -> Shematic::DetectCircutLinks()
       432   -> Shematic::InsertLU(long, void *)
     504   Shematic::Init2()
       504   -> CLUAnd_8_1::CLUAnd_8_1(char, char)
       504   -> CLUAnd_8_1::~CLUAnd_8_1()
       504   -> CLUDInput_0_1::CLUDInput_0_1(char, char)
       504   -> CLUDInput_0_1::~CLUDInput_0_1()
       504   -> CLUDout_1_0::CLUDout_1_0(char, char)
       504   -> CLUDout_1_0::~CLUDout_1_0()
       504   -> CLULed::CLULed(char, char)
       504   -> CLULed::~CLULed()
       504   -> CLUNot_1_1::CLUNot_1_1(char, char)
       504   -> CLUNot_1_1::~CLUNot_1_1()
       504   -> CLUOr_8_1::CLUOr_8_1(char, char)
       504   -> CLUOr_8_1::~CLUOr_8_1()
       504   -> CLUXor_8_1::CLUXor_8_1(char, char)
       504   -> CLUXor_8_1::~CLUXor_8_1()
       504   -> CMft::CMft(char, char)
       504   -> CMft::~CMft()
       504   -> Shematic::DetectCircutLinks()
       504   -> Shematic::InsertLU(long, void *)
       504   -> Shematic::SetupCLUAnd_8_1StngParam(void *)
       504   -> Shematic::SetupCLUDInput_0_1StngParam(void *)
       504   -> Shematic::SetupCLUDout_1_0StngParam(void *)
       504   -> Shematic::SetupCLULedStngParam(void *)
       504   -> Shematic::SetupCLUMft_2_1StngParam(void *)
       504   -> Shematic::SetupCLUNot_1_1StngParam(void *)
       504   -> Shematic::SetupCLUOr_8_1StngParam(void *)
       504   -> Shematic::SetupCLUXor_8_1StngParam(void *)
       504   -> Shematic::SetupCircutLinks(void *)
      48   Shematic::InsertLU(long, void *)
        48   -> CLUBase::SetOrderNumber()
        48   -> Shematic::EvalSizeObj(long)
        48   -> __aeabi_memcpy
       0   Shematic::PrintPointsState()
       0   Shematic::PrintShematicElemPointsState()
      16   Shematic::SetupCLUAnd_8_1StngParam(void *)
      16   Shematic::SetupCLUDInput_0_1StngParam(void *)
      16   Shematic::SetupCLUDout_1_0StngParam(void *)
      56   Shematic::SetupCLUInternalRef(void *)
        56   -> Shematic::EvalAmtIn_arrLUAreaListElem(long)
        56   -> Shematic::EvalIdxinarrLUAreaListElem(long)
        56   -> Shematic::FillSBitFld_LUInInfo(void *, void *)
      16   Shematic::SetupCLULedStngParam(void *)
      32   Shematic::SetupCLUMft_2_1StngParam(void *)
        32   -- Indirect call
        32   -> CMft::LinkMftTimers()
        32   -> CMft::UpdateCMft()
      32   Shematic::SetupCLUNot_1_1StngParam(void *)
        32   -- Indirect call
      32   Shematic::SetupCLUOr_8_1StngParam(void *)
        32   -- Indirect call
      32   Shematic::SetupCLUXor_8_1StngParam(void *)
        32   -- Indirect call
      80   Shematic::SetupCircutLinks(void *)
        80   -> Shematic::EvalAmtIn_arrLUAreaListElem(long)
        80   -> Shematic::EvalIdxinarrLUAreaListElem(long)
        80   -> Shematic::FillSBitFld_LUInInfo(void *, void *)
        80   -> Shematic::SetupCLUInternalRef(void *)
       0   Shematic::SetupLULinks(void *)
       0   Shematic::Shematic()
       0   Shematic::printResult()
       8   Shematic::subobject Shematic()
         8   -> Shematic::Shematic()
       8   Shematic::subobject ~Shematic()
         8   -> Shematic::~Shematic()
       0   Shematic::~Shematic()
       8   __sti__routine()
         8   -> Shematic::Shematic()
         8   -> __aeabi_atexit


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable12
       4  ??DataTable13
       4  ??DataTable14
       4  ??DataTable15
       4  ??DataTable16
       4  ??DataTable17
       4  ??DataTable22
       4  ??DataTable27
       4  ??DataTable27_1
       4  ??DataTable27_10
       4  ??DataTable27_11
       4  ??DataTable27_12
       4  ??DataTable27_13
       4  ??DataTable27_14
       4  ??DataTable27_2
       4  ??DataTable27_3
       4  ??DataTable27_4
       4  ??DataTable27_5
       4  ??DataTable27_6
       4  ??DataTable27_7
       4  ??DataTable27_8
       4  ??DataTable27_9
       4  ??DataTable5
       4  ??DataTable5_1
       4  ??DataTable5_10
       4  ??DataTable5_11
       4  ??DataTable5_12
       4  ??DataTable5_13
       4  ??DataTable5_14
       4  ??DataTable5_2
       4  ??DataTable5_3
       4  ??DataTable5_4
       4  ??DataTable5_5
       4  ??DataTable5_6
       4  ??DataTable5_7
       4  ??DataTable5_8
       4  ??DataTable5_9
       4  ??DataTable6
       4  ??DataTable7
       4  ??DataTable9
      10  DoCalcWrp
      40  GetHIDLU(void *, long)
     520  GlobalObjectMap
      12  InitSchematic
       8  LL_CryaCrya
      32  ResetarNum()
       2  Shematic::ChangeRelativeOnEvalLinks()
     422  Shematic::ChangeStngOrdnumRelOnBase(long)
       2  Shematic::CreateTestSchema()
    2434  Shematic::DetectCircutLinks()
     116  Shematic::DoCalc()
     110  Shematic::EvalAmtIn_arrLUAreaListElem(long)
     256  Shematic::EvalIdxibnarrSBitFldCRefInfo(long)
     238  Shematic::EvalIdxinarrLUAreaListElem(long)
     122  Shematic::EvalSizeObj(long)
      68  Shematic::FillSBitFld_LUInInfo(void *, void *)
     248  Shematic::GetTrueOrderNum()
      16  Shematic::Init()
    2050  Shematic::Init1()
     692  Shematic::Init2()
     246  Shematic::InsertLU(long, void *)
       2  Shematic::PrintPointsState()
       2  Shematic::PrintShematicElemPointsState()
     144  Shematic::SetupCLUAnd_8_1StngParam(void *)
     110  Shematic::SetupCLUDInput_0_1StngParam(void *)
     116  Shematic::SetupCLUDout_1_0StngParam(void *)
     304  Shematic::SetupCLUInternalRef(void *)
     118  Shematic::SetupCLULedStngParam(void *)
     188  Shematic::SetupCLUMft_2_1StngParam(void *)
     174  Shematic::SetupCLUNot_1_1StngParam(void *)
     176  Shematic::SetupCLUOr_8_1StngParam(void *)
     176  Shematic::SetupCLUXor_8_1StngParam(void *)
     894  Shematic::SetupCircutLinks(void *)
      12  Shematic::SetupLULinks(void *)
      98  Shematic::Shematic()
       2  Shematic::printResult()
      12  Shematic::subobject Shematic()
      12  Shematic::subobject ~Shematic()
       2  Shematic::~Shematic()
      24  __sti__routine()
    1200  arNum
     640  ar_n_And_Dsc
      80  ar_n_Not_Dsc
     640  ar_n_Or_Dsc
      40  ar_n_Output_Dsc
     160  ar_n_Xor_Dsc
      40  ar_n__Output_Dsc
      96  ar_n_and_Dsc
      60  ar_n_led_Dsc
     280  ar_n_output_CRDsc
      60  ar_n_output_Dsc
    3200  arrSBitFldCRefInfo
       1  chGblGround
       1  chGblVcc
   16384  gLUAreaMem
      20  gblLUAreaAuxVar
       4  lAmountOccupyMem
   16384  lcUArea
      56  preSetUP
       4  sh
       2  shAmountTotalElem
       2  shCounterCalls_GLB
       2  shIdxLUnit
       4  -- Other

 
 19 599 bytes in section .bss
    333 bytes in section .data
      4 bytes in section .init_array
  1 560 bytes in section .rodata
  9 842 bytes in section .text
 16 672 bytes in section NonZeroIniVars_RAM1
  1 200 bytes in section ZeroInivars_RAM1
    520 bytes in section variables_RAM1
 
  9 846 bytes of CODE  memory
  1 560 bytes of CONST memory
 38 324 bytes of DATA  memory

Errors: none
Warnings: none
