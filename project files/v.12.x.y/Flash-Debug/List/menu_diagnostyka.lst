###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       24/Mar/2017  12:54:57
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\menu_diagnostyka.c
#    Command line =  
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\menu_diagnostyka.c" -D USE_STDPERIPH_DRIVER -D STM32F2XX -D
#        USE_USB_OTG_FS -D KEYBOARD_VER_1 -D SYSTEM_VIEWER_ENABLE -lc
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List" --remarks -o
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --enable_multibytes --fpu=None
#        --dlib_config G:\PRG\IAR7_50_2\arm\INC\c\DLib_Config_Full.h -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\usb\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_OTG_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Core\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\"
#        -I "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\Config\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\OS\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\SEGGER\" -On --use_c++_inline
#        --require_prototypes -I G:\PRG\IAR7_50_2\arm\CMSIS\Include\ -D
#        ARM_MATH_CM3
#    List file    =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List\menu_diagnostyka.lst
#    Object file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj\menu_diagnostyka.o
#
###############################################################################

G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working files\src\menu_diagnostyka.c
      1          #include "header.h"
      2          
      3          /*****************************************************/
      4          /*
      5          Функція переміщення по меню
      6          
      7          Вхідні параметри
      8          (1 << BIT_REWRITE) - перемалювати меню
      9          (1 << BIT_KEY_DOWN) - рухатися вниз
     10          (1 << BIT_KEY_UP) - рухатися вверх
     11          */
     12          /*****************************************************/
     13          void move_into_diagnostics(unsigned int action, int max_row)
     14          {
     15            unsigned int diagnostyka_tmp[3] = {diagnostyka[0], diagnostyka[1], (diagnostyka[2] & USED_BITS_IN_LAST_INDEX)};
     16            if (
     17                (diagnostyka_tmp[0] == 0) &&
     18                (diagnostyka_tmp[1] == 0) &&
     19                (diagnostyka_tmp[2] == 0)
     20               ) 
     21            {
     22              current_state_menu2.index_position = 0;
     23            }
     24            else
     25            {
     26              if (action & ((1 << BIT_REWRITE) | (1 << BIT_KEY_DOWN)))
     27              {
     28                if (action & (1 << BIT_KEY_DOWN)) current_state_menu2.index_position++;
     29                do
     30                {
     31                  if(current_state_menu2.index_position >= max_row) current_state_menu2.index_position = 0;
     32                  while (_CHECK_SET_BIT(diagnostyka_tmp, current_state_menu2.index_position) == 0)
     33                  {
     34                    if(++current_state_menu2.index_position >= max_row) current_state_menu2.index_position = 0;
     35                  }
     36                }
     37                while ((action & (1 << BIT_KEY_DOWN)) && (current_state_menu2.index_position >= max_row));
     38              }
     39              else if (action & (1 << BIT_KEY_UP))
     40              {
     41                current_state_menu2.index_position--;
     42                do
     43                {
     44                  if(current_state_menu2.index_position < 0) current_state_menu2.index_position = max_row - 1;
     45                  while (_CHECK_SET_BIT(diagnostyka_tmp, current_state_menu2.index_position) == 0)
     46                  {
     47                    if(--current_state_menu2.index_position < 0) current_state_menu2.index_position = max_row - 1;
     48                  }
     49                }
     50                while (current_state_menu2.index_position < 0);
     51              }
     52            }
     53          }
     54          /*****************************************************/
     55          
     56          /*****************************************************/
     57          //Формуємо екран відображення діагностики
     58          /*****************************************************/
     59          void make_ekran_diagnostics(void)
     60          {
     61          #define NUMBER_ROW_FOR_NO_ERRORS 2
     62            
     63            unsigned int position_temp = current_state_menu2.index_position;
     64            const uint8_t name_string[MAX_NAMBER_LANGUAGE][NUMBER_ROW_FOR_NO_ERRORS + MAX_ROW_FOR_DIAGNOSTYKA][MAX_COL_LCD + 1] = 
     65            {
     66              {
     67                "      Нет       ",
     68                "     ошибок     ",
     69                NAME_DIAGN_RU
     70              },
     71              {
     72                "     Немає      ",
     73                "    помилок     ",
     74                NAME_DIAGN_UA
     75              },
     76              {
     77                "       No       ",
     78                "     errors     ",
     79                NAME_DIAGN_EN
     80              },
     81              {
     82                "      Кате      ",
     83                "      жок       ",
     84                NAME_DIAGN_KZ
     85              }
     86            };
     87          
     88            int index_language = index_language_in_array(settings_fix_prt.language);
     89              
     90            if (
     91                (diagnostyka[0] == 0) &&
     92                (diagnostyka[1] == 0) &&
     93                (diagnostyka[2] == 0) 
     94               )
     95            {
     96              //Це означає, що ніякої помилки не зафіксовано
     97               
     98              //Текучу позицію в сипску переводимо на сам початок
     99              current_state_menu2.index_position = 0;
    100              position_in_current_level_menu2[current_state_menu2.current_level] = 0;
    101          
    102              //Копіюємо  рядки у робочий екран
    103              for (size_t i = 0; i < MAX_ROW_LCD; i++)
    104              {
    105                //Копіюємо в робочий екран інформацію, що нічого не відранжовано
    106                for (size_t j = 0; j < MAX_COL_LCD; j++)working_ekran[i][j] = (i < NUMBER_ROW_FOR_NO_ERRORS) ? name_string[index_language][i][j] : ' ';
    107              }
    108              //Курсор не видимий
    109              current_state_menu2.cursor_on = 0;
    110            }
    111            else
    112            {
    113              /************************************************************/
    114              //Формуємо список із помилок які реально присутні
    115              /************************************************************/
    116              uint8_t name_string_tmp[MAX_ROW_FOR_DIAGNOSTYKA][MAX_COL_LCD + 1];
    117          
    118              int offset = 0;
    119              for(intptr_t index_1 = 0; index_1 < (MAX_ROW_FOR_DIAGNOSTYKA - offset); index_1++)
    120              {
    121                while (
    122                       (index_1 < (MAX_ROW_FOR_DIAGNOSTYKA - offset)) &&
    123                       (_CHECK_SET_BIT(diagnostyka, (index_1 + offset)) == 0)
    124                      )   
    125                {
    126                  if (_CHECK_SET_BIT(diagnostyka, (index_1 + offset)) == 0)
    127                  {
    128                     if (current_state_menu2.index_position >= ((int)(index_1 + offset))) position_temp--;
    129                    offset++;
    130                  }
    131                }
    132                
    133                if (index_1 < (MAX_ROW_FOR_DIAGNOSTYKA - offset))
    134                {
    135                  for(size_t index_2 = 0; index_2 < (MAX_COL_LCD + 1); index_2++)
    136                    name_string_tmp[index_1][index_2] = name_string[index_language][NUMBER_ROW_FOR_NO_ERRORS + index_1 + offset][index_2];
    137                }
    138              }
    139              /************************************************************/
    140              
    141              int index_in_ekran = (position_temp >> POWER_MAX_ROW_LCD) << POWER_MAX_ROW_LCD;
    142              //Копіюємо  рядки у робочий екран
    143              for (size_t i = 0; i< MAX_ROW_LCD; i++)
    144              {
    145                //Наступні рядки треба перевірити, чи їх требе відображати у текучій коффігурації
    146                for (unsigned int j = 0; j<MAX_COL_LCD; j++) working_ekran[i][j] = (index_in_ekran < (MAX_ROW_FOR_DIAGNOSTYKA - offset)) ? name_string_tmp[index_in_ekran][j] : ' ';
    147          
    148                index_in_ekran++;
    149              }
    150          
    151              //Курсор видимий
    152              current_state_menu2.cursor_on = 1;
    153            }
    154          
    155            //Курсор по горизонталі відображається на першій позиції
    156            current_state_menu2.position_cursor_x = 0;
    157            //Відображення курору по вертикалі
    158            current_state_menu2.position_cursor_y = position_temp & (MAX_ROW_LCD - 1);
    159          
    160            //Курсор не мигає
    161            current_state_menu2.cursor_blinking_on = 0;
    162            //Обновити повністю весь екран
    163            current_state_menu2.current_action = ACTION_WITH_CARRENT_EKRANE_FULL_UPDATE;
    164            
    165          #undef NUMBER_ROW_FOR_NO_ERRORS
    166          }
    167          /*****************************************************/
    168          
    169          /*****************************************************/
    170          //
    171          /*****************************************************/
    172          /*****************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
    7640   make_ekran_diagnostics
      7640   -> __aeabi_memcpy4
      7640   -> index_language_in_array
      12   move_into_diagnostics


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
    6120  ?_0
     380  make_ekran_diagnostics
     262  move_into_diagnostics

 
 6 120 bytes in section .rodata
   670 bytes in section .text
 
   670 bytes of CODE  memory
 6 120 bytes of CONST memory

Errors: none
Warnings: none
