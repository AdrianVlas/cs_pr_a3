###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       24/Mar/2017  12:54:59
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\menu_view_measurement.c
#    Command line =  
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\menu_view_measurement.c" -D USE_STDPERIPH_DRIVER -D
#        STM32F2XX -D USE_USB_OTG_FS -D KEYBOARD_VER_1 -D SYSTEM_VIEWER_ENABLE
#        -lc "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List" --remarks -o
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --enable_multibytes --fpu=None
#        --dlib_config G:\PRG\IAR7_50_2\arm\INC\c\DLib_Config_Full.h -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\usb\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_OTG_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Core\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\"
#        -I "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\Config\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\OS\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\SEGGER\" -On --use_c++_inline
#        --require_prototypes -I G:\PRG\IAR7_50_2\arm\CMSIS\Include\ -D
#        ARM_MATH_CM3
#    List file    =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List\menu_view_measurement.lst
#    Object file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj\menu_view_measurement.o
#
###############################################################################

G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working files\src\menu_view_measurement.c
      1          #include "header.h"
      2          
      3          /*****************************************************/
      4          //Конвертація в рядок і поміщення в масив для відображення на екрані вимірювань
      5          /*****************************************************/
      6          void convert_and_insert_char_for_measurement(unsigned int start_number_digit_after_point, unsigned int temp_meas, unsigned int koef_mul, unsigned int koef_div, unsigned char *name_string, unsigned int start_position)
      7          {
      8            unsigned long long temp_value_long  = ((unsigned long long)temp_meas)*((unsigned long long)koef_mul)/((unsigned long long)koef_div);
      9            unsigned int temp_value = (unsigned int)temp_value_long;
     10            unsigned int number_digit_after_point = start_number_digit_after_point, error = 0, overflow = 0;
     11            
     12            //Помічаємо, що зараз ми ще не перейшли ні на шкалу КІЛО ні на шкалу МЕГА
     13          //  *(name_string + start_position + 7) = ' ';
     14          
     15            overflow = ((temp_value_long & 0xffffffff00000000ull) != 0);
     16            while (
     17                   (
     18                    (overflow != 0) ||
     19                    (temp_value > 999999)
     20                   )
     21                   &&  
     22                   (error == 0)  
     23                  )   
     24            {
     25              //Ми не вкладаємося у значення з шести цифр і коми
     26          
     27              //Відкидаємо найменш значуще число
     28              if (overflow != 0)
     29              {
     30                temp_value_long /= 10ull;
     31                overflow = ((temp_value_long & 0xffffffff00000000ull) != 0);
     32                if (overflow == 0)
     33                  temp_value = temp_value_long;
     34              }
     35              else
     36                temp_value /=10;
     37              
     38              //Змінюємо позицію десяткової коми і, при потрребі, переходимо на іншу шкалу
     39              switch (number_digit_after_point)
     40              {
     41              case 1:
     42              case 2:
     43                {
     44                  //Переходимо з формату 1.5 до 2.4 або з формату 2.4 до 3.3
     45                  number_digit_after_point++;
     46                  break;
     47                }
     48              case 3:
     49                {
     50                  //Переходимо з формату 3.3 до 1.5 із встановленням позначки ' '->'k' або 'k'->'M'
     51                  number_digit_after_point = 1;
     52                  if ((*(name_string + start_position + 7)) == ' ') 
     53                  {
     54                    if (settings_fix.language == LANGUAGE_EN)
     55                      *(name_string + start_position + 7) = 'k';
     56                    else
     57                      *(name_string + start_position + 7) = 'к';
     58                  }
     59                  else if (
     60                           ((*(name_string + start_position + 7)) == 'к') ||
     61                           ((*(name_string + start_position + 7)) == 'k')  
     62                          )
     63                  {
     64                    *(name_string + start_position + 7) = 'М';
     65                  }
     66                  else if ((*(name_string + start_position + 7)) == 'М')
     67                  {
     68                    if (settings_fix.language == LANGUAGE_EN)
     69                      *(name_string + start_position + 7) = 'G';
     70                    else
     71                      *(name_string + start_position + 7) = 'Г';
     72                  }
     73                  else
     74                  {
     75                    /*
     76                    теоретично сюди б програма могла зайти у двох випадках:
     77                    1) перехід з шкали МЕГА на вищу шкалу, що при наший числах це не мало ніколи б бути
     78                    2) у 7-мый позицыъ було незрозумлий символ - і це э помилкова ситуація, яка б також ніколи не мала виникати
     79                    
     80                    У такому разі будем виводити повідомлення ***.*** і символ у 7-мый позицыъ ,який призвів до такої ситуації
     81                    */
     82                    error = 2;
     83                  }
     84                  break;
     85                }
     86              default:
     87                {
     88                  /*
     89                  теоретично сюди програма ніколи б не  мала зайти
     90                  
     91                  У такому разі будем виводити повідомлення XXXXXXX
     92                  */
     93                  error = 1;
     94                }
     95              }
     96            }
     97            
     98            if (error == 0)
     99            {
    100              //При приведені числа до відповідного формату і відповідної шкали помилок не було зафіксовано
    101              unsigned int first_symbol = 0, value, position = start_position; /*позиція з якої поинається виведення значення - найзначуще число*/
    102              
    103              /*
    104              X?????
    105              */
    106              if (temp_value > 99999)
    107              {
    108                value = temp_value / 100000; 
    109                temp_value %= 100000;
    110                *(name_string + position) = value + 0x30;
    111                first_symbol = 1;
    112              }
    113              else
    114              {
    115                if (number_digit_after_point == 1)
    116                {
    117                  *(name_string + position) = '0';
    118                  first_symbol = 1;
    119                }
    120                else *(name_string + position) = ' ';
    121              }
    122              position++;
    123          
    124              if (number_digit_after_point == 1)
    125              {
    126                //Десяткова "кома"
    127                *(name_string + position) = '.';
    128                position++;
    129              }
    130          
    131              /*
    132              *X????
    133              */
    134              if (temp_value > 9999)
    135              {
    136                value = temp_value / 10000; 
    137                temp_value %= 10000;
    138                *(name_string + position) = value + 0x30;
    139                first_symbol = 1;
    140              }
    141              else
    142              {
    143                if (
    144                    (number_digit_after_point == 2) ||
    145                    (first_symbol             != 0)  
    146                   )   
    147                {
    148                  *(name_string + position) = '0';
    149                  first_symbol = 1;
    150                }
    151                else *(name_string + position) = ' ';
    152              }
    153              position++;
    154          
    155              if (number_digit_after_point == 2)
    156              {
    157                //Десяткова "кома"
    158                *(name_string + position) = '.';
    159                position++;
    160              }
    161              
    162              /*
    163              **X???
    164              */
    165              value = temp_value / 1000; 
    166              temp_value %= 1000;
    167              *(name_string + position) = value + 0x30;
    168              position++;
    169          
    170              if (number_digit_after_point == 3)
    171              {
    172                //Десяткова "кома"
    173                *(name_string + position) = '.';
    174                position++;
    175              }
    176              
    177              //З цього місця змінна position має обов'язково бути рівною (start_position + 4)
    178              if (position == (start_position + 4))
    179              {
    180                /*
    181                ***X??
    182                */
    183                value = temp_value / 100; 
    184                temp_value %= 100;
    185                *(name_string + (position++)) = value + 0x30;
    186            
    187                /*
    188                ****X?
    189                */
    190                value = temp_value / 10; 
    191                temp_value %= 10;
    192                *(name_string + (position++)) = value + 0x30;
    193            
    194                /*
    195                *****X
    196                */
    197                *(name_string + (position++)) = temp_value + 0x30;
    198              }
    199              else
    200              {
    201                //Помилка, яка б ніколи не мала виникати помічаємо це знаками оклику
    202                for (unsigned int i = 0; i < 7; i++) *(name_string + start_position + i) = '!';
    203                *(name_string + start_position + 7) = ' ';
    204              }
    205            }
    206            else if (error == 1)
    207            {
    208              //Помилка виникла при аналізі попереднього формату
    209              for (unsigned int i = 0; i < 7; i++) *(name_string + start_position + i) = 'X';
    210              *(name_string + start_position + 7) = ' ';
    211            }
    212            else if (error == 2)
    213            {
    214              //Помилка виникла при переході на іншу шкалу
    215              for (unsigned int i = 0; i < 7; i++) *(name_string + start_position + i) = '*';
    216              *(name_string + start_position + 3) = '.';
    217            }
    218            else
    219            {
    220              //Невизначена помилка
    221              for (unsigned int i = 0; i < 7; i++) *(name_string + start_position + i) = '?';
    222              *(name_string + start_position + 7) = ' ';
    223            }
    224          }
    225          /*****************************************************/
    226          
    227          /*****************************************************/
    228          //Формуємо екран відображення струмів
    229          /*****************************************************/
    230          void make_ekran_measurement(void)
    231          {
    232            
    233            uint8_t name_string[MAX_ROW_FOR_MEASURMENT_ANALOG_INPUT][MAX_COL_LCD + 1] = 
    234            {
    235              " I1 =           ",
    236              " I2 =           ",
    237              " I3 =           ",
    238              " I4 =           ",
    239              " U  =           "
    240            };
    241            
    242            const uint32_t index_array[MAX_ROW_FOR_MEASURMENT_ANALOG_INPUT] = 
    243            {
    244              IM_I1,
    245              IM_I2,
    246              IM_I3,
    247              IM_I4,
    248              IM_U
    249            };
    250            
    251            //Копіюємо вимірювання які потрібні для відображення
    252            semaphore_measure_values_low1 = 1;
    253            for (size_t i = 0; i < MAX_ROW_FOR_MEASURMENT_ANALOG_INPUT; i++ ) 
    254            {
    255              unsigned int index_to_copy = index_array[i];
    256              measurement_low[index_to_copy] = measurement_middle[index_to_copy];
    257            }
    258            semaphore_measure_values_low1 = 0;
    259          
    260            int index_language = index_language_in_array(settings_fix_prt.language);
    261          #define COL_ODYNYCI_VYM 14
    262            for(size_t index_1 = 0; index_1 < MAX_ROW_FOR_MEASURMENT_ANALOG_INPUT; index_1++)
    263            {
    264              if (index_1 < (MAX_ROW_FOR_MEASURMENT_ANALOG_INPUT - 1))
    265                name_string[index_1][COL_ODYNYCI_VYM] = odynyci_vymirjuvannja[index_language][INDEX_A];
    266              else
    267                name_string[index_1][COL_ODYNYCI_VYM] = odynyci_vymirjuvannja[index_language][INDEX_V];
    268            }
    269          #undef COL_ODYNYCI_VYM
    270            
    271            int position_temp = current_state_menu2.index_position;
    272            int index_in_ekran = (position_temp >> POWER_MAX_ROW_LCD) << POWER_MAX_ROW_LCD;
    273            
    274            //Копіюємо  рядки у робочий екран
    275            for (size_t i = 0; i < MAX_ROW_LCD; i++)
    276            {
    277              //Наступні рядки треба перевірити, чи їх требе відображати у текучій кофігурації
    278              if (index_in_ekran < MAX_ROW_FOR_MEASURMENT_ANALOG_INPUT)
    279              {
    280                /********************************/
    281                //Вводимо вимірювальні значення  
    282                /********************************/
    283                unsigned int index = index_array[index_in_ekran];
    284                unsigned int start_number_digit_after_point = 3;
    285                convert_and_insert_char_for_measurement(start_number_digit_after_point, measurement_low[index], 1, 1, name_string[index_in_ekran], 6);
    286                /********************************/
    287          
    288                for (size_t j = 0; j < MAX_COL_LCD; j++) working_ekran[i][j] = name_string[index_in_ekran][j];
    289              }
    290              else
    291                for (size_t j = 0; j < MAX_COL_LCD; j++) working_ekran[i][j] = ' ';
    292          
    293              index_in_ekran++;
    294            }
    295          
    296            //Курсор по горизонталі відображається на першій позиції
    297            current_state_menu2.position_cursor_x = 0;
    298            //Відображення курору по вертикалі
    299            current_state_menu2.position_cursor_y = position_temp & (MAX_ROW_LCD - 1);
    300            //Курсор видимий
    301            current_state_menu2.cursor_on = 1;
    302            //Курсор не мигає
    303            current_state_menu2.cursor_blinking_on = 0;
    304            //Обновити повністю весь екран
    305            current_state_menu2.current_action = ACTION_WITH_CARRENT_EKRANE_FULL_UPDATE;
    306          }
    307          /*****************************************************/
    308          
    309          /*****************************************************/
    310          //
    311          /*****************************************************/
    312          /*****************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      52   convert_and_insert_char_for_measurement
        52 __aeabi_uldivmod
     144   make_ekran_measurement
       144   -> __aeabi_memcpy4
       144   -> convert_and_insert_char_for_measurement
       144   -> index_language_in_array


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_10
       4  ??DataTable1_11
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable1_5
       4  ??DataTable1_6
       4  ??DataTable1_7
       4  ??DataTable1_8
       4  ??DataTable1_9
      20  ?_0
      88  ?_1
     758  convert_and_insert_char_for_measurement
     286  make_ekran_measurement

 
   108 bytes in section .rodata
 1 092 bytes in section .text
 
 1 092 bytes of CODE  memory
   108 bytes of CONST memory

Errors: none
Warnings: none
