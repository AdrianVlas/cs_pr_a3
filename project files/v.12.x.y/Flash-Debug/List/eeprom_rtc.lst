###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       24/Mar/2017  12:54:54
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\eeprom_rtc.c
#    Command line =  
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\eeprom_rtc.c" -D USE_STDPERIPH_DRIVER -D STM32F2XX -D
#        USE_USB_OTG_FS -D KEYBOARD_VER_1 -D SYSTEM_VIEWER_ENABLE -lc
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List" --remarks -o
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --enable_multibytes --fpu=None
#        --dlib_config G:\PRG\IAR7_50_2\arm\INC\c\DLib_Config_Full.h -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\usb\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_OTG_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Core\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\"
#        -I "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\Config\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\OS\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\SEGGER\" -On --use_c++_inline
#        --require_prototypes -I G:\PRG\IAR7_50_2\arm\CMSIS\Include\ -D
#        ARM_MATH_CM3
#    List file    =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List\eeprom_rtc.lst
#    Object file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj\eeprom_rtc.o
#
###############################################################################

G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working files\src\eeprom_rtc.c
      1          #include "header.h"
      2          
      3          
      4          /*****************************************************/
      5          //Старт  запису буферу по I2C
      6          /*
      7            Результат
      8            0 - почався новий обмін
      9            1 - покищо лінія зайнята
     10            2 - не запущений обмін через помилки на i2C
     11          */
     12          /*****************************************************/
     13          unsigned int start_write_buffer_via_I2C(uint32_t device_id, uint16_t WriteAddr,  uint8_t volatile* pBuffer, uint32_t number)
     14          {
     15            unsigned int error = 0; //0 - успішно виконано; 1 - лінія зайнята; 2 - інші помилки
     16            //Перевіряємо чи у процесі аналізу попередньої транзакції скинуті попередні помилки
     17            if (type_error_of_exchanging_via_i2c != 0)
     18            {
     19              type_error_of_exchanging_via_i2c |= (1<<ERROR_TOTAL_BIT);
     20              error = 2;
     21            }
     22            else
     23            {
     24              /*Перевіряємо чи лінія є зайнятою на момент запуску цієї функції*/
     25              if (I2C_GetFlagStatus(I2C, I2C_FLAG_BUSY))
     26              {
     27                if (number_busy_state < MAX_NUMBER_BUSY_STATE)
     28                {
     29                  error = 1;
     30                  number_busy_state++;
     31                }
     32                else
     33                {
     34                  type_error_of_exchanging_via_i2c |= (1<<ERROR_TOTAL_BIT);
     35                  error = 2;
     36                }
     37                    
     38                /***/
     39                //Перевірка, чи є непрочитані дані
     40                /***/
     41                unsigned int temp_value = 0;
     42                while (((I2C_GetLastEvent(I2C) & I2C_EVENT_MASTER_BYTE_RECEIVED_NO_BUSY) !=0) && (temp_value < 100 ))
     43                {
     44                  I2C_AcknowledgeConfig(I2C, DISABLE);
     45                  I2C_GenerateSTOP(I2C, ENABLE);
     46                  I2C_ReceiveData(I2C);
     47                  temp_value++;
     48                }
     49                if (temp_value >= 100 )
     50                {
     51                  type_error_of_exchanging_via_i2c |= (1<<ERROR_TOTAL_BIT);
     52                  error = 2;
     53                }
     54                /***/
     55              }
     56              else
     57              {
     58                //Очищаємо кількість BUSY станів
     59                number_busy_state = 0;
     60          
     61                //Заповнюємо структуру драйверу обміну через I2C
     62                driver_i2c.state_execution = 0;
     63                driver_i2c.device_id = device_id;
     64                driver_i2c.action = 2;
     65                driver_i2c.internal_address = WriteAddr;
     66                driver_i2c.number_bytes = number;
     67                driver_i2c.point_buffer = pBuffer;
     68                
     69                //Виставляємо генерацію ACK операції читання (хоч при операції запису цей біт не мав би впливати)
     70                I2C_AcknowledgeConfig(I2C, ENABLE);
     71          
     72                /*Стираємо можливі помилки, які можуть бути виставленими у регістрі статусу*/
     73                I2C_ClearFlag(I2C, I2C_FLAG_TIMEOUT | I2C_FLAG_OVR | I2C_FLAG_AF | I2C_FLAG_ARLO | I2C_FLAG_BERR);
     74                
     75                /* Дозволяємо для I2C генерацію переривань по подіях */
     76                I2C_ITConfig(I2C, I2C_IT_EVT, ENABLE);
     77                
     78                /* Посилаємо STRAT*/
     79                I2C_GenerateSTART(I2C, ENABLE);
     80              }
     81            }
     82            
     83            return error;      
     84          }
     85          /*****************************************************/
     86          
     87          /*****************************************************/
     88          //Старт  читання буферу по I2C
     89          /*
     90            Результат
     91            0 - почався новий обмін
     92            1 - покищо лінія зайнята
     93            2 - не запущений обмін через помилки на i2C
     94          */
     95          /*****************************************************/
     96          unsigned int start_read_buffer_via_I2C(uint32_t device_id, uint16_t ReadAddr, uint8_t volatile* pBuffer, uint32_t number)
     97          {
     98            unsigned int error = 0; //0 - успішно виконано; 1 - лінія зайнята; 2 - інші помилки
     99            //Перевіряємо чи у процесі аналізу попередньої транзакції скинуті попередні помилки
    100            if (type_error_of_exchanging_via_i2c != 0)
    101            {
    102              type_error_of_exchanging_via_i2c |= (1<<ERROR_TOTAL_BIT);
    103              error = 2;
    104            }
    105            else
    106            {
    107              /*Перевіряємо чи лінія є зайнятою на момент запуску цієї функції*/
    108              if (I2C_GetFlagStatus(I2C, I2C_FLAG_BUSY))
    109              {
    110                if (number_busy_state < MAX_NUMBER_BUSY_STATE)
    111                {
    112                  error = 1;
    113                  number_busy_state++;
    114                }
    115                else
    116                {
    117                  type_error_of_exchanging_via_i2c |= (1<<ERROR_TOTAL_BIT);
    118                  error = 2;
    119                }
    120                    
    121                /***/
    122                //Перевірка, чи є непрочитані дані
    123                /***/
    124                unsigned int temp_value = 0;
    125                while (((I2C_GetLastEvent(I2C) & I2C_EVENT_MASTER_BYTE_RECEIVED_NO_BUSY) !=0) && (temp_value < 100 ))
    126                {
    127                  I2C_AcknowledgeConfig(I2C, DISABLE);
    128                  I2C_GenerateSTOP(I2C, ENABLE);
    129                  I2C_ReceiveData(I2C);
    130                  temp_value++;
    131                }
    132                if (temp_value >= 100 )
    133                {
    134                  type_error_of_exchanging_via_i2c |= (1<<ERROR_TOTAL_BIT);
    135                  error = 2;
    136                }
    137                /***/
    138              }
    139              else
    140              {
    141                //Очищаємо кількість BUSY станів
    142                number_busy_state = 0;
    143                
    144                //Заповнюэмо структуру драйверу обміну через I2C
    145                driver_i2c.state_execution = 0;
    146                driver_i2c.device_id = device_id;
    147                driver_i2c.action = 0;
    148                driver_i2c.internal_address = ReadAddr;
    149                driver_i2c.number_bytes = number;
    150                driver_i2c.point_buffer = pBuffer;
    151                
    152                //Виставляємо генерацію ACK операції читання
    153                I2C_AcknowledgeConfig(I2C, ENABLE);
    154          
    155                /*Стираємо можливі помилки, які можуть бути виставленими у регістрі статусу*/
    156                I2C_ClearFlag(I2C, I2C_FLAG_TIMEOUT | I2C_FLAG_OVR | I2C_FLAG_AF | I2C_FLAG_ARLO | I2C_FLAG_BERR);
    157                
    158                /* Дозволяємо для I2C генерацію переривань по подіях */
    159                I2C_ITConfig(I2C, I2C_IT_EVT, ENABLE);
    160                
    161                /* Посилаємо STRAT*/
    162                I2C_GenerateSTART(I2C, ENABLE);
    163              }
    164            }
    165            
    166            return error;      
    167          }
    168          /*****************************************************/
    169          
    170          /*****************************************************/
    171          //Управління обміном через I2C
    172          /*****************************************************/
    173          void main_routines_for_i2c(void)
    174          {
    175            //Статична змінна, яка вказує який блок конфігурації треба записувати у EEPROM
    176            static unsigned int number_block_config_write_to_eeprom;
    177            //Статична змінна, яка вказує який блок настройок треба записувати у EEPROM
    178            static unsigned int number_block_settings_write_to_eeprom;
    179            //Статична змінна, яка вказує з якої адреси треба почати записувати налаштування у EEPROM
    180            static size_t shift_from_start_address_settings_in_eeprom;
    181            //Статична змінна, яка вказує скільки байт налаштувань підготовлено для запису у EEPROM
    182            static size_t size_settings;
    183            //Статична змінна, яка вказує який блок юстування треба записувати у EEPROM
    184            static unsigned int number_block_ustuvannja_write_to_eeprom;
    185            //Статична змінна, яка вказує який блок триґерної інформації треба записувати у EEPROM
    186          //  static unsigned int number_block_trg_func_write_to_eeprom;
    187            //Статична змінна, яка вказує який блок інформації по реєстраторі програмних подій треба записувати у EEPROM
    188            static unsigned int number_block_info_rejestrator_pr_err_write_to_eeprom;
    189            
    190            static unsigned int temp_value_for_rtc;
    191            
    192            //Статичні змінні для контролю коректності запису
    193            static __CONFIG current_config_comp;
    194            static unsigned int ustuvannja_comp[NUMBER_ANALOG_CANALES], serial_number_dev_comp;
    195          //  static unsigned int trigger_active_functions_comp[N_BIG];
    196            static __INFO_REJESTRATOR info_rejestrator_pr_err_comp;
    197            
    198            if (driver_i2c.state_execution < 0)
    199            {
    200              /*************************************************/
    201              //Зараз можна ініціювати нову трансакцію через I2C
    202              /*************************************************/
    203              
    204              if(_CHECK_SET_BIT(control_i2c_taskes, TASK_SET_START_SETTINGS_RTC_BIT) !=0)
    205              {
    206                unsigned int rez;
    207                
    208                //Виставляння регістрів RTC у потрібні стартові значення для того, щоб на виході мати 1 Гц
    209                if (etap_settings_test_frequency == 0)
    210                {
    211                  read_write_i2c_buffer[0] = temp_register_rtc[0];
    212                  rez = start_write_buffer_via_I2C(RTC_ADDRESS, 0xC, read_write_i2c_buffer, 1);
    213                }
    214                else if (etap_settings_test_frequency == 1)
    215                {
    216                  read_write_i2c_buffer[0] = 0xf0;
    217                  rez = start_write_buffer_via_I2C(RTC_ADDRESS, 0x13, read_write_i2c_buffer, 1);
    218                }
    219                else
    220                {
    221                  read_write_i2c_buffer[0] = temp_register_rtc[1];
    222                  rez = start_write_buffer_via_I2C(RTC_ADDRESS, 0xA, read_write_i2c_buffer, 1);
    223                }
    224                
    225                //Аналізуємо успішність запуску нового запису
    226                if (rez > 1)
    227                {
    228                  error_start_i2c();
    229                  
    230                  //Покищо просто очищаємо змінну, яка конкретизуєм помилку, у майбутньому її можна буде конкретизувати
    231                  type_error_of_exchanging_via_i2c = 0;
    232                }
    233                else if (rez == 0) _SET_BIT(clear_diagnostyka, ERROR_START_VIA_I2C_BIT);
    234              }
    235              else if((_CHECK_SET_BIT(control_i2c_taskes, TASK_RESET_OF_RTC_BIT) !=0) || (_CHECK_SET_BIT(control_i2c_taskes, TASK_RESET_ST_RTC_BIT) !=0))
    236              {
    237                unsigned int rez;
    238                
    239                if (_CHECK_SET_BIT(control_i2c_taskes, TASK_RESET_OF_RTC_BIT) !=0)
    240                {
    241                  //Скидання OF-біт в RTC
    242                  if (etap_reset_of_bit == ETAP_CLEAR_OF_ST_STOP)
    243                    read_write_i2c_buffer[0] = time[1] | (1<<7); //ST = 1
    244                  else if (etap_reset_of_bit == ETAP_CLEAR_OF_ST_CLEAR)
    245                    read_write_i2c_buffer[0] = time[1] & (~(1<<7)) ; //ST = 0
    246                  else
    247                    read_write_i2c_buffer[0] = (unsigned char)(temp_value_for_rtc) & (~(1<<2)) ; //OF = 0
    248                }
    249                else
    250                {
    251                  read_write_i2c_buffer[0] = time[1] & (~(1<<7)) ; //ST = 0
    252                }
    253                if ((_CHECK_SET_BIT(control_i2c_taskes, TASK_RESET_OF_RTC_BIT) !=0) && (etap_reset_of_bit != ETAP_CLEAR_OF_ST_STOP) &&(etap_reset_of_bit != ETAP_CLEAR_OF_ST_CLEAR))
    254                  rez = start_write_buffer_via_I2C(RTC_ADDRESS, 0xF, read_write_i2c_buffer, 1);
    255                else 
    256                  rez = start_write_buffer_via_I2C(RTC_ADDRESS, 0x1, read_write_i2c_buffer, 1);
    257                
    258                //Аналізуємо успішність запуску нового запису
    259                if (rez > 1)
    260                {
    261                  error_start_i2c();
    262                  
    263                  //Покищо просто очищаємо змінну, яка конкретизуєм помилку, у майбутньому її можна буде конкретизувати
    264                  type_error_of_exchanging_via_i2c = 0;
    265                }
    266                else if (rez == 0) _SET_BIT(clear_diagnostyka, ERROR_START_VIA_I2C_BIT);
    267              }
    268              else if(
    269                      (_CHECK_SET_BIT(control_i2c_taskes, TASK_BLK_WRITING_EEPROM_BIT) !=0) ||
    270                      (_CHECK_SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT)      !=0)
    271                     )
    272              {
    273                //Зараз треба зачекати з початною опрерацією, тому просто виходимо з цієї підпрограми
    274              }
    275              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_CONFIG_EEPROM_BIT) !=0)
    276              {
    277                //Стоїть умова запису блоку у EEPROM конфігурації
    278          
    279                int size_to_end;
    280                unsigned int rez, offset_from_start;
    281                
    282                //Визначаємо з якого місця треба почати записувати
    283                offset_from_start = number_block_config_write_to_eeprom*SIZE_PAGE_EEPROM;
    284          
    285                //Кількість байт до кінця буферу 
    286                size_to_end = (sizeof(__CONFIG) + 1) - offset_from_start; 
    287                
    288                if (size_to_end > 0)
    289                {
    290                  if (size_to_end < SIZE_PAGE_EEPROM)
    291                    rez = start_write_buffer_via_I2C(EEPROM_ADDRESS, (START_ADDRESS_CONFIG_IN_EEPROM + offset_from_start), (read_write_i2c_buffer + offset_from_start), size_to_end);
    292                  else
    293                    rez = start_write_buffer_via_I2C(EEPROM_ADDRESS, (START_ADDRESS_CONFIG_IN_EEPROM + offset_from_start), (read_write_i2c_buffer + offset_from_start), SIZE_PAGE_EEPROM);
    294                  
    295                  //Аналізуємо успішність запуску нового запису
    296                  if (rez > 1)
    297                  {
    298                    error_start_i2c();          
    299                    
    300                    //Покищо просто очищаємо змінну, яка конкретизуєм помилку, у майбутньому її можна буде конкретизувати
    301                    type_error_of_exchanging_via_i2c = 0;
    302                  }
    303                  else if (rez == 0) _SET_BIT(clear_diagnostyka, ERROR_START_VIA_I2C_BIT);
    304                }
    305                else
    306                {
    307                  //Весь масив конфігурації вже записаний
    308                  
    309                  //Виставляємо команду контрольного читання для перевідрки достовірності записаної інформації
    310                  comparison_writing |= COMPARISON_WRITING_CONFIG;
    311                  _SET_BIT(control_i2c_taskes, TASK_START_READ_CONFIG_EEPROM_BIT);
    312                  _SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);        
    313                  
    314                  //Скидаємо умову запису конфігурації у EEPROM
    315                  _CLEAR_BIT(control_i2c_taskes, TASK_WRITING_CONFIG_EEPROM_BIT);
    316                }
    317                
    318              }
    319              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_SETTINGS_EEPROM_BIT) !=0)
    320              {
    321                //Стоїть умова запису блоку у EEPROM настройок
    322          
    323                int size_to_end;
    324                unsigned int rez, offset_from_start;
    325                
    326                //Визначаємо з якого місця треба почати записувати
    327                offset_from_start = number_block_settings_write_to_eeprom*SIZE_PAGE_EEPROM;
    328          
    329                //Кількість байт до кінця буферу 
    330                size_to_end = size_settings - offset_from_start; 
    331                
    332                if (size_to_end > 0)
    333                {
    334                  if (size_to_end < SIZE_PAGE_EEPROM)
    335                    rez = start_write_buffer_via_I2C(EEPROM_ADDRESS, (START_ADDRESS_SETTINGS_IN_EEPROM + shift_from_start_address_settings_in_eeprom + offset_from_start), (read_write_i2c_buffer + offset_from_start), size_to_end);
    336                  else
    337                    rez = start_write_buffer_via_I2C(EEPROM_ADDRESS, (START_ADDRESS_SETTINGS_IN_EEPROM + shift_from_start_address_settings_in_eeprom + offset_from_start), (read_write_i2c_buffer + offset_from_start), SIZE_PAGE_EEPROM);
    338                  
    339                  //Аналізуємо успішність запуску нового запису
    340                  if (rez > 1)
    341                  {
    342                    error_start_i2c();          
    343                    
    344                    //Покищо просто очищаємо змінну, яка конкретизуєм помилку, у майбутньому її можна буде конкретизувати
    345                    type_error_of_exchanging_via_i2c = 0;
    346                  }
    347                  else if (rez == 0) _SET_BIT(clear_diagnostyka, ERROR_START_VIA_I2C_BIT);
    348                }
    349                else
    350                {
    351                  //Порція масиву налаштувань вже записана
    352                  _CLEAR_BIT(control_i2c_taskes, TASK_WRITING_SETTINGS_EEPROM_BIT);
    353                }
    354                
    355              }
    356              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_USTUVANNJA_EEPROM_BIT) !=0)
    357              {
    358                //Стоїть умова запису блоку у EEPROM юстування
    359          
    360                int size_to_end;
    361                unsigned int rez, offset_from_start;
    362                
    363                //Визначаємо з якого місця треба почати записувати
    364                offset_from_start = number_block_ustuvannja_write_to_eeprom*SIZE_PAGE_EEPROM;
    365          
    366                //Кількість байт до кінця буферу 
    367                size_to_end = (SIZE_USTUVANNJA + 1) - offset_from_start; 
    368                
    369                if (size_to_end > 0)
    370                {
    371                  if (size_to_end < SIZE_PAGE_EEPROM)
    372                    rez = start_write_buffer_via_I2C(EEPROM_ADDRESS, (START_ADDRESS_USTUVANNJA_IN_EEPROM + offset_from_start), (read_write_i2c_buffer + offset_from_start), size_to_end);
    373                  else
    374                    rez = start_write_buffer_via_I2C(EEPROM_ADDRESS, (START_ADDRESS_USTUVANNJA_IN_EEPROM + offset_from_start), (read_write_i2c_buffer + offset_from_start), SIZE_PAGE_EEPROM);
    375                  
    376                  //Аналізуємо успішність запуску нового запису
    377                  if (rez > 1)
    378                  {
    379                    error_start_i2c();          
    380                    
    381                    //Покищо просто очищаємо змінну, яка конкретизуєм помилку, у майбутньому її можна буде конкретизувати
    382                    type_error_of_exchanging_via_i2c = 0;
    383                  }
    384                  else if (rez == 0) _SET_BIT(clear_diagnostyka, ERROR_START_VIA_I2C_BIT);
    385                }
    386                else
    387                {
    388                  //Весь масив юстування вже записаний
    389          
    390                  //Виставляємо команду контрольного читання для перевідрки достовірності записаної інформації
    391                  comparison_writing |= COMPARISON_WRITING_USTUVANNJA;
    392                  _SET_BIT(control_i2c_taskes, TASK_START_READ_USTUVANNJA_EEPROM_BIT);
    393                  _SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);        
    394                  
    395                  //Скидаємо умову запису юстування у EEPROM
    396                  _CLEAR_BIT(control_i2c_taskes, TASK_WRITING_USTUVANNJA_EEPROM_BIT);
    397                }
    398              }
    399          //    else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_TRG_FUNC_EEPROM_BIT) !=0)
    400          //    {
    401          //      //Стоїть умова запису блоку триґерної інформації
    402          //
    403          //      int size_to_end;
    404          //      unsigned int rez, offset_from_start;
    405          //      
    406          //      //Визначаємо з якого місця треба почати записувати
    407          //      offset_from_start = number_block_trg_func_write_to_eeprom*SIZE_PAGE_EEPROM;
    408          //
    409          //      //Кількість байт до кінця буферу 
    410          //      size_to_end = (sizeof(trigger_active_functions) + 1) - offset_from_start; 
    411          //      
    412          //      if (size_to_end > 0)
    413          //      {
    414          //        if (size_to_end < SIZE_PAGE_EEPROM)
    415          //          rez = start_write_buffer_via_I2C(EEPROM_ADDRESS, (START_ADDRESS_TRG_FUNC + offset_from_start), (read_write_i2c_buffer + offset_from_start), size_to_end);
    416          //        else
    417          //          rez = start_write_buffer_via_I2C(EEPROM_ADDRESS, (START_ADDRESS_TRG_FUNC + offset_from_start), (read_write_i2c_buffer + offset_from_start), SIZE_PAGE_EEPROM);
    418          //        
    419          //        //Аналізуємо успішність запуску нового запису
    420          //        if (rez > 1)
    421          //        {
    422          //          error_start_i2c();          
    423          //          
    424          //          //Покищо просто очищаємо змінну, яка конкретизуєм помилку, у майбутньому її можна буде конкретизувати
    425          //          type_error_of_exchanging_via_i2c = 0;
    426          //        }
    427          //        else if (rez == 0) _SET_BIT(clear_diagnostyka, ERROR_START_VIA_I2C_BIT);
    428          //      }
    429          //      else
    430          //      {
    431          //        //Весь масив вже записаний
    432          //       
    433          //        //Виставляємо команду контрольного читання для перевідрки достовірності записаної інформації
    434          //        comparison_writing |= COMPARISON_WRITING_TRG_FUNC;
    435          //        _SET_BIT(control_i2c_taskes, TASK_START_READ_TRG_FUNC_EEPROM_BIT);
    436          //        _SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);        
    437          //
    438          //        //Cкидаємо умову запису інформації аналогового реєстратора у EEPROM
    439          //        _CLEAR_BIT(control_i2c_taskes, TASK_WRITING_TRG_FUNC_EEPROM_BIT);
    440          //      }
    441          //      
    442          //    }
    443              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT) !=0)
    444              {
    445                //Стоїть умова запису блоку інформації реєстратора програмних подій у EEPROM
    446          
    447                int size_to_end;
    448                unsigned int rez, offset_from_start;
    449                
    450                //Визначаємо з якого місця треба почати записувати
    451                offset_from_start = number_block_info_rejestrator_pr_err_write_to_eeprom*SIZE_PAGE_EEPROM;
    452          
    453                //Кількість байт до кінця буферу 
    454                size_to_end = (sizeof(info_rejestrator_pr_err) + 1) - offset_from_start; 
    455                
    456                if (size_to_end > 0)
    457                {
    458                  if (size_to_end < SIZE_PAGE_EEPROM)
    459                    rez = start_write_buffer_via_I2C(EEPROM_ADDRESS, (START_ADDRESS_INFO_REJESTRATORS_PR_ERR + offset_from_start), (read_write_i2c_buffer + offset_from_start), size_to_end);
    460                  else
    461                    rez = start_write_buffer_via_I2C(EEPROM_ADDRESS, (START_ADDRESS_INFO_REJESTRATORS_PR_ERR + offset_from_start), (read_write_i2c_buffer + offset_from_start), SIZE_PAGE_EEPROM);
    462                  
    463                  //Аналізуємо успішність запуску нового запису
    464                  if (rez > 1)
    465                  {
    466                    error_start_i2c();          
    467                    
    468                    //Покищо просто очищаємо змінну, яка конкретизуєм помилку, у майбутньому її можна буде конкретизувати
    469                    type_error_of_exchanging_via_i2c = 0;
    470                  }
    471                  else if (rez == 0) _SET_BIT(clear_diagnostyka, ERROR_START_VIA_I2C_BIT);
    472                }
    473                else
    474                {
    475                  //Весь масив вже записаний
    476                 
    477                  //Виставляємо команду контрольного читання для перевідрки достовірності записаної інформації
    478                  comparison_writing |= COMPARISON_WRITING_INFO_REJESTRATOR_PR_ERR;
    479                  _SET_BIT(control_i2c_taskes, TASK_START_READ_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT);
    480                  _SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);        
    481          
    482                  //Cкидаємо умову запису інформації реєстратора програмних подій у EEPROM
    483                  _CLEAR_BIT(control_i2c_taskes, TASK_WRITING_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT);
    484                }
    485                
    486              }
    487              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_START_READ_CONFIG_EEPROM_BIT) !=0)
    488              {
    489                unsigned int rez;
    490          
    491                //Запускаємо процес читання конфігурації
    492                rez = start_read_buffer_via_I2C(EEPROM_ADDRESS, START_ADDRESS_CONFIG_IN_EEPROM, read_write_i2c_buffer, (sizeof(__CONFIG) + 1));
    493                
    494                //Аналізуємо успішність запуску нового запису
    495                if (rez > 1)
    496                {
    497                  error_start_i2c();
    498                  
    499                  //Покищо просто очищаємо змінну, яка конкретизуєм помилку, у майбутньому її можна буде конкретизувати
    500                  type_error_of_exchanging_via_i2c = 0;
    501                }
    502                else if (rez == 0)
    503                {
    504                  _SET_BIT(clear_diagnostyka, ERROR_START_VIA_I2C_BIT);
    505          
    506                  //При успішнопу запуску читання скидаємо біт запуску читання конфігурації і виставляємо біт процесу читання конфігурації
    507                  _SET_BIT(control_i2c_taskes, TASK_READING_CONFIG_EEPROM_BIT);
    508                  _SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);        
    509                  _CLEAR_BIT(control_i2c_taskes, TASK_START_READ_CONFIG_EEPROM_BIT);
    510                }
    511              }
    512              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_START_READ_SETTINGS_EEPROM_BIT) !=0)
    513              {
    514                //Запускаємо процес читання настройок
    515                static enum _id_fb block;
    516                static unsigned int shift;
    517          
    518                if (
    519                    (shift_from_start_address_settings_in_eeprom == 0) &&
    520                    (size_settings == 0)  
    521                   )   
    522                {
    523                  block = _ID_FB_FIRST_ALL;
    524                  shift = 0;
    525                }
    526                
    527                if (size_settings == 0)
    528                {
    529                  //Якщо ця статична змінна size_setting рівна нулю, то це ознаає що прочитані дані вже оброблені і можна читати наступний блок
    530                  size_t size_of_block = 0;
    531                  size_t size = 0;
    532                  while(
    533                        (size < SIZE_BUFFER_FOR_EEPROM_EXCHNGE) &&
    534                        (block < _ID_FB_LAST_ALL)
    535                       )
    536                  {
    537                    //Визначаємо розмір нового блоку
    538                    switch (block)
    539                    {
    540                    case ID_FB_CONTROL_BLOCK:
    541                      {
    542                        size_of_block = sizeof(__SETTINGS_FIX);
    543                        break;
    544                      }
    545                    case ID_FB_INPUT:
    546                      {
    547                        size_of_block = current_config.n_input*sizeof(__settings_for_INPUT);
    548                        break;
    549                      }
    550                    case ID_FB_OUTPUT:
    551                      {
    552                        size_of_block = current_config.n_output*sizeof(__settings_for_OUTPUT);
    553                        break;
    554                      }
    555                    case ID_FB_LED:
    556                      {
    557                        size_of_block = current_config.n_led*sizeof(__settings_for_LED);
    558                        break;
    559                      }
    560                    case ID_FB_ALARM:
    561                      {
    562                        size_of_block = current_config.n_alarm*sizeof(__settings_for_ALARM);
    563                        break;
    564                      }
    565                    case ID_FB_GROUP_ALARM:
    566                      {
    567                        size_of_block = current_config.n_group_alarm*sizeof(__settings_for_GROUP_ALARM);
    568                        break;
    569                      }
    570                    case ID_FB_AND:
    571                      {
    572                        size_of_block = current_config.n_and*sizeof(__settings_for_AND);
    573                        break;
    574                      }
    575                    case ID_FB_OR:
    576                      {
    577                        size_of_block = current_config.n_or*sizeof(__settings_for_OR);
    578                        break;
    579                      }
    580                    case ID_FB_XOR:
    581                      {
    582                        size_of_block = current_config.n_xor*sizeof(__settings_for_XOR);
    583                        break;
    584                      }
    585                    case ID_FB_NOT:
    586                      {
    587                        size_of_block = current_config.n_not*sizeof(__settings_for_NOT);
    588                        break;
    589                      }
    590                    case ID_FB_TIMER:
    591                      {
    592                        size_of_block = current_config.n_timer*sizeof(__settings_for_TIMER);
    593                        break;
    594                      }
    595                    case ID_FB_TRIGGER:
    596                      {
    597                        size_of_block = current_config.n_trigger*sizeof(__settings_for_TRIGGER);
    598                        break;
    599                      }
    600                    case ID_FB_MEANDER:
    601                      {
    602                        size_of_block = current_config.n_meander*sizeof(__settings_for_MEANDER);
    603                        break;
    604                      }
    605                    default:
    606                      {
    607                        //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
    608                        total_error_sw_fixed(53);
    609                      }
    610                    }
    611                
    612                    size_t size_tmp = size + (size_of_block - shift);
    613                    if (size_tmp <= SIZE_BUFFER_FOR_EEPROM_EXCHNGE) 
    614                    {
    615                      shift = 0;
    616                      block++;
    617                      size = size_tmp;
    618                    }
    619                    else
    620                    {
    621                      shift += SIZE_BUFFER_FOR_EEPROM_EXCHNGE - size;
    622                      size = SIZE_BUFFER_FOR_EEPROM_EXCHNGE;
    623                    }
    624                  }
    625                  size_settings = size;
    626                }
    627                
    628                if (
    629                    (size_settings < SIZE_BUFFER_FOR_EEPROM_EXCHNGE) &&
    630                    (block == _ID_FB_LAST_ALL)
    631                   )   
    632                {
    633                  //Додаємо ще контрольу суму для читання
    634                  size_settings++;
    635                  block++; /*це робимо для того, щоб коли наступний раз попадемо у цю частину програми, то не додавти ще один байтт для читання, а скинути всі статичні змінні і завршити процедуру читання*/
    636          
    637                }
    638                
    639                if (size_settings != 0) 
    640                {
    641                  /*Тепер вже нерівність нулю цієї статичної змінної означає, що є що читати*/
    642                  unsigned int rez = start_read_buffer_via_I2C(EEPROM_ADDRESS, START_ADDRESS_SETTINGS_IN_EEPROM + shift_from_start_address_settings_in_eeprom, read_write_i2c_buffer, size_settings);
    643                  //Аналізуємо успішність запуску нового запису
    644                  if (rez > 1)
    645                  {
    646                    error_start_i2c();
    647                  
    648                    //Покищо просто очищаємо змінну, яка конкретизуєм помилку, у майбутньому її можна буде конкретизувати
    649                    type_error_of_exchanging_via_i2c = 0;
    650                  }
    651                  else if (rez == 0)
    652                  {
    653                    _SET_BIT(clear_diagnostyka, ERROR_START_VIA_I2C_BIT);
    654          
    655                    //При успішнопу запуску читання виставляємо біт процесу читання настройок
    656                    _SET_BIT(control_i2c_taskes, TASK_READING_SETTINGS_EEPROM_BIT);
    657                    _SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);        
    658                  }
    659                }
    660                else
    661                {
    662                  //Скидаємо всі статичні змінні, які використовуютья при записі налаштувань
    663                  block = _ID_FB_FIRST_ALL;
    664                  shift = 0;
    665          
    666                  shift_from_start_address_settings_in_eeprom = 0;
    667                  size_settings = 0;
    668          
    669                  //Знімаємо можливу сигналізацію, що виконувалося порівнняння
    670                  comparison_writing &= (unsigned int)(~COMPARISON_WRITING_SETTINGS);
    671                  //Скидаємо біт команди читання налаштувань
    672                  _CLEAR_BIT(control_i2c_taskes, TASK_START_READ_SETTINGS_EEPROM_BIT);
    673                }
    674              }
    675              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_START_READ_USTUVANNJA_EEPROM_BIT) !=0)
    676              {
    677                unsigned int rez;
    678                
    679                //Запускаємо процес читання юстування
    680                rez = start_read_buffer_via_I2C(EEPROM_ADDRESS, START_ADDRESS_USTUVANNJA_IN_EEPROM, read_write_i2c_buffer, (SIZE_USTUVANNJA + 1));
    681                
    682                //Аналізуємо успішність запуску
    683                if (rez > 1)
    684                {
    685                  error_start_i2c();
    686                  
    687                  //Покищо просто очищаємо змінну, яка конкретизуєм помилку, у майбутньому її можна буде конкретизувати
    688                  type_error_of_exchanging_via_i2c = 0;
    689                }
    690                else if (rez == 0)
    691                {
    692                  _SET_BIT(clear_diagnostyka, ERROR_START_VIA_I2C_BIT);
    693          
    694                  //При успішнопу запуску читання скидаємо біт запуску читання юстування і виставляємо біт процесу читання юстування
    695                  _SET_BIT(control_i2c_taskes, TASK_READING_USTUVANNJA_EEPROM_BIT);
    696                  _SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);        
    697                  _CLEAR_BIT(control_i2c_taskes, TASK_START_READ_USTUVANNJA_EEPROM_BIT);
    698                }
    699              }
    700          //    else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_START_READ_TRG_FUNC_EEPROM_BIT) !=0)
    701          //    {
    702          //      unsigned int rez;
    703          //
    704          //      //Запускаємо процес читання
    705          //      rez = start_read_buffer_via_I2C(EEPROM_ADDRESS, START_ADDRESS_TRG_FUNC, read_write_i2c_buffer, (sizeof(trigger_active_functions) + 1));
    706          //      
    707          //      //Аналізуємо успішність запуску
    708          //      if (rez > 1)
    709          //      {
    710          //        error_start_i2c();
    711          //        
    712          //        //Покищо просто очищаємо змінну, яка конкретизуєм помилку, у майбутньому її можна буде конкретизувати
    713          //        type_error_of_exchanging_via_i2c = 0;
    714          //      }
    715          //      else if (rez == 0)
    716          //      {
    717          //        _SET_BIT(clear_diagnostyka, ERROR_START_VIA_I2C_BIT);
    718          //
    719          //        //При успішнопу запуску читання скидаємо біт запуску читання і виставляємо біт процесу читання
    720          //        _SET_BIT(control_i2c_taskes, TASK_READING_TRG_FUNC_EEPROM_BIT);
    721          //        _SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);        
    722          //        _CLEAR_BIT(control_i2c_taskes, TASK_START_READ_TRG_FUNC_EEPROM_BIT);
    723          //      }
    724          //    }
    725              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_START_READ_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT) !=0)
    726              {
    727                unsigned int rez;
    728          
    729                //Запускаємо процес читання
    730                rez = start_read_buffer_via_I2C(EEPROM_ADDRESS, START_ADDRESS_INFO_REJESTRATORS_PR_ERR, read_write_i2c_buffer, (sizeof(info_rejestrator_pr_err) + 1));
    731                
    732                //Аналізуємо успішність запуску нового запису
    733                if (rez > 1)
    734                {
    735                  error_start_i2c();
    736                  
    737                  //Покищо просто очищаємо змінну, яка конкретизуєм помилку, у майбутньому її можна буде конкретизувати
    738                  type_error_of_exchanging_via_i2c = 0;
    739                }
    740                else if (rez == 0)
    741                {
    742                  _SET_BIT(clear_diagnostyka, ERROR_START_VIA_I2C_BIT);
    743          
    744                  //При успішнопу запуску читання скидаємо біт запуску читання і виставляємо біт процесу читання
    745                  _SET_BIT(control_i2c_taskes, TASK_READING_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT);
    746                  _SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);        
    747                  _CLEAR_BIT(control_i2c_taskes, TASK_START_READ_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT);
    748                }
    749              }
    750              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_START_WRITE_CONFIG_EEPROM_BIT) !=0)
    751              {
    752                //Стоїть умова початку нового запису у EEPROM конфігурації пристрою
    753                
    754                //Скидаємо біт запуску нового запису і виставляємо біт запису блоків у EEPROM з блокуванням, щоб запуск почався з синхронізацією
    755                _SET_BIT(control_i2c_taskes, TASK_WRITING_CONFIG_EEPROM_BIT);
    756                _SET_BIT(control_i2c_taskes, TASK_BLK_WRITING_EEPROM_BIT);
    757                _CLEAR_BIT(control_i2c_taskes, TASK_START_WRITE_CONFIG_EEPROM_BIT);
    758                
    759                //Робимо копію записуваної інформації для контролю
    760          
    761                //Готуємо буфер для запису настройок (зкопійоманих) у EEPROM разом з контрольною сумою
    762                unsigned char crc_eeprom_config = 0, temp_value;
    763                unsigned char  *point_1 = (unsigned char*)(&current_config); 
    764                unsigned char  *point_2 = (unsigned char*)(&current_config_comp); 
    765                for (unsigned int i = 0; i < sizeof(__CONFIG); i++)
    766                {
    767                  temp_value = *(point_1);
    768                  *(point_2) = temp_value;
    769                  point_1++;
    770                  point_2++;
    771                  read_write_i2c_buffer[i] = temp_value;
    772                  crc_eeprom_config += temp_value;
    773                }
    774                //Добавляємо інвертовану контрольну суму у кінець масиву
    775                read_write_i2c_buffer[sizeof(__CONFIG)] = (unsigned char)((~(unsigned int)crc_eeprom_config) & 0xff);
    776                
    777                //Виставляємо перший блок конфігурації запису у EEPROM
    778                number_block_config_write_to_eeprom = 0;
    779              }
    780              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_START_WRITE_SETTINGS_EEPROM_BIT) !=0)
    781              {
    782                //Стоїть умова початку запису нової порції інформації по налаштуваннях у EEPROM
    783                static enum _id_fb block;
    784                static unsigned int shift;
    785                static uint8_t crc_eeprom_settings;
    786          
    787                if (
    788                    (shift_from_start_address_settings_in_eeprom == 0) &&
    789                    (size_settings == 0)  
    790                   )   
    791                {
    792                  block = _ID_FB_FIRST_ALL;
    793                  shift = 0;
    794                  crc_eeprom_settings = 0;
    795                }
    796                
    797                //Робимо копію записуваної інформації для контролю
    798          
    799                //Готуємо буфер для запису настройок (зкопійоманих) у EEPROM разом з контрольною сумою
    800                uint8_t temp_value;
    801                uint8_t *point_1, *point_2; 
    802                size_t size_of_block = 0;
    803                
    804                size_t index = 0;
    805                while(
    806                      (index < SIZE_BUFFER_FOR_EEPROM_EXCHNGE) &&
    807                      (block < _ID_FB_LAST_ALL)
    808                     )
    809                {
    810                  if (size_of_block == 0)
    811                  {
    812                    //Визначаємо розмір нового блоку
    813                    switch (block)
    814                    {
    815                    case ID_FB_CONTROL_BLOCK:
    816                      {
    817                        size_of_block = sizeof(__SETTINGS_FIX);
    818                        break;
    819                      }
    820                    case ID_FB_INPUT:
    821                      {
    822                        size_of_block = current_config.n_input*sizeof(__settings_for_INPUT);
    823                        break;
    824                      }
    825                    case ID_FB_OUTPUT:
    826                      {
    827                        size_of_block = current_config.n_output*sizeof(__settings_for_OUTPUT);
    828                        break;
    829                      }
    830                    case ID_FB_LED:
    831                      {
    832                        size_of_block = current_config.n_led*sizeof(__settings_for_LED);
    833                        break;
    834                      }
    835                    case ID_FB_ALARM:
    836                      {
    837                        size_of_block = current_config.n_alarm*sizeof(__settings_for_ALARM);
    838                        break;
    839                      }
    840                    case ID_FB_GROUP_ALARM:
    841                      {
    842                        size_of_block = current_config.n_group_alarm*sizeof(__settings_for_GROUP_ALARM);
    843                        break;
    844                      }
    845                    case ID_FB_AND:
    846                      {
    847                        size_of_block = current_config.n_and*sizeof(__settings_for_AND);
    848                        break;
    849                      }
    850                    case ID_FB_OR:
    851                      {
    852                        size_of_block = current_config.n_or*sizeof(__settings_for_OR);
    853                        break;
    854                      }
    855                    case ID_FB_XOR:
    856                      {
    857                        size_of_block = current_config.n_xor*sizeof(__settings_for_XOR);
    858                        break;
    859                      }
    860                    case ID_FB_NOT:
    861                      {
    862                        size_of_block = current_config.n_not*sizeof(__settings_for_NOT);
    863                        break;
    864                      }
    865                    case ID_FB_TIMER:
    866                      {
    867                        size_of_block = current_config.n_timer*sizeof(__settings_for_TIMER);
    868                        break;
    869                      }
    870                    case ID_FB_TRIGGER:
    871                      {
    872                        size_of_block = current_config.n_trigger*sizeof(__settings_for_TRIGGER);
    873                        break;
    874                      }
    875                    case ID_FB_MEANDER:
    876                      {
    877                        size_of_block = current_config.n_meander*sizeof(__settings_for_MEANDER);
    878                        break;
    879                      }
    880                    default:
    881                      {
    882                        //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
    883                        total_error_sw_fixed(51);
    884                      }
    885                    }
    886          
    887                    //Визначаємо вказівник на початок блоку
    888                    if (size_of_block != 0)
    889                    {
    890                      if (block == ID_FB_CONTROL_BLOCK)
    891                      {
    892                        point_1 = (uint8_t *)(&settings_fix);
    893                        point_2 = (uint8_t *)(&settings_fix_edit);
    894                      }
    895                      else
    896                      {
    897                        point_1 = (uint8_t *)(sca_of_p     [block - _ID_FB_FIRST_VAR]);
    898                        point_2 = (uint8_t *)(sca_of_p_edit[block - _ID_FB_FIRST_VAR]);
    899                      }
    900                    }
    901                  }
    902                
    903                  if (size_of_block != 0)
    904                  {
    905                    temp_value = *(point_1 + shift);
    906                    *(point_2 + shift) = temp_value;
    907                    read_write_i2c_buffer[index++] = temp_value;
    908                    crc_eeprom_settings += temp_value;
    909                    
    910                    if ((++shift) >= size_of_block)
    911                    {
    912                      shift = 0;
    913                      block++;
    914                      size_of_block = 0;
    915                    }
    916                  }
    917                  else 
    918                  {
    919                    shift = 0;
    920                    block++;
    921                  }
    922                }
    923                
    924                if (
    925                    (index < SIZE_BUFFER_FOR_EEPROM_EXCHNGE) &&
    926                    (block == _ID_FB_LAST_ALL)
    927                   )   
    928                {
    929                  //Додаємо ще контрольу суму
    930                  read_write_i2c_buffer[index++] = (uint8_t)((~(unsigned int)crc_eeprom_settings) & 0xff);
    931                  block++; /*це робимо для того, щоб коли наступний раз попадемо у цю частину програми, то не додавти контрольну суму, а скинути всі статичні змінні і завршити процедузу запису*/
    932          
    933                }
    934          
    935                //Виставляємо перший блок настройок запису у EEPROM
    936                number_block_settings_write_to_eeprom = 0;
    937                
    938                if (index == 0)
    939                {
    940                  //Весь масив настройок вже записаний
    941                  
    942                  //Скидаємо всі статичні змінні, які використовуютья при записі налаштувань
    943                  block = _ID_FB_FIRST_ALL;
    944                  shift = 0;
    945                  crc_eeprom_settings = 0;
    946                  
    947                  shift_from_start_address_settings_in_eeprom = 0;
    948                  size_settings = 0;
    949          
    950                  //Виставляємо команду контрольного читання для перевідрки достовірності записаної інформації
    951                  comparison_writing |= COMPARISON_WRITING_SETTINGS;
    952                  _SET_BIT(control_i2c_taskes, TASK_START_READ_SETTINGS_EEPROM_BIT);
    953                  _SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);        
    954          
    955                  //Скидаємо біт команди запису налаштувань
    956                  _CLEAR_BIT(control_i2c_taskes, TASK_START_WRITE_SETTINGS_EEPROM_BIT);
    957                }
    958                else
    959                {
    960                  //Виставляємо біт запису блоків у EEPROM з блокуванням (щоб запуск почався з синхронізацією) тільки утому випадку, якщо є підготовлені дані до запису
    961                  _SET_BIT(control_i2c_taskes, TASK_WRITING_SETTINGS_EEPROM_BIT);
    962                  _SET_BIT(control_i2c_taskes, TASK_BLK_WRITING_EEPROM_BIT);
    963                
    964                  //Фіксуємо з якого зміщення треба продовжити писати
    965                  shift_from_start_address_settings_in_eeprom += size_settings;
    966                  
    967                  //Виставляємо скільки байт підготовлено до запису
    968                  size_settings = index;
    969                }
    970              }
    971              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_START_WRITE_USTUVANNJA_EEPROM_BIT) !=0)
    972              {
    973                //Стоїть умова початку нового запису у EEPROM юстування
    974                
    975                //Скидаємо біт запуску нового запису і виставляємо біт запису блоків у EEPROM з блокуванням, щоб запуск почався з синхронізацією
    976                _SET_BIT(control_i2c_taskes, TASK_WRITING_USTUVANNJA_EEPROM_BIT);
    977                _SET_BIT(control_i2c_taskes, TASK_BLK_WRITING_EEPROM_BIT);
    978                _CLEAR_BIT(control_i2c_taskes, TASK_START_WRITE_USTUVANNJA_EEPROM_BIT);
    979          
    980                //Робимо копію записуваної інформації для контролю
    981                
    982                //Готуємо буфер для запису настройок у EEPROM разом з контрольноюсумою
    983                unsigned char crc_eeprom_ustuvannja = 0, temp_value;
    984                unsigned char  *point_1; 
    985                unsigned char  *point_2;
    986                unsigned int offset = 0;
    987          
    988                //Додаємо ідентифікатор типу нобору юстуючих коефіцієнтів
    989                unsigned int adjustment_id_tmp = ADJUSTMENT_ID;
    990                point_1 = (unsigned char*)(&adjustment_id_tmp); 
    991                for (unsigned int i = 0; i < sizeof(unsigned int); i++)
    992                {
    993                  temp_value = *(point_1++);
    994                  read_write_i2c_buffer[offset + i] = temp_value;
    995                  crc_eeprom_ustuvannja += temp_value;
    996                }
    997                offset += sizeof(unsigned int);
    998                
    999                //Додаємо юстуючі коефіцієнти
   1000                point_1 = (unsigned char*)(&ustuvannja); 
   1001                point_2 = (unsigned char*)(&ustuvannja_comp);
   1002                for (unsigned int i =0; i < sizeof(ustuvannja); i++)
   1003                {
   1004                  temp_value = *(point_1);
   1005                  *(point_2) = temp_value;
   1006                  point_1++;
   1007                  point_2++;
   1008                  read_write_i2c_buffer[offset + i] = temp_value;
   1009                  crc_eeprom_ustuvannja += temp_value;
   1010                }
   1011                offset += sizeof(ustuvannja);
   1012          
   1013                //Додаємо ще серійний номер пристрою
   1014                point_1 = (unsigned char*)(&serial_number_dev); 
   1015                point_2 = (unsigned char*)(&serial_number_dev_comp); 
   1016                for (unsigned int i = 0; i < sizeof(serial_number_dev); i++)
   1017                {
   1018                  temp_value = *(point_1);
   1019                  *(point_2) = temp_value;
   1020                  point_1++;
   1021                  point_2++;
   1022                  read_write_i2c_buffer[offset + i] = temp_value;
   1023                  crc_eeprom_ustuvannja += temp_value;
   1024                }
   1025                offset += sizeof(serial_number_dev);
   1026                
   1027                //Добавляємо інвертовану контрольну суму у кінець масиву
   1028                read_write_i2c_buffer[offset] = (unsigned char)((~(unsigned int)crc_eeprom_ustuvannja) & 0xff);
   1029                
   1030                //Виставляємо перший блок юстування запису у EEPROM
   1031                number_block_ustuvannja_write_to_eeprom = 0;
   1032              }
   1033          //    else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_START_WRITE_TRG_FUNC_EEPROM_BIT) !=0)
   1034          //    {
   1035          //      //Стоїть умова початку нового запису у EEPROM по триґерній інформації
   1036          //      
   1037          //      //Скидаємо біт запуску нового запису і виставляємо біт запису блоків у EEPROM з блокуванням, щоб запуск почався з синхронізацією
   1038          //      _SET_BIT(control_i2c_taskes, TASK_WRITING_TRG_FUNC_EEPROM_BIT);
   1039          //      _SET_BIT(control_i2c_taskes, TASK_BLK_WRITING_EEPROM_BIT);
   1040          //      _CLEAR_BIT(control_i2c_taskes, TASK_START_WRITE_TRG_FUNC_EEPROM_BIT);
   1041          //      
   1042          //      //Робимо копію записуваної інформації для контролю
   1043          //
   1044          //      //Готуємо буфер для запису настройок у EEPROM разом з контрольноюсумою
   1045          //      unsigned char crc_eeprom_trg_func = 0, temp_value;
   1046          //      unsigned char  *point_1; 
   1047          //      unsigned char  *point_2;
   1048          //      unsigned int offset = 0;
   1049          //
   1050          //      //Додаємо триґерні функції
   1051          //      point_1 = (unsigned char*)(&trigger_active_functions); 
   1052          //      point_2 = (unsigned char*)(&trigger_active_functions_comp);
   1053          //      for (unsigned int i =0; i < sizeof(trigger_active_functions); i++)
   1054          //      {
   1055          //        temp_value = *(point_1);
   1056          //        *(point_2) = temp_value;
   1057          //        point_1++;
   1058          //        point_2++;
   1059          //        read_write_i2c_buffer[offset + i] = temp_value;
   1060          //        crc_eeprom_trg_func += temp_value;
   1061          //      }
   1062          //      offset += sizeof(trigger_active_functions);
   1063          //
   1064          //      //Добавляємо інвертовану контрольну суму у кінець масиву
   1065          //      read_write_i2c_buffer[offset] = (unsigned char)((~(unsigned int)crc_eeprom_trg_func) & 0xff);
   1066          //      
   1067          //      //Виставляємо перший блок запису у EEPROM
   1068          //      number_block_trg_func_write_to_eeprom = 0;
   1069          //    }
   1070              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_START_WRITE_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT) !=0)
   1071              {
   1072                //Стоїть умова початку нового запису у EEPROM по інформації реєстратора програмних подій
   1073                
   1074                //Скидаємо біт запуску нового запису і виставляємо біт запису блоків у EEPROM з блокуванням, щоб запуск почався з синхронізацією
   1075                _SET_BIT(control_i2c_taskes, TASK_WRITING_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT);
   1076                _SET_BIT(control_i2c_taskes, TASK_BLK_WRITING_EEPROM_BIT);
   1077                _CLEAR_BIT(control_i2c_taskes, TASK_START_WRITE_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT);
   1078                
   1079                //Робимо копію записуваної інформації для контролю
   1080          
   1081                //Готуємо буфер для запису у EEPROM разом з контрольною сумою
   1082                unsigned char crc_eeprom_info_rejestrator_pr_err = 0, temp_value;
   1083                unsigned char  *point_1 = (unsigned char*)(&info_rejestrator_pr_err); 
   1084                unsigned char  *point_2 = (unsigned char*)(&info_rejestrator_pr_err_comp); 
   1085                for (unsigned int i = 0; i < sizeof(__INFO_REJESTRATOR); i++)
   1086                {
   1087                  temp_value = *(point_1);
   1088                  *(point_2) = temp_value;
   1089                  point_1++;
   1090                  point_2++;
   1091                  read_write_i2c_buffer[i] = temp_value;
   1092                  crc_eeprom_info_rejestrator_pr_err += temp_value;
   1093                }
   1094          
   1095                //Добавляємо інвертовану контрольну суму у кінець масиву
   1096                read_write_i2c_buffer[sizeof(info_rejestrator_pr_err)] = (unsigned char)((~(unsigned int)crc_eeprom_info_rejestrator_pr_err) & 0xff);
   1097                
   1098                //Виставляємо перший блок запису у EEPROM
   1099                number_block_info_rejestrator_pr_err_write_to_eeprom = 0;
   1100              }
   1101              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_START_READ_RTC_BIT) !=0)
   1102              {
   1103                unsigned int rez;
   1104          
   1105                //Запускаємо процес читання RTC
   1106                rez = start_read_buffer_via_I2C(RTC_ADDRESS, START_ADDRESS_TIME_REGISTERS, read_write_i2c_buffer, MAX_NUMBER_REGISTERS_RTC);
   1107                
   1108                //Аналізуємо успішність запуску нового запису
   1109                if (rez > 1)
   1110                {
   1111                  error_start_i2c();
   1112                  
   1113                  //Покищо просто очищаємо змінну, яка конкретизуєм помилку, у майбутньому її можна буде конкретизувати
   1114                  type_error_of_exchanging_via_i2c = 0;
   1115                }
   1116                else if (rez == 0)
   1117                {
   1118                  _SET_BIT(clear_diagnostyka, ERROR_START_VIA_I2C_BIT);
   1119          
   1120                  //При успішнопу запуску читання скидаємо біт запуску читання RTC і виставляємо біт процесу читання RTC
   1121                  _SET_BIT(control_i2c_taskes, TASK_READING_RTC_BIT);
   1122                  _CLEAR_BIT(control_i2c_taskes, TASK_START_READ_RTC_BIT);
   1123                }
   1124              }
   1125              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_START_WRITE_RTC_BIT) !=0)
   1126              {
   1127                unsigned int rez;
   1128          
   1129                copying_time = 1; //Помічаємо, що зараз  ще також обновляємо масив часу
   1130                //Запускаємо процес запису часу в RTC
   1131                read_write_i2c_buffer[0] = time[0] = 0;
   1132                read_write_i2c_buffer[1] = time[1] = time_edit[1] & 0x7F;
   1133                read_write_i2c_buffer[2] = time[2] = time_edit[2] & 0x7F;
   1134                read_write_i2c_buffer[3] = time[3] = time_edit[3] & 0x3F;
   1135                read_write_i2c_buffer[4] = 7;
   1136                read_write_i2c_buffer[5] = time[4] = time_edit[4] & 0x3F;
   1137                read_write_i2c_buffer[6] = time[5] = time_edit[5] & 0x1F;
   1138                read_write_i2c_buffer[7] = time[6] = time_edit[6] & 0xFF;
   1139                
   1140                calibration = calibration_edit & 0x3f;
   1141                read_write_i2c_buffer[8] = calibration | (copy_register8_RTC & 0xC0);
   1142          
   1143                copying_time = 0; //Помічаємо, що обновлення масив часу завершене
   1144                //Робимо копію масиву часу для того, щоб коли основний масив буде обновлятися можна було іншим модулям взяти попереднє, але достовірне значення часу і дати з цього масиву
   1145                for(unsigned int i = 0; i < 7; i++) time_copy[i] = time[i];
   1146                calibration_copy = calibration;
   1147                
   1148                rez = start_write_buffer_via_I2C(RTC_ADDRESS, START_ADDRESS_TIME_REGISTERS, read_write_i2c_buffer, 9);
   1149                
   1150                //Аналізуємо успішність запуску нового запису
   1151                if (rez > 1)
   1152                {
   1153                  error_start_i2c();
   1154                  
   1155                  //Покищо просто очищаємо змінну, яка конкретизуєм помилку, у майбутньому її можна буде конкретизувати
   1156                  type_error_of_exchanging_via_i2c = 0;
   1157                }
   1158                else if (rez == 0)
   1159                {
   1160                  _SET_BIT(clear_diagnostyka, ERROR_START_VIA_I2C_BIT);
   1161          
   1162                  //При успішнопу запуску читання скидаємо біт запуску читання RTC і виставляємо біт процесу читання RTC
   1163                  _SET_BIT(control_i2c_taskes, TASK_WRITING_RTC_BIT);
   1164                  _CLEAR_BIT(control_i2c_taskes, TASK_START_WRITE_RTC_BIT);
   1165                }
   1166              }
   1167              
   1168              /*************************************************/
   1169            }
   1170            else if (driver_i2c.state_execution == 1)
   1171            {
   1172              /*************************************************/
   1173              //Обмін завершився без помилок
   1174              /*************************************************/
   1175              //Виставляємо повідомлення, що I2C готовий до нової транзакції 
   1176              driver_i2c.state_execution = -1;
   1177          
   1178              if (
   1179                  (_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_CONFIG_EEPROM_BIT                 ) != 0) || 
   1180                  (_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_SETTINGS_EEPROM_BIT               ) != 0) || 
   1181                  (_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_USTUVANNJA_EEPROM_BIT             ) != 0) ||
   1182          //        (_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_TRG_FUNC_EEPROM_BIT               ) != 0) ||
   1183                  (_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT) != 0)
   1184                 )
   1185              {
   1186                //Стоїть умова запису блоку у EEPROM
   1187          
   1188                if(_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_CONFIG_EEPROM_BIT) !=0)
   1189                {
   1190                  //Виставляємо наступний блок конфігурації запису у EEPROM
   1191                  number_block_config_write_to_eeprom++;
   1192                }
   1193                else if(_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_SETTINGS_EEPROM_BIT) !=0)
   1194                {
   1195                  //Виставляємо наступний блок настройок запису у EEPROM
   1196                  number_block_settings_write_to_eeprom++;
   1197                }
   1198                else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_USTUVANNJA_EEPROM_BIT) !=0)
   1199                {
   1200                  //Виставляємо наступний блок юстування запису у EEPROM
   1201                  number_block_ustuvannja_write_to_eeprom++;
   1202                }
   1203          //      else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_TRG_FUNC_EEPROM_BIT) != 0)
   1204          //      {
   1205          //        //Виставляємо наступний блок триґерної інформаціїзапису у EEPROM
   1206          //        number_block_trg_func_write_to_eeprom++;
   1207          //      }
   1208                else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT) != 0)
   1209                {
   1210                  //Виставляємо наступний блок інформації по реєстраторах запису у EEPROM
   1211                  number_block_info_rejestrator_pr_err_write_to_eeprom++;
   1212                }
   1213                else
   1214                {
   1215                  //Відбулася невизначена помилка, тому треба піти на перезавантаження
   1216                  total_error_sw_fixed(25);
   1217                }
   1218          
   1219                //Виставляємо біт тимчасового блокування запису, щоб витримати певну павзу і запустити запис після більш пріоритетних завдвнь  
   1220                //Згідно документації операція запису відбувається до 5 мс
   1221                _SET_BIT(control_i2c_taskes, TASK_BLK_WRITING_EEPROM_BIT);
   1222              }
   1223              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_READING_CONFIG_EEPROM_BIT) !=0)
   1224              {
   1225                //Аналізуємо прочитані дані
   1226                //Спочатку аналізуємо, чи прийнятий блок є пустим, чи вже попередньо записаним
   1227                unsigned int empty_block = 1, i = 0; 
   1228                __CONFIG current_config_tmp;
   1229                
   1230                while ((empty_block != 0) && ( i < (sizeof(__CONFIG) + 1)))
   1231                {
   1232                  if (read_write_i2c_buffer[i] != 0xff) empty_block = 0;
   1233                  i++;
   1234                }
   1235                
   1236                if(empty_block == 0)
   1237                {
   1238                  //Помічаємо, що блок конфігурації не є пустим
   1239                  state_i2c_task &= (unsigned int)(~STATE_CONFIG_EEPROM_EMPTY);
   1240                  //Скидаємо повідомлення у слові діагностики
   1241                  _SET_BIT(clear_diagnostyka, ERROR_CONFIG_EEPROM_EMPTY_BIT);
   1242                  
   1243                  //Перевіряємо контрольну суму і переписуємо прочитані дані у структуру управління
   1244                  unsigned char crc_eeprom_config = 0, temp_value;
   1245                  unsigned char  *point = (unsigned char*)(&current_config_tmp); 
   1246                  for (i = 0; i < sizeof(__CONFIG); i++)
   1247                  {
   1248                    temp_value = read_write_i2c_buffer[i];
   1249                    *(point) = temp_value;
   1250                    crc_eeprom_config += temp_value;
   1251                    point++;
   1252                  }
   1253                  if (read_write_i2c_buffer[sizeof(__CONFIG)]  == ((unsigned char)((~(unsigned int)crc_eeprom_config) & 0xff)))
   1254                  {
   1255                    //Контролдьна сума сходиться
   1256          
   1257                    //Скидаємо повідомлення у слові діагностики
   1258                    _SET_BIT(clear_diagnostyka, ERROR_CONFIG_EEPROM_BIT);
   1259          
   1260                    if (current_config_tmp.device_id == VERSIA_PZ)
   1261                    {
   1262                      //Таблиця конфігурації відповідає типу даного приладу
   1263                      state_i2c_task &= (unsigned int)(~STATE_CONFIG_EEPROM_FAIL);
   1264                      state_i2c_task |= STATE_CONFIG_EEPROM_GOOD;
   1265                    
   1266                      //Скидаємо повідомлення у слові діагностики
   1267                      _SET_BIT(clear_diagnostyka, ERROR_CONFIG_EEPROM_DEVICE_ID_FAIL_BIT);
   1268                      
   1269                      //Зберігаємо контрольну суму (не інвертовану)
   1270                      crc_config = crc_eeprom_config;
   1271          
   1272                      if ((comparison_writing & COMPARISON_WRITING_CONFIG) == 0)
   1273                      {
   1274                        //Виконувалося зчитування конфігурації у таблицю конфігурації
   1275                      
   1276                        /*
   1277                        Забороняємо генерацію переривань, під час обновлення конфігурації для структури з якою працюють захисти
   1278                        */
   1279                        //Єдине поле, яке не змінюється з функції allocate_dynamic_memory_for_settings
   1280                        current_config_prt.device_id = current_config.device_id = current_config_edit.device_id = current_config_tmp.device_id;
   1281                        __disable_interrupt();
   1282          
   1283                        __result_dym_mem_select result = allocate_dynamic_memory_for_settings(MAKE_DYN_MEM, true, spca_of_p_prt, NULL, &current_config_prt, &current_config_tmp, NULL);
   1284                        
   1285                        /*
   1286                        Дозволяємо генерацію переривань
   1287                        */
   1288                        __enable_interrupt();
   1289                        
   1290                        //Робимо зміни у динамічній пам'яті для налаштувань
   1291                        if (result == DYN_MEM_SELECT_OK) result = allocate_dynamic_memory_for_settings(MAKE_DYN_MEM, false, sca_of_p     , spca_of_p_prt, &current_config     , &current_config_tmp, &current_config_prt);
   1292                        if (result == DYN_MEM_SELECT_OK) result = allocate_dynamic_memory_for_settings(MAKE_DYN_MEM, false, sca_of_p_edit, sca_of_p     , &current_config_edit, &current_config_tmp, &current_config    );
   1293                        for (size_t t = 0; t < (7 + 1); t++) current_config_edit.time_config[t] = current_config.time_config[t] = current_config_prt.time_config[t] = current_config_tmp.time_config[t];
   1294                        
   1295                        if (result == DYN_MEM_SELECT_OK) 
   1296                        {
   1297                          state_i2c_task &= (unsigned int)(~STATE_CONFIG_EEPROM_NO_FREE_MEMORY);
   1298          
   1299                          //Скидаємо повідомлення у слові діагностики
   1300                          _SET_BIT(clear_diagnostyka, ERROR_NO_FREE_DYNAMIC_MEMORY_BIT);
   1301                        }
   1302                        else
   1303                        {
   1304                          state_i2c_task &= (unsigned int)(~STATE_CONFIG_EEPROM_GOOD);
   1305                          state_i2c_task |= STATE_CONFIG_EEPROM_NO_FREE_MEMORY;
   1306          
   1307                          //Виствляємо повідомлення у слові діагностики
   1308                          _SET_BIT(set_diagnostyka, ERROR_NO_FREE_DYNAMIC_MEMORY_BIT);
   1309                          
   1310                          //Звільняємо всю пам'ять
   1311                          for (enum _id_fb index_1 = _ID_FB_FIRST_VAR; index_1 < _ID_FB_LAST_VAR; index_1++)
   1312                          {
   1313                            free(sca_of_p_edit[index_1 - _ID_FB_FIRST_VAR]);
   1314                            free(sca_of_p[index_1 - _ID_FB_FIRST_VAR]);
   1315                            free(spca_of_p_prt[index_1 - _ID_FB_FIRST_VAR]);
   1316                          }
   1317                        }
   1318                      }
   1319                      else
   1320                      {
   1321                        //Виконувалося контроль достовірності записаної інформації у EEPROM з записуваною
   1322                      
   1323                        unsigned char  *point_to_read  = (unsigned char*)(&current_config_tmp );
   1324                        unsigned char  *point_to_write = (unsigned char*)(&current_config_comp);
   1325                        unsigned int difference = 0;
   1326          
   1327                        i = 0;
   1328                        while ((difference == 0) && ( i < sizeof(__CONFIG)))
   1329                        {
   1330                          if (*point_to_write != *point_to_read) difference = 0xff;
   1331                          else
   1332                          {
   1333                            point_to_write++;
   1334                            point_to_read++;
   1335                            i++;
   1336                          }
   1337                        }
   1338                        if (difference == 0)
   1339                        {
   1340                          //Контроль порівнняння пройшов успішно
   1341          
   1342                          //Скидаємо повідомлення у слові діагностики
   1343                          _SET_BIT(clear_diagnostyka, ERROR_CONFIG_EEPROM_COMPARISON_BIT);
   1344                        }
   1345                        else
   1346                        {
   1347                          //Контроль порівнняння зафіксував розбіжності між записаною і записуваною інформацією
   1348          
   1349                          //Виствляємо повідомлення у слові діагностики
   1350                          _SET_BIT(set_diagnostyka, ERROR_CONFIG_EEPROM_COMPARISON_BIT);
   1351                        }
   1352                      }
   1353                    }
   1354                    else
   1355                    {
   1356                      //Таблиця конфігурації не відповідає типу даного приладу
   1357          
   1358                      //Помічаємо, що прочитаний блок конфігурації є пустим
   1359                      state_i2c_task &= (unsigned int)(~STATE_CONFIG_EEPROM_FAIL);
   1360                      state_i2c_task &= (unsigned int)(~STATE_CONFIG_EEPROM_GOOD);
   1361                      state_i2c_task |= STATE_CONFIG_EEPROM_EMPTY; /*Не відповідність типу настройок це то саме що їх немає взагалі*/
   1362                  
   1363                      //Виствляємо повідомлення у слові діагностики
   1364                      _SET_BIT(set_diagnostyka, ERROR_CONFIG_EEPROM_DEVICE_ID_FAIL_BIT);
   1365                    }
   1366                  }
   1367                  else
   1368                  {
   1369                    //Контрольна сума не сходиться
   1370                    state_i2c_task &= (unsigned int)(~STATE_CONFIG_EEPROM_GOOD);
   1371                    state_i2c_task |= STATE_CONFIG_EEPROM_FAIL;
   1372                    
   1373                    //Виствляємо повідомлення у слові діагностики
   1374                    _SET_BIT(clear_diagnostyka, ERROR_CONFIG_EEPROM_DEVICE_ID_FAIL_BIT);
   1375                    _SET_BIT(set_diagnostyka, ERROR_CONFIG_EEPROM_BIT);
   1376                  }
   1377                }
   1378                else
   1379                {
   1380                  //Помічаємо, що прочитаний блок конфігурації є пустим
   1381                  state_i2c_task &= (unsigned int)(~STATE_CONFIG_EEPROM_FAIL);
   1382                  state_i2c_task &= (unsigned int)(~STATE_CONFIG_EEPROM_GOOD);
   1383                  state_i2c_task |= STATE_CONFIG_EEPROM_EMPTY;
   1384                  
   1385                  //Виствляємо повідомлення у слові діагностики
   1386                  _SET_BIT(clear_diagnostyka, ERROR_CONFIG_EEPROM_BIT);
   1387                  _SET_BIT(clear_diagnostyka, ERROR_CONFIG_EEPROM_DEVICE_ID_FAIL_BIT);
   1388                  _SET_BIT(set_diagnostyka, ERROR_CONFIG_EEPROM_EMPTY_BIT);
   1389                }
   1390                      
   1391                //Знімаємо можливу сигналізацію, що виконувалося порівнняння
   1392                comparison_writing &= (unsigned int)(~COMPARISON_WRITING_CONFIG);
   1393                //Скидаємо повідомлення про читання даних
   1394                _CLEAR_BIT(control_i2c_taskes, TASK_READING_CONFIG_EEPROM_BIT);
   1395              }
   1396              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_READING_SETTINGS_EEPROM_BIT) !=0)
   1397              {
   1398                //Аналізуємо прочитані дані
   1399          
   1400                //Статична змінна, яка визначає блок для налаштувань є пустим
   1401                static unsigned int empty_block, difference;
   1402                static uint8_t crc_eeprom_settings;
   1403                if (shift_from_start_address_settings_in_eeprom == 0) 
   1404                {
   1405                  empty_block = true;
   1406                  difference = false;
   1407                  crc_eeprom_settings = 0;
   1408                }
   1409                
   1410                size_t new_shift = shift_from_start_address_settings_in_eeprom + size_settings;
   1411                size_settings = 0; /*Цим повідомляємо інші блоки, що читання успішно даного блоку відбувся*/
   1412          
   1413                //Спочатку аналізуємо скільки і який блок налаштування прочитано
   1414                enum _id_fb block = _ID_FB_FIRST_ALL;
   1415                unsigned int shift = 0;
   1416                
   1417                size_t size_of_block = 0;
   1418                size_t index = 0;
   1419                uint8_t *p;
   1420                while(
   1421                      (index < new_shift) &&
   1422                      (block < _ID_FB_LAST_ALL)
   1423                     )
   1424                {
   1425                  //Визначаємо розмір нового блоку
   1426                  if (size_of_block == 0)
   1427                  {
   1428                    switch (block)
   1429                    {
   1430                    case ID_FB_CONTROL_BLOCK:
   1431                      {
   1432                        size_of_block = sizeof(__SETTINGS_FIX);
   1433                        break;
   1434                      }
   1435                    case ID_FB_INPUT:
   1436                      {
   1437                        size_of_block = current_config.n_input*sizeof(__settings_for_INPUT);
   1438                        break;
   1439                      }
   1440                    case ID_FB_OUTPUT:
   1441                      {
   1442                        size_of_block = current_config.n_output*sizeof(__settings_for_OUTPUT);
   1443                        break;
   1444                      }
   1445                    case ID_FB_LED:
   1446                      {
   1447                        size_of_block = current_config.n_led*sizeof(__settings_for_LED);
   1448                        break;
   1449                      }
   1450                    case ID_FB_ALARM:
   1451                      {
   1452                        size_of_block = current_config.n_alarm*sizeof(__settings_for_ALARM);
   1453                        break;
   1454                      }
   1455                    case ID_FB_GROUP_ALARM:
   1456                      {
   1457                        size_of_block = current_config.n_group_alarm*sizeof(__settings_for_GROUP_ALARM);
   1458                        break;
   1459                      }
   1460                    case ID_FB_AND:
   1461                      {
   1462                        size_of_block = current_config.n_and*sizeof(__settings_for_AND);
   1463                        break;
   1464                      }
   1465                    case ID_FB_OR:
   1466                      {
   1467                        size_of_block = current_config.n_or*sizeof(__settings_for_OR);
   1468                        break;
   1469                      }
   1470                    case ID_FB_XOR:
   1471                      {
   1472                        size_of_block = current_config.n_xor*sizeof(__settings_for_XOR);
   1473                        break;
   1474                      }
   1475                    case ID_FB_NOT:
   1476                      {
   1477                        size_of_block = current_config.n_not*sizeof(__settings_for_NOT);
   1478                        break;
   1479                      }
   1480                    case ID_FB_TIMER:
   1481                      {
   1482                        size_of_block = current_config.n_timer*sizeof(__settings_for_TIMER);
   1483                        break;
   1484                      }
   1485                    case ID_FB_TRIGGER:
   1486                      {
   1487                        size_of_block = current_config.n_trigger*sizeof(__settings_for_TRIGGER);
   1488                        break;
   1489                      }
   1490                    case ID_FB_MEANDER:
   1491                      {
   1492                        size_of_block = current_config.n_meander*sizeof(__settings_for_MEANDER);
   1493                        break;
   1494                      }
   1495                    default:
   1496                      {
   1497                        //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
   1498                        total_error_sw_fixed(54);
   1499                      }
   1500                    }
   1501                    
   1502                    if (block == ID_FB_CONTROL_BLOCK) p = (uint8_t *)(&settings_fix_edit);
   1503                    else p = (uint8_t *)(sca_of_p_edit[block - _ID_FB_FIRST_VAR]);
   1504                  }
   1505          
   1506                  if (index < shift_from_start_address_settings_in_eeprom)
   1507                  {
   1508                    size_t index_tmp = index + size_of_block;
   1509                    if (index_tmp <= shift_from_start_address_settings_in_eeprom) 
   1510                    {
   1511                      block++;
   1512                      index = index_tmp;
   1513                      
   1514                      size_of_block = 0;
   1515                    }
   1516                    else
   1517                    {
   1518                      shift = shift_from_start_address_settings_in_eeprom - index;
   1519                      index = shift_from_start_address_settings_in_eeprom;
   1520                    }
   1521                  }
   1522                  else
   1523                  {
   1524                    if (size_of_block != 0)
   1525                    {
   1526                      intptr_t i = (index++) - shift_from_start_address_settings_in_eeprom;
   1527                      uint8_t temp_value = read_write_i2c_buffer[i];
   1528                      if (temp_value != 0xff) empty_block = 0;
   1529                      crc_eeprom_settings += temp_value;
   1530                      if (p != NULL) 
   1531                      {
   1532                        if ((comparison_writing & COMPARISON_WRITING_SETTINGS) == 0) 
   1533                        {
   1534                          //Виконувалося зчитування настройок у таблиці настройок
   1535                          *(p + shift) = temp_value;
   1536                        }
   1537                        else
   1538                        {
   1539                          //Відбувалося контрольне читання після запису
   1540                          if (*(p + shift) != temp_value) difference = true;
   1541                        }
   1542                      }
   1543                      else
   1544                      {
   1545                        //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
   1546                        total_error_sw_fixed(55);
   1547                      }
   1548                    
   1549                      if ((++shift) >= size_of_block)
   1550                      {
   1551                        shift = 0;
   1552                        block++;
   1553                        size_of_block = 0;
   1554                      }
   1555                    }
   1556                    else 
   1557                    {
   1558                      shift = 0;
   1559                      block++;
   1560                    }
   1561                  }
   1562                }
   1563                
   1564                if (
   1565                    (index < new_shift) &&
   1566                    (block == _ID_FB_LAST_ALL)
   1567                   )   
   1568                {
   1569                  uint8_t crc_eeprom_settings_remote = read_write_i2c_buffer[(index++) - shift_from_start_address_settings_in_eeprom];
   1570                  if (index == new_shift)
   1571                  {
   1572                    //Це нормальна ситуація коли вичитано останньоб контрольна сума і можна приступити до аналізу всіх прочитаних даних
   1573          
   1574                    if(empty_block == 0)
   1575                    {
   1576                      //Помічаємо, що блок настроювання не є пустим
   1577                      state_i2c_task &= (unsigned int)(~STATE_SETTINGS_EEPROM_EMPTY);
   1578                      //Скидаємо повідомлення у слові діагностики
   1579                      _SET_BIT(clear_diagnostyka, ERROR_SETTINGS_EEPROM_EMPTY_BIT);
   1580                  
   1581                      //Перевіряємо контрольну суму і переписуємо прочитані дані у структуру управління
   1582                      if (crc_eeprom_settings_remote  == ((uint8_t)((~(unsigned int)crc_eeprom_settings) & 0xff)))
   1583                      {
   1584                        //Контролдьна сума сходиться
   1585          
   1586                        //Скидаємо повідомлення у слові діагностики
   1587                        _SET_BIT(clear_diagnostyka, ERROR_SETTINGS_EEPROM_BIT);
   1588          
   1589                        //Зберігаємо контрольну суму (не інвертовану)
   1590                        crc_settings = crc_eeprom_settings;
   1591          
   1592                        if ((comparison_writing & COMPARISON_WRITING_SETTINGS) == 0)
   1593                        {
   1594                          //Виконувалося зчитування настройок у таблицю настройок
   1595                      
   1596                          /*
   1597                          Копіюємо у контейнер і структуру для захистів (prt) з структури у якії йшло зчитування з EEPROM
   1598                          */
   1599                          copy_settings(&current_config_edit, &settings_fix, &settings_fix_edit, sca_of_p, sca_of_p_edit);
   1600          
   1601                          __disable_interrupt();
   1602                          copy_settings(&current_config_edit, &settings_fix_prt, &settings_fix_edit, spca_of_p_prt, sca_of_p_edit);
   1603                          __enable_interrupt();
   1604                          /***/
   1605          
   1606                        }
   1607                        else
   1608                        {
   1609                          //Виконувалося контроль достовірності записаної інформації у EEPROM з записуваною
   1610                      
   1611                          if (difference == false)
   1612                          {
   1613                            //Контроль порівнняння пройшов успішно
   1614              
   1615                            //Скидаємо повідомлення у слові діагностики
   1616                            _SET_BIT(clear_diagnostyka, ERROR_SETTINGS_EEPROM_COMPARISON_BIT);
   1617                          }
   1618                          else
   1619                          {
   1620                            //Контроль порівнняння зафіксував розбіжності між записаною і записуваною інформацією
   1621          
   1622                            //Виствляємо повідомлення у слові діагностики
   1623                            _SET_BIT(set_diagnostyka, ERROR_SETTINGS_EEPROM_COMPARISON_BIT);
   1624                          }
   1625                        }
   1626          
   1627                        state_i2c_task &= (unsigned int)(~STATE_SETTINGS_EEPROM_FAIL);
   1628                        state_i2c_task |= STATE_SETTINGS_EEPROM_GOOD;
   1629                      }
   1630                      else
   1631                      {
   1632                        //Контрольна сума не сходиться
   1633                        /*
   1634                        Повертаємо у структури у які йшло зчитування з EEPROM (edit) з контейнера
   1635                        */
   1636                        copy_settings(&current_config, &settings_fix_edit, &settings_fix, sca_of_p_edit, sca_of_p);
   1637                        /***/
   1638          
   1639                        state_i2c_task &= (unsigned int)(~STATE_SETTINGS_EEPROM_GOOD);
   1640                        state_i2c_task |= STATE_SETTINGS_EEPROM_FAIL;
   1641                    
   1642                        //Виствляємо повідомлення у слові діагностики
   1643                        _SET_BIT(set_diagnostyka, ERROR_SETTINGS_EEPROM_BIT);
   1644                      }
   1645                    }
   1646                    else
   1647                    {
   1648                      //Зчитаний блок налаштувань виявився пустим
   1649                      /*
   1650                      Повертаємо у структури у які йшло зчитування з EEPROM (edit) з контейнера
   1651                      */
   1652                      copy_settings(&current_config, &settings_fix_edit, &settings_fix, sca_of_p_edit, sca_of_p);
   1653                      /***/
   1654                      
   1655                      //Помічаємо, що прочитаний блок настройок є пустим
   1656                      state_i2c_task &= (unsigned int)(~STATE_SETTINGS_EEPROM_FAIL);
   1657                      state_i2c_task &= (unsigned int)(~STATE_SETTINGS_EEPROM_GOOD);
   1658                      state_i2c_task |= STATE_SETTINGS_EEPROM_EMPTY;
   1659                  
   1660                      //Виствляємо повідомлення у слові діагностики
   1661                      _SET_BIT(clear_diagnostyka, ERROR_SETTINGS_EEPROM_BIT);
   1662                      _SET_BIT(set_diagnostyka, ERROR_SETTINGS_EEPROM_EMPTY_BIT);
   1663                    }
   1664                  }
   1665                  else
   1666                  {
   1667                    //Якщо сюди дійшла програма, значить відбулася недопустива помилка, тому треба зациклити програму, щоб вона пішла на перезагрузку
   1668                    total_error_sw_fixed(55);
   1669                  }
   1670                }
   1671                shift_from_start_address_settings_in_eeprom = new_shift; /*У статичній змінній визначаємо з якого зміщення треба буде продовжувати читати*/
   1672                
   1673                //Скидаємо повідомлення про читання даних
   1674                _CLEAR_BIT(control_i2c_taskes, TASK_READING_SETTINGS_EEPROM_BIT);
   1675              }
   1676              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_READING_USTUVANNJA_EEPROM_BIT) !=0)
   1677              {
   1678                //Аналізуємо прочитані дані
   1679                //Спочатку аналізуємо, чи прояитаний блок є пустим, чи вже попередньо записаним
   1680                unsigned int empty_block = 1, i = 0; 
   1681                unsigned int adjustment_id_tmp, ustuvannja_tmp[NUMBER_ANALOG_CANALES], serial_number_dev_tmp;
   1682          
   1683                while ((empty_block != 0) && ( i < (SIZE_USTUVANNJA + 1)))
   1684                {
   1685                  if (read_write_i2c_buffer[i] != 0xff) empty_block = 0;
   1686                  i++;
   1687                }
   1688                
   1689                if(empty_block == 0)
   1690                {
   1691                  //Помічаємо, що блок настроювання не є пустим
   1692                  state_i2c_task &= (unsigned int)(~STATE_USTUVANNJA_EEPROM_EMPTY);
   1693                  //Скидаємо повідомлення у слові діагностики
   1694                  _SET_BIT(clear_diagnostyka, ERROR_USTUVANNJA_EEPROM_EMPTY_BIT);
   1695                  
   1696                  //Перевіряємо контрольну суму і переписуємо прочитані дані у масив юстування з серійним номером
   1697                  unsigned char crc_eeprom_ustuvannja = 0, temp_value;
   1698                  unsigned char  *point;
   1699                  unsigned int offset = 0;
   1700          
   1701                  point = (unsigned char*)(&adjustment_id_tmp); 
   1702                  for (i =0; i < sizeof(unsigned int); i++)
   1703                  {
   1704                    temp_value = read_write_i2c_buffer[offset + i];
   1705                    *(point) = temp_value;
   1706                    crc_eeprom_ustuvannja += temp_value;
   1707                    point++;
   1708                  }
   1709                  offset += sizeof(unsigned int);
   1710                  
   1711                  point = (unsigned char*)(&ustuvannja_tmp); 
   1712                  for (i =0; i < sizeof(ustuvannja_tmp); i++)
   1713                  {
   1714                    temp_value = read_write_i2c_buffer[offset + i];
   1715                    *(point) = temp_value;
   1716                    crc_eeprom_ustuvannja += temp_value;
   1717                    point++;
   1718                  }
   1719                  offset +=  sizeof(ustuvannja_tmp);
   1720                  
   1721                  point = (unsigned char*)(&serial_number_dev_tmp); 
   1722                  for (i =0; i < sizeof(serial_number_dev_tmp); i++)
   1723                  {
   1724                    temp_value = read_write_i2c_buffer[offset + i];
   1725                    *(point) = temp_value;
   1726                    crc_eeprom_ustuvannja += temp_value;
   1727                    point++;
   1728                  }
   1729                  offset += sizeof(serial_number_dev_tmp);
   1730          
   1731                  if (read_write_i2c_buffer[offset]  == ((unsigned char)((~(unsigned int)crc_eeprom_ustuvannja) & 0xff)))
   1732                  {
   1733                    //Контролдьна сума сходиться
   1734          
   1735                    //Скидаємо повідомлення у слові діагностики
   1736                    _SET_BIT(clear_diagnostyka, ERROR_USTUVANNJA_EEPROM_BIT);
   1737                    
   1738                    if (adjustment_id_tmp == ADJUSTMENT_ID)
   1739                    {
   1740                      //Тип набору юстуючих коефіцієнтів відповідає даному програмному забезпеченню
   1741          
   1742                      //Зберігаємо контрольну суму (не інвертовану)
   1743                      crc_ustuvannja = crc_eeprom_ustuvannja;
   1744                    
   1745                      if ((comparison_writing & COMPARISON_WRITING_USTUVANNJA) == 0)
   1746                      {
   1747                        //Виконувалося зчитування юстування у масив юстування
   1748                      
   1749                        //Помічаємо, що юстування зараз буде змінюватися і їх треба буде з вимірювальної системи зкопіювати у таблицю з якою працює вимірювальна система
   1750                        changed_ustuvannja = CHANGED_ETAP_EXECUTION;
   1751                        //Перекидаємо масив юстування з тимчасового масиву у робочий масив
   1752                        for(unsigned int k = 0; k < NUMBER_ANALOG_CANALES; k++) 
   1753                        {
   1754                          ustuvannja[k] = ustuvannja_tmp[k];
   1755                        }
   1756                        serial_number_dev = serial_number_dev_tmp;
   1757                        //Помічаємо, що юстування змінилася і її треба буде з вимірювальної системи зкопіювати у масив з яким працює вимірювальна система
   1758                        changed_ustuvannja = CHANGED_ETAP_ENDED;
   1759                      }
   1760                      else
   1761                      {
   1762                        //Виконувалося контроль достовірності записаної інформації у EEPROM з записуваною
   1763                      
   1764                        unsigned int difference = 0;
   1765            
   1766                        i = 0;
   1767                        while ((difference == 0) && (i < NUMBER_ANALOG_CANALES))
   1768                        {
   1769                          //Перевірка запису юстуючих коефіцієнтів
   1770                          if (
   1771                              (ustuvannja_comp[i] != ustuvannja_tmp[i])
   1772                             )
   1773                          {
   1774                            difference = 0xff;
   1775                          }
   1776                          else
   1777                          {
   1778                            i++;
   1779                          }
   1780                        }
   1781                        if (difference == 0) 
   1782                        {
   1783                          //Перевірка запису серійного номеру (якщо до того не зафіксовано вже помилки)
   1784                          if (serial_number_dev_comp != serial_number_dev_tmp) difference = 0xff;
   1785                        }
   1786                      
   1787                        if (difference == 0)
   1788                        {
   1789                          //Контроль порівнняння пройшов успішно
   1790            
   1791                          //Скидаємо повідомлення у слові діагностики
   1792                          _SET_BIT(clear_diagnostyka, ERROR_USTUVANNJA_EEPROM_COMPARISON_BIT);
   1793                        }
   1794                        else
   1795                        {
   1796                          //Контроль порівнняння зафіксував розбіжності між записаною і записуваною інформацією
   1797          
   1798                          //Виствляємо повідомлення у слові діагностики
   1799                          _SET_BIT(set_diagnostyka, ERROR_USTUVANNJA_EEPROM_COMPARISON_BIT);
   1800                        }
   1801                      }
   1802          
   1803                      state_i2c_task &= (unsigned int)(~STATE_USTUVANNJA_EEPROM_FAIL);
   1804                      state_i2c_task |= STATE_USTUVANNJA_EEPROM_GOOD;
   1805                    
   1806                      //Скидаємо повідомлення у слові діагностики
   1807                      _SET_BIT(clear_diagnostyka, ERROR_USTUVANNJA_EEPROM_ADJUSTMENT_ID_FAIL_BIT);
   1808                    }
   1809                    else
   1810                    {
   1811                      //Тип набору юстуючих коефіцієнтів не відповідає даному програмному забезпеченню
   1812          
   1813                      //Помічаємо, що прочитаний блок юстування є пустим
   1814                      state_i2c_task &= (unsigned int)(~STATE_USTUVANNJA_EEPROM_FAIL);
   1815                      state_i2c_task &= (unsigned int)(~STATE_USTUVANNJA_EEPROM_GOOD);
   1816                      state_i2c_task |= STATE_USTUVANNJA_EEPROM_EMPTY;/*Не відповідність типу юстуючих коефіцієнтів -  це то саме що їх немає взагалі*/
   1817                  
   1818                      //Виствляємо повідомлення у слові діагностики
   1819                      _SET_BIT(set_diagnostyka, ERROR_USTUVANNJA_EEPROM_ADJUSTMENT_ID_FAIL_BIT);
   1820                    }
   1821                  }
   1822                  else
   1823                  {
   1824                    //Контрольна сума не сходиться
   1825                    state_i2c_task &= (unsigned int)(~STATE_USTUVANNJA_EEPROM_GOOD);
   1826                    state_i2c_task |= STATE_USTUVANNJA_EEPROM_FAIL;
   1827                    
   1828                    //Виствляємо повідомлення у слові діагностики
   1829                    _SET_BIT(clear_diagnostyka, ERROR_USTUVANNJA_EEPROM_ADJUSTMENT_ID_FAIL_BIT);
   1830                    _SET_BIT(set_diagnostyka, ERROR_USTUVANNJA_EEPROM_BIT);
   1831                  }
   1832                }
   1833                else
   1834                {
   1835                  //Помічаємо, що прочитаний блок юстування є пустим
   1836                  state_i2c_task &= (unsigned int)(~STATE_USTUVANNJA_EEPROM_FAIL);
   1837                  state_i2c_task &= (unsigned int)(~STATE_USTUVANNJA_EEPROM_GOOD);
   1838                  state_i2c_task |= STATE_USTUVANNJA_EEPROM_EMPTY;
   1839                  
   1840                  //Виствляємо повідомлення у слові діагностики
   1841                  _SET_BIT(clear_diagnostyka, ERROR_USTUVANNJA_EEPROM_BIT);
   1842                  _SET_BIT(clear_diagnostyka, ERROR_USTUVANNJA_EEPROM_ADJUSTMENT_ID_FAIL_BIT);
   1843                  _SET_BIT(set_diagnostyka, ERROR_USTUVANNJA_EEPROM_EMPTY_BIT);
   1844                }
   1845                      
   1846                //Знімаємо можливу сигналізацію, що виконувалося порівнняння
   1847                comparison_writing &= (unsigned int)(~COMPARISON_WRITING_USTUVANNJA);
   1848                //Скидаємо повідомлення про читання даних
   1849                _CLEAR_BIT(control_i2c_taskes, TASK_READING_USTUVANNJA_EEPROM_BIT);
   1850              }
   1851          //    else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_READING_TRG_FUNC_EEPROM_BIT) !=0)
   1852          //    {
   1853          //      //Аналізуємо прочитані дані
   1854          //      //Спочатку аналізуємо, чи прояитаний блок є пустим, чи вже попередньо записаним
   1855          //      unsigned int empty_block = 1, i = 0; 
   1856          //      unsigned int trigger_active_functions_tmp[N_BIG];
   1857          //
   1858          //      while ((empty_block != 0) && ( i < (1 + sizeof(trigger_active_functions_tmp) + 1)))
   1859          //      {
   1860          //        if (read_write_i2c_buffer[i] != 0xff) empty_block = 0;
   1861          //        i++;
   1862          //      }
   1863          //      
   1864          //      if(empty_block == 0)
   1865          //      {
   1866          //        //Помічаємо, що блок не є пустим
   1867          //        state_i2c_task &= (unsigned int)(~STATE_TRG_FUNC_EEPROM_EMPTY);
   1868          //        //Скидаємо повідомлення у слові діагностики
   1869          //        _SET_BIT(clear_diagnostyka, ERROR_TRG_FUNC_EEPROM_EMPTY_BIT);
   1870          //        
   1871          //        //Перевіряємо контрольну суму і переписуємо прочитані дані у тимчасові змінні
   1872          //        unsigned char crc_eeprom_trg_func = 0, temp_value;
   1873          //        unsigned char  *point;
   1874          //        unsigned int offset = 0;
   1875          //
   1876          //        point = (unsigned char*)(&trigger_active_functions_tmp); 
   1877          //        for (i =0; i < sizeof(trigger_active_functions_tmp); i++)
   1878          //        {
   1879          //          temp_value = read_write_i2c_buffer[offset + i];
   1880          //          *(point) = temp_value;
   1881          //          crc_eeprom_trg_func += temp_value;
   1882          //          point++;
   1883          //        }
   1884          //        offset +=  sizeof(trigger_active_functions_tmp);
   1885          //        
   1886          //        if (read_write_i2c_buffer[offset]  == ((unsigned char)((~(unsigned int)crc_eeprom_trg_func) & 0xff)))
   1887          //        {
   1888          //          //Контролдьна сума сходиться
   1889          //
   1890          //          //Скидаємо повідомлення у слові діагностики
   1891          //          _SET_BIT(clear_diagnostyka, ERROR_TRG_FUNC_EEPROM_BIT);
   1892          //          
   1893          //          //Зберігаємо контрольну суму (не інвертовану)
   1894          //          crc_trg_func = crc_eeprom_trg_func;
   1895          //          
   1896          //          if ((comparison_writing & COMPARISON_WRITING_TRG_FUNC) == 0)
   1897          //          {
   1898          //            //Виконувалося зчитування триґерної інформації
   1899          //            
   1900          //            //Перекидаємо триґерну інформацію у робочі змінні
   1901          //            for(unsigned int k = 0; k < N_BIG; k++) trigger_active_functions[k] = trigger_active_functions_tmp[k];
   1902          ////            restore_trigger_functions(trigger_active_functions);
   1903          //          }
   1904          //          else
   1905          //          {
   1906          //            //Виконувалося контроль достовірності записаної інформації у EEPROM з записуваною
   1907          //            
   1908          //            unsigned int difference = 0;
   1909          //  
   1910          //            i = 0;
   1911          //            while ((difference == 0) && (i < N_BIG))
   1912          //            {
   1913          //              //Перевірка запису функцій значення яких зберігається у енергонезалежній пам'яті
   1914          //              if (trigger_active_functions_comp[i] != trigger_active_functions_tmp[i]) difference = 0xff;
   1915          //              else
   1916          //              {
   1917          //                i++;
   1918          //              }
   1919          //            }
   1920          //            
   1921          //            if (difference == 0)
   1922          //            {
   1923          //              //Контроль порівнняння пройшов успішно
   1924          //  
   1925          //              //Скидаємо повідомлення у слові діагностики
   1926          //              _SET_BIT(clear_diagnostyka, ERROR_TRG_FUNC_EEPROM_COMPARISON_BIT);
   1927          //            }
   1928          //            else
   1929          //            {
   1930          //              //Контроль порівнняння зафіксував розбіжності між записаною і записуваною інформацією
   1931          //
   1932          //              //Виствляємо повідомлення у слові діагностики
   1933          //              _SET_BIT(set_diagnostyka, ERROR_TRG_FUNC_EEPROM_COMPARISON_BIT);
   1934          //            }
   1935          //          }
   1936          //
   1937          //          state_i2c_task &= (unsigned int)(~STATE_TRG_FUNC_EEPROM_FAIL);
   1938          //          state_i2c_task |= STATE_TRG_FUNC_EEPROM_GOOD;
   1939          //        }
   1940          //        else
   1941          //        {
   1942          //          //Контрольна сума не сходиться
   1943          //          state_i2c_task &= (unsigned int)(~STATE_TRG_FUNC_EEPROM_GOOD);
   1944          //          state_i2c_task |= STATE_TRG_FUNC_EEPROM_FAIL;
   1945          //          
   1946          //          //Виствляємо повідомлення у слові діагностики
   1947          //          _SET_BIT(set_diagnostyka, ERROR_TRG_FUNC_EEPROM_BIT);
   1948          //        }
   1949          //      }
   1950          //      else
   1951          //      {
   1952          //        //Помічаємо, що прочитаний блок є пустим
   1953          //        state_i2c_task &= (unsigned int)(~STATE_TRG_FUNC_EEPROM_FAIL);
   1954          //        state_i2c_task &= (unsigned int)(~STATE_TRG_FUNC_EEPROM_GOOD);
   1955          //        state_i2c_task |= STATE_TRG_FUNC_EEPROM_EMPTY;
   1956          //        
   1957          //        //Виствляємо повідомлення у слові діагностики
   1958          //        _SET_BIT(clear_diagnostyka, ERROR_TRG_FUNC_EEPROM_BIT);
   1959          //        _SET_BIT(set_diagnostyka, ERROR_TRG_FUNC_EEPROM_EMPTY_BIT);
   1960          //      }
   1961          //            
   1962          //      //Знімаємо можливу сигналізацію, що виконувалося порівнняння
   1963          //      comparison_writing &= (unsigned int)(~COMPARISON_WRITING_TRG_FUNC);
   1964          //      //Скидаємо повідомлення про читання даних
   1965          //      _CLEAR_BIT(control_i2c_taskes, TASK_READING_TRG_FUNC_EEPROM_BIT);
   1966          //    }
   1967              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_READING_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT) !=0)
   1968              {
   1969                //Аналізуємо прочитані дані
   1970                //Спочатку аналізуємо, чи прояитаний блок є пустим, чи вже попередньо записаним
   1971                unsigned int empty_block = 1, i = 0; 
   1972                __INFO_REJESTRATOR info_rejestrator_pr_err_tmp;
   1973                
   1974                while ((empty_block != 0) && ( i < (sizeof(__INFO_REJESTRATOR) + 1)))
   1975                {
   1976                  if (read_write_i2c_buffer[i] != 0xff) empty_block = 0;
   1977                  i++;
   1978                }
   1979                
   1980                if(empty_block == 0)
   1981                {
   1982                  //Помічаємо, що блок не є пустим
   1983                  state_i2c_task &= (unsigned int)(~STATE_INFO_REJESTRATOR_PR_ERR_EEPROM_EMPTY);
   1984                  //Скидаємо повідомлення у слові діагностики
   1985                  _SET_BIT(clear_diagnostyka, ERROR_INFO_REJESTRATOR_PR_ERR_EEPROM_EMPTY_BIT);
   1986                  
   1987                  //Перевіряємо контрольну суму і переписуємо прочитані дані у структуру
   1988                  unsigned char crc_eeprom_info_rejestrator_pr_err = 0, temp_value;
   1989                  unsigned char  *point = (unsigned char*)(&info_rejestrator_pr_err_tmp); 
   1990                  for (i =0; i < sizeof(__INFO_REJESTRATOR); i++)
   1991                  {
   1992                    temp_value = read_write_i2c_buffer[i];
   1993                    *(point) = temp_value;
   1994                    crc_eeprom_info_rejestrator_pr_err += temp_value;
   1995                    point++;
   1996                  }
   1997                  if (read_write_i2c_buffer[sizeof(__INFO_REJESTRATOR)]  == ((unsigned char)((~(unsigned int)crc_eeprom_info_rejestrator_pr_err) & 0xff)))
   1998                  {
   1999                    //Контролдьна сума сходиться
   2000                    
   2001                    //Зберігаємо контрольну суму (не інвертовану)
   2002                    crc_info_rejestrator_pr_err = crc_eeprom_info_rejestrator_pr_err;
   2003          
   2004                    state_i2c_task &= (unsigned int)(~STATE_INFO_REJESTRATOR_PR_ERR_EEPROM_FAIL);
   2005                    state_i2c_task |= STATE_INFO_REJESTRATOR_PR_ERR_EEPROM_GOOD;
   2006                    
   2007                    //Скидаємо повідомлення у слові діагностики
   2008                    _SET_BIT(clear_diagnostyka, ERROR_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT);
   2009          
   2010                    if ((comparison_writing & COMPARISON_WRITING_INFO_REJESTRATOR_PR_ERR) == 0)
   2011                    {
   2012                      //Виконувалося зчитування інформації по реєстратору програмних подій у робочу структуру
   2013                      
   2014                      //Перекидаємо інформації по реєстратору програмних подій з тимчасової структури у робочу структуру
   2015                      info_rejestrator_pr_err = info_rejestrator_pr_err_tmp;
   2016          
   2017                      //Перевіряємо чи всі поляу у своїх допустимих межах
   2018                      if(
   2019                         (info_rejestrator_pr_err.next_address   >= MIN_ADDRESS_PR_ERR_AREA) && 
   2020                         (info_rejestrator_pr_err.next_address   <= MAX_ADDRESS_PR_ERR_AREA) &&
   2021                         (info_rejestrator_pr_err.number_records <= MAX_NUMBER_RECORDS_INTO_PR_ERR)  
   2022                        )
   2023                      {
   2024                        //Всі величину мають допустимі значення
   2025          
   2026                        //Перевіряємо, чи у процесі запису останньої аварії не відбувся перезапуск/запуск приладу.
   2027                        //Тоді останій запис може бути пошкодженим, якщо вже свя флешка є заповнена
   2028                        //Тоді помічаємо, що у нашій флешці на один запис є менше
   2029                        //Перевіряємо, чи у процесі запису програмної події не відбувся перезапуск/запуск приладу.
   2030                        //Тоді записи у сторінці, яку записували може бути пошкодженими
   2031                        if (info_rejestrator_pr_err.saving_execution !=0 )
   2032                        {
   2033                          //Виставляємо повідомлення про цю подію
   2034                          _SET_BIT(set_diagnostyka, ERROR_PR_ERR_LOSS_INFORMATION_BIT);
   2035          
   2036                          //Виставляємо команду запису цієї структури у EEPROM
   2037                          /*
   2038                          Команду виставляємо скоріше, а потім робимо зміни у полях, які треба змінити,
   2039                          бо по вимозі проконтролювати достовірність даних інформації по реєстратору
   2040                          програмних подій відбувається копіювання з переривання обслуговування DataFlash структури
   2041                          info_rejestrator_pr_err у резервну копію. Це копіювання блокується у випадку 
   2042                          "читання з"/"запису в" EEPROM цієї інформації. Тому виставлення спочатку команди
   2043                          запису заблокує копіювання.
   2044                          З другої сторони не можливо, щоб почався запис до модифікації, 
   2045                          бо запис ініціюється функцією main_routines_for_i2c - в якій ми зараз знаходимося.
   2046                          Тобто спочатку треба з цієї функції вийти і при наступних входженнях у цю функцію
   2047                          можливе виконання команди, яку ми виставили перед зміною даних, яку 
   2048                          ми зараз гарантовано зробимо (до виходу з цієї функції)
   2049                          */
   2050                          _SET_BIT(control_i2c_taskes, TASK_START_WRITE_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT);
   2051          
   2052                          info_rejestrator_pr_err.saving_execution = 0;
   2053                          
   2054                          
   2055                        }   
   2056                      }
   2057                      else
   2058                      {
   2059                        //Виствляємо повідомлення у слові діагностики
   2060                        _SET_BIT(set_diagnostyka, ERROR_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT);
   2061                    
   2062                        //Виставляємо команду запису цієї структури у EEPROM
   2063                        /*
   2064                        Команду виставляємо скоріше, а потім робимо зміни у полях, які треба змінити,
   2065                        бо по вимозі проконтролювати достовірність даних інформації по реєстратору
   2066                        програмних подій відбувається копіювання з переривання обслуговування DataFlash структури
   2067                        info_rejestrator_pr_err у резервну копію. Це копіювання блокується у випадку 
   2068                        "читання з"/"запису в" EEPROM цієї інформації. Тому виставлення спочатку команди
   2069                        запису заблокує копіювання.
   2070                        З другої сторони не можливо, щоб почався запис до модифікації, 
   2071                        бо запис ініціюється функцією main_routines_for_i2c - в якій ми зараз знаходимося.
   2072                        Тобто спочатку треба з цієї функції вийти і при наступних входженнях у цю функцію
   2073                        можливе виконання команди, яку ми виставили перед зміною даних, яку 
   2074                        ми зараз гарантовано зробимо (до виходу з цієї функції)
   2075                        */
   2076                        _SET_BIT(control_i2c_taskes, TASK_START_WRITE_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT);
   2077          
   2078                        //Очищаємо структуру інформації по реєстраторі програмних подій
   2079                        info_rejestrator_pr_err.next_address = MIN_ADDRESS_PR_ERR_AREA;
   2080                        info_rejestrator_pr_err.saving_execution = 0;
   2081                        info_rejestrator_pr_err.number_records = 0;
   2082                      }
   2083                    }
   2084                    else
   2085                    {
   2086                      //Виконувалося контроль достовірності записаної інформації у EEPROM з записуваною
   2087                      
   2088                      unsigned char  *point_to_read  = (unsigned char*)(&info_rejestrator_pr_err_tmp );
   2089                      unsigned char  *point_to_write = (unsigned char*)(&info_rejestrator_pr_err_comp);
   2090                      unsigned int difference = 0;
   2091          
   2092                      i = 0;
   2093                      while ((difference == 0) && ( i < sizeof(__INFO_REJESTRATOR)))
   2094                      {
   2095                        if (*point_to_write != *point_to_read) difference = 0xff;
   2096                        else
   2097                        {
   2098                          point_to_write++;
   2099                          point_to_read++;
   2100                          i++;
   2101                        }
   2102                      }
   2103                      if (difference == 0)
   2104                      {
   2105                        //Контроль порівнняння пройшов успішно
   2106          
   2107                        //Скидаємо повідомлення у слові діагностики
   2108                        _SET_BIT(clear_diagnostyka, ERROR_INFO_REJESTRATOR_PR_ERR_COMPARISON_BIT);
   2109                      }
   2110                      else
   2111                      {
   2112                        //Контроль порівнняння зафіксував розбіжності між записаною і записуваною інформацією
   2113          
   2114                        //Виствляємо повідомлення у слові діагностики
   2115                        _SET_BIT(set_diagnostyka, ERROR_INFO_REJESTRATOR_PR_ERR_COMPARISON_BIT);
   2116                      }
   2117                    }
   2118                  }
   2119                  else
   2120                  {
   2121                    //Контрольна сума не сходиться
   2122                    state_i2c_task &= (unsigned int)(~STATE_INFO_REJESTRATOR_PR_ERR_EEPROM_GOOD);
   2123                    state_i2c_task |= STATE_INFO_REJESTRATOR_PR_ERR_EEPROM_FAIL;
   2124                    
   2125                    //Виствляємо повідомлення у слові діагностики
   2126                    _SET_BIT(set_diagnostyka, ERROR_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT);
   2127                    
   2128                    /*
   2129                    Виставляємо повідомлення про те, що в EEPROM треба записати нові значення
   2130                    структури тільки тоді, коли ми зчитуємо збережені дані для відновлення 
   2131                    їх у оперативній пам'яті, а не коли ми проводимо контроль запису.
   2132                    Бо для контролю запису нам важливо знати чи успішно записалися дані, які є у 
   2133                    оперативній пам'яті і при цьому, навіть, якщо запис відбувся невдало, то,
   2134                    оскільки ми працюємо зі змінними з оперативної пам'яті,  які є у нас достовірні,
   2135                    бо ми їх якраз і записували, то на роботу до перезавантаження програмного забезперечння 
   2136                    збій запису у EEPROM не мав би вплинути
   2137                    */
   2138                    if ((comparison_writing & COMPARISON_WRITING_INFO_REJESTRATOR_PR_ERR) == 0)
   2139                    {
   2140                      //Виконувалося зчитування інформації по дискретному реєстратору у робочу структуру
   2141          
   2142                      //Виставляємо команду запису цієї структури у EEPROM
   2143                      /*
   2144                      Команду виставляємо скоріше, а потім робимо зміни у полях, які треба змінити,
   2145                      бо по вимозі проконтролювати достовірність даних інформації по реєстратору
   2146                      програмних подій відбувається копіювання з переривання обслуговування DataFlash структури
   2147                      info_rejestrator_pr_err у резервну копію. Це копіювання блокується у випадку 
   2148                      "читання з"/"запису в" EEPROM цієї інформації. Тому виставлення спочатку команди
   2149                      запису заблокує копіювання.
   2150                      З другої сторони не можливо, щоб почався запис до модифікації, 
   2151                      бо запис ініціюється функцією main_routines_for_i2c - в якій ми зараз знаходимося.
   2152                      Тобто спочатку треба з цієї функції вийти і при наступних входженнях у цю функцію
   2153                      можливе виконання команди, яку ми виставили перед зміною даних, яку 
   2154                      ми зараз гарантовано зробимо (до виходу з цієї функції)
   2155                      */
   2156                      _SET_BIT(control_i2c_taskes, TASK_START_WRITE_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT);
   2157          
   2158                      //Очищаємо структуру інформації по реєстраторі програмних подій
   2159                      info_rejestrator_pr_err.next_address = MIN_ADDRESS_PR_ERR_AREA;
   2160                      info_rejestrator_pr_err.saving_execution = 0;
   2161                      info_rejestrator_pr_err.number_records = 0;
   2162                    }
   2163                  }
   2164                }
   2165                else
   2166                {
   2167                  //Помічаємо, що прочитаний блок є пустим
   2168                  state_i2c_task &= (unsigned int)(~(STATE_INFO_REJESTRATOR_PR_ERR_EEPROM_FAIL | STATE_INFO_REJESTRATOR_PR_ERR_EEPROM_GOOD));
   2169                  state_i2c_task |= STATE_INFO_REJESTRATOR_PR_ERR_EEPROM_EMPTY;
   2170                  
   2171                  //Виствляємо повідомлення у слові діагностики
   2172                  _SET_BIT(clear_diagnostyka, ERROR_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT);
   2173                  _SET_BIT(set_diagnostyka, ERROR_INFO_REJESTRATOR_PR_ERR_EEPROM_EMPTY_BIT);
   2174          
   2175                  /*
   2176                  Виставляємо повідомлення про те, що в EEPROM треба записати нові значення
   2177                  структури тільки тоді, коли ми зчитуємо збережені дані для відновлення 
   2178                  їх у оперативній пам'яті, а не коли ми проводимо контроль запису.
   2179                  Бо для контролю запису нам важливо знати чи успішно записалися дані, які є у 
   2180                  оперативній пам'яті і при цьому, навіть, якщо запис відбувся невдало, то,
   2181                  оскільки ми працюємо зі змінними з оперативної пам'яті,  які є у нас достовірні,
   2182                  бо ми їх якраз і записували, то на роботу до перезавантаження програмного забезперечння 
   2183                  збій запису у EEPROM не мав би вплинути
   2184                  */
   2185                  if ((comparison_writing & COMPARISON_WRITING_INFO_REJESTRATOR_PR_ERR) == 0)
   2186                  {
   2187                    //Виконувалося зчитування інформації по дискретному реєстратору у робочу структуру
   2188          
   2189                    //Виставляємо команду запису цієї структури у EEPROM
   2190                    /*
   2191                    Команду виставляємо скоріше, а потім робимо зміни у полях, які треба змінити,
   2192                    бо по вимозі проконтролювати достовірність даних інформації по реєстратору
   2193                    програмних подій відбувається копіювання з переривання обслуговування DataFlash структури
   2194                    info_rejestrator_pr_err у резервну копію. Це копіювання блокується у випадку 
   2195                    "читання з"/"запису в" EEPROM цієї інформації. Тому виставлення спочатку команди
   2196                    запису заблокує копіювання.
   2197                    З другої сторони не можливо, щоб почався запис до модифікації, 
   2198                    бо запис ініціюється функцією main_routines_for_i2c - в якій ми зараз знаходимося.
   2199                    Тобто спочатку треба з цієї функції вийти і при наступних входженнях у цю функцію
   2200                    можливе виконання команди, яку ми виставили перед зміною даних, яку 
   2201                    ми зараз гарантовано зробимо (до виходу з цієї функції)
   2202                    */
   2203                    _SET_BIT(control_i2c_taskes, TASK_START_WRITE_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT);
   2204          
   2205                    //Очищаємо структуру інформації по реєстраторі програмних подій
   2206                    info_rejestrator_pr_err.next_address = MIN_ADDRESS_PR_ERR_AREA;
   2207                    info_rejestrator_pr_err.saving_execution = 0;
   2208                    info_rejestrator_pr_err.number_records = 0;
   2209                  }
   2210                }
   2211          
   2212                //Знімаємо можливу сигналізацію, що виконувалося порівнняння
   2213                comparison_writing &= (unsigned int)(~COMPARISON_WRITING_INFO_REJESTRATOR_PR_ERR);
   2214                //Скидаємо повідомлення про читання даних
   2215                _CLEAR_BIT(control_i2c_taskes, TASK_READING_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT);
   2216              }
   2217              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_READING_RTC_BIT) !=0)
   2218              {
   2219                //Аналізуємо прочитані дані
   2220                if (
   2221                    ((read_write_i2c_buffer[0xA ] & (1<< 6)) == 0 ) /*SQWE = 0*/ ||
   2222                    ((read_write_i2c_buffer[0xC] &  (1<< 6)) != 0 ) /*HT  = 1 */ ||
   2223                    ((read_write_i2c_buffer[0x13]          ) != 0xf0) /*Потрібна частота*/ 
   2224                   )
   2225                {
   2226                  //Треба потрібні біти  і слова виставити у робочі значення, щоб на виході отримати 1гц
   2227                  temp_register_rtc[0] = read_write_i2c_buffer[0xC ] & (unsigned char)(~ (1<< 6));
   2228                  temp_register_rtc[1] = read_write_i2c_buffer[0xA ] | (1<< 6);
   2229          
   2230                  //Повідомлення про цю несправність виставляємо, коли не йде тільки-но перше зчитування
   2231                  if((state_i2c_task & STATE_FIRST_READING_RTC) == 0 ) _SET_BIT(set_diagnostyka, RTC_WORK_FIELD_NOT_SET_BIT);
   2232                  else _SET_BIT(clear_diagnostyka, RTC_WORK_FIELD_NOT_SET_BIT);
   2233                  
   2234                  etap_settings_test_frequency = 0;
   2235                  _SET_BIT(control_i2c_taskes, TASK_SET_START_SETTINGS_RTC_BIT);
   2236                } 
   2237                else
   2238                  _SET_BIT(clear_diagnostyka, RTC_WORK_FIELD_NOT_SET_BIT);
   2239                
   2240                if ((read_write_i2c_buffer[0x1] &  (1<< 7)) != 0) /*ST = 1 */
   2241                {
   2242                  //Треба запустиити осцилятор для RTC
   2243                  _SET_BIT(control_i2c_taskes, TASK_RESET_ST_RTC_BIT);
   2244                }
   2245                else if ((etap_reset_of_bit < ETAP_CLEAR_OF_ST_STOP) && ((read_write_i2c_buffer[0xf] & (1<<2)) != 0))
   2246                {
   2247                  _SET_BIT(set_diagnostyka, RTC_OSCILLATOR_FAIL_BIT);
   2248                  //Треба ST-біт виставити в 1 і негайно скинути його в 0. Почекати через 5 секунд він має скинутися
   2249                  if((state_i2c_task & STATE_FIRST_READING_RTC) == 0 )
   2250                  {
   2251                    etap_reset_of_bit = ETAP_CLEAR_OF_ST_STOP;
   2252                    _SET_BIT(control_i2c_taskes, TASK_RESET_OF_RTC_BIT);
   2253                  }
   2254                  else
   2255                    etap_reset_of_bit = ETAP_CLEAR_OF_ST_START_WAITING_5S;
   2256                }
   2257                else if (etap_reset_of_bit == ETAP_CLEAR_OF_WRITE_OF_0)
   2258                {
   2259                  //Треба очистити OF-біт
   2260                  temp_value_for_rtc = read_write_i2c_buffer[0xf];
   2261                  _SET_BIT(control_i2c_taskes, TASK_RESET_OF_RTC_BIT);
   2262                }
   2263                
   2264                if ((read_write_i2c_buffer[0xC] & (1<< 6)) != 0)
   2265                {
   2266                  //Повідомлення про цю несправність виставляємо, коли не йде тільки-но перше зчитування
   2267                  if((state_i2c_task & STATE_FIRST_READING_RTC) == 0 )_SET_BIT(set_diagnostyka, RTC_UPDATING_HALTED_BIT);
   2268                  else _SET_BIT(clear_diagnostyka, RTC_UPDATING_HALTED_BIT);
   2269                }
   2270                else _SET_BIT(clear_diagnostyka, RTC_UPDATING_HALTED_BIT);
   2271                if ((read_write_i2c_buffer[0x1] &  (1<< 7)) != 0) _SET_BIT(set_diagnostyka, RTC_OSCILLATOR_STOPED_BIT);
   2272                else _SET_BIT(clear_diagnostyka, RTC_OSCILLATOR_STOPED_BIT);
   2273                if ((read_write_i2c_buffer[0xF] &  (1<< 4)) != 0) _SET_BIT(set_diagnostyka, RTC_BATTERY_LOW_BIT);
   2274                else _SET_BIT(clear_diagnostyka, RTC_BATTERY_LOW_BIT);
   2275                if ((read_write_i2c_buffer[0xF] &  (1<< 2)) == 0) _SET_BIT(clear_diagnostyka, RTC_OSCILLATOR_FAIL_BIT);
   2276                
   2277                if((state_i2c_task & STATE_FIRST_READING_RTC) !=0)
   2278                {
   2279                  //Зараз відбувається перше зчитування даних з RTC - скидаємо біт першого читання
   2280                  state_i2c_task &= (unsigned int)(~STATE_FIRST_READING_RTC);
   2281                }
   2282          
   2283                //Обновлюємо час
   2284                copying_time = 1; //Помічаємо, що зараз обновляємо масив часу
   2285                time[0] = read_write_i2c_buffer[0] & 0xff;
   2286                time[1] = read_write_i2c_buffer[1] & 0x7f;
   2287                time[2] = read_write_i2c_buffer[2] & 0x7f;
   2288                time[3] = read_write_i2c_buffer[3] & 0x3f;
   2289                time[4] = read_write_i2c_buffer[5] & 0x3f;
   2290                time[5] = read_write_i2c_buffer[6] & 0x1f;
   2291                time[6] = read_write_i2c_buffer[7] & 0xff;
   2292                copy_register8_RTC = read_write_i2c_buffer[8];
   2293                calibration = copy_register8_RTC & 0x3f;
   2294          
   2295                copying_time = 0; //Помічаємо, що обновлення масив часу завершене
   2296                //Робимо копію масиву часу для того, щоб коли основний масив буде обновлятися можна було іншим модулям взяти попереднє, але достовірне значення часу і дати з цього масиву
   2297                for(unsigned int i = 0; i < 7; i++) time_copy[i] = time[i];
   2298                calibration_copy = calibration;
   2299                
   2300                if(
   2301                   (_CHECK_SET_BIT(    diagnostyka, EVENT_START_SYSTEM_BIT  ) != 0) ||
   2302                   (_CHECK_SET_BIT(set_diagnostyka, EVENT_START_SYSTEM_BIT  ) != 0) ||
   2303                   (_CHECK_SET_BIT(    diagnostyka, EVENT_RESTART_SYSTEM_BIT) != 0) ||
   2304                   (_CHECK_SET_BIT(set_diagnostyka, EVENT_RESTART_SYSTEM_BIT) != 0)
   2305                  )
   2306                {
   2307                  //До цього часу ще не зчитано першої реальної часової мітки
   2308                  if((read_write_i2c_buffer[0xC] & (1<< 6)) != 0)
   2309                  {
   2310                    //Зчитано час, коли пропало живлення з RTC внаслідок виключення пристрою
   2311                    fixed_power_down_into_RTC = 1; //Виставляємо повідомлення про те, що було зафіксовано пропадання живлення на годиннику RTC до того, як програма стартувала спочатку
   2312          
   2313                    if ((head_fifo_buffer_pr_err_records > 1) && (tail_fifo_buffer_pr_err_records == 0))
   2314                    {
   2315                      //Це перестраховка, бо завжди у цьому місці має бути як мінімум два записи в буфері FIFO подія про зупинку роботи приладу і старт/рестарт системи, а запис у мікросхему dataFlash ще  є забороненй
   2316                      unsigned int local_point_for_time = tail_fifo_buffer_pr_err_records*SIZE_ONE_RECORD_PR_ERR + 1 ; //Індекс першого числа часу у вже першому записі (перший запис відподає за подію - зупинку роботи приладу) (tail_fifo_buffer_pr_err_records має дорівнювати 0 у ціьому місці програми)
   2317                      //Час, який зараз прочитаний з RTC до моменту скидання біту HT вказує на час до пропадання живлення з годинника RTC
   2318                      for(unsigned int i = 0; i < 7; i++)  buffer_pr_err_records[local_point_for_time + i] = time[i]; /*використовувати time_copy і calibration_copy не треба бо іде обробка одної функції main_routines_for_i2c*/ 
   2319                    }
   2320                  }
   2321                  else
   2322                  {
   2323                    //Зчитано першу часову мітку з моменту запуску/перезапуску програми
   2324                    unsigned int local_point_for_time;
   2325          
   2326                    if (fixed_power_down_into_RTC == 0)
   2327                    {
   2328                      //Це означає, що програма не зафікусала факт пропадання живлення на годиннику RTC до моменту запуску/перезапуску програми
   2329                      /*
   2330                      Тому подію про зупинку пристрою трбе очистити із очікуваних на запис
   2331                      шляхом встановлення "хвоста" буферу FIF0  в значення 1
   2332                      (індес 0 до моменту розблокування запису в реєстратор програмних подій,
   2333                      згідно розробленого програмного забезпечення  - це подія про зупинку роботи приладу,
   2334                      а 1 - це наступна подія)
   2335                      */
   2336                      if ((head_fifo_buffer_pr_err_records > 0) && (tail_fifo_buffer_pr_err_records == 0))
   2337                      {
   2338                        //Це перестраховка, бо завжди у цьому місці має бути як мінімум два записи в буфері FIFO подія про зупинку роботи приладу і старт/рестарт системи, а запис у мікросхему dataFlash ще  є забороненй
   2339                        /*
   2340                        Якби перша половина цієї умови (head_fifo_buffer_pr_err_records > 0)
   2341                        по незрозумілій причині для мене не виконувалася то тоді ми нічого не міняємо, і тоді 
   2342                        head_fifo_buffer_pr_err_records = 0 і tail_fifo_buffer_pr_err_records = 0,
   2343                        а це буде означати. що немає нових записів у черзі до запису і тому я думаю. що нічого 
   2344                        надзвичайного не мало б статися. Хоч це і неможливо, на мій погляд, і з точки зору ідеології
   2345                        розробленого програмного забезпечення.
   2346                        
   2347                        Якби ця умова по незрозумілій причині для мене не виконувалася повністю.
   2348                        То я з нову ж таки не можу зрозуміти, чого така виникла ситтуація, але думю. що тоді ніяких корекцій
   2349                        не варта робити, бо хоч це і неможливо, на мій погляд, і з точки зору ідеології
   2350                        розробленого програмного забезпечення  - аде я не думаю, що це б привело до неправильної 
   2351                        роботи "основної" частини програмного забезпечення
   2352                        */
   2353                        tail_fifo_buffer_pr_err_records += 1;
   2354                        while(tail_fifo_buffer_pr_err_records >= MAX_NUMBER_RECORDS_PR_ERR_INTO_BUFFER) tail_fifo_buffer_pr_err_records -= MAX_NUMBER_RECORDS_PR_ERR_INTO_BUFFER;
   2355                      }
   2356          
   2357                      local_point_for_time = tail_fifo_buffer_pr_err_records*SIZE_ONE_RECORD_PR_ERR + 1; //Індекс першого числа часу у першому записі, який чекає на запис у DataFlash
   2358                    }
   2359                    else
   2360                    {
   2361                      local_point_for_time = (tail_fifo_buffer_pr_err_records + 1)*SIZE_ONE_RECORD_PR_ERR + 1; //Індекс першого числа часу у другому записі, який чекає на запис у DataFlash
   2362                    }
   2363          
   2364                    //Встановлюємо часові мітки для тих подій, які мали місце до зчитування першої реальної часової мітки
   2365                    /*
   2366                    Змінна local_point_for_time зараз вказує на перше число часу другого запису (якщо була фіксація виключення живлення перед стартом),
   2367                    або першого запису (якщо пропадання живлення на RTC перед стартом програми не було зафіксовано)
   2368                    */
   2369                    
   2370                    //Блокуємо початок записування підготовлених записів до моменту гарантованого розставляння всіх часових міток
   2371                    temporary_block_writing_records_pr_err_into_DataFlash = 1;
   2372                    /*Цикл у циклі з однаковою умовою завершення я зробив для того, що 
   2373                    ця частина коду може у будь-який момент часу буде перервана вищепріоритетною
   2374                    роботою, яка сформує новий запис (але часову мітку ставить тоді,
   2375                    коли зняті події про запуск/перезапуск ). Крім того тут я знімаю в діагностіиці
   2376                    подію про запуск/перезапуск програми, що є також умовою блокування старту
   2377                    записування у мікросхему DataFlash і, саме головне, встановлення часових міток
   2378                    з модуля формування запису.
   2379                    Тому, теоретично може бути, що часові мітки жве всі виставлені, але до моменту
   2380                    зняття події запуску/перезапуску, сформувався новий запис у якого не буде часової мітки.
   2381                    Тому повторна перевірка після зняття заборони встановлення часових міток у модулі 
   2382                    формування запису, мала б повторно перейти до довстановлення часових міток
   2383                    у такоих записах.
   2384                    Аж після успішного повторного підтвердження розставляння часових міток буде розблоковно
   2385                    записування записів у мікросхему DataFlash.
   2386                    При цьому не треба боятися, що у такий момент, що часові сітки дозволені 
   2387                    і з модуля формування запису і дорозставляння часових міток з цієї частини програми
   2388                    буде втачена достовірність часової мітки, бо поки ми не вийдемо з цієї
   2389                    частини програми, то не буде запущено читання нового значення часу. Тобто
   2390                    на цей момент часу не боже бути "свіжішої" часової мітки, ніж та що є зараз. 
   2391                    І старшою часовою часовоюміткою може бути тільки мітка вимкнення приладу.
   2392                    */
   2393                    do
   2394                    {
   2395                      while (
   2396                             (local_point_for_time < (head_fifo_buffer_pr_err_records*SIZE_ONE_RECORD_PR_ERR)) &&
   2397                             (local_point_for_time <  SIZE_BUFFER_FOR_PR_ERR)
   2398                            )
   2399                      {
   2400                        for(unsigned int i = 0; i < 7; i++)  buffer_pr_err_records[local_point_for_time + i] = time[i]; /*використовувати time_copy і calibration_copy не треба бо іде обробка одної функції main_routines_for_i2c*/ 
   2401                        local_point_for_time += SIZE_ONE_RECORD_PR_ERR;
   2402                      }
   2403          
   2404                      //Скидаємо біти запуску програми або її перезапуску
   2405                      _SET_BIT(clear_diagnostyka, EVENT_START_SYSTEM_BIT);
   2406                      _SET_BIT(clear_diagnostyka, EVENT_RESTART_SYSTEM_BIT);
   2407                    }
   2408                    while (
   2409                           (local_point_for_time < (head_fifo_buffer_pr_err_records*SIZE_ONE_RECORD_PR_ERR)) &&
   2410                           (local_point_for_time <  SIZE_BUFFER_FOR_PR_ERR)
   2411                          );
   2412                    //Розблоковуємо початок записування підготовлених записів, бо я вважаю, що часові мітки я вже гарантовано розставив
   2413                    temporary_block_writing_records_pr_err_into_DataFlash = 0;
   2414                  }
   2415                }
   2416          
   2417                //Скидаємо повідомлення про читання системного часу
   2418                _CLEAR_BIT(control_i2c_taskes, TASK_READING_RTC_BIT);
   2419              }
   2420              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_RTC_BIT) !=0)
   2421              {
   2422                //Виставляємо команду читання системного часу 
   2423                _SET_BIT(control_i2c_taskes, TASK_START_READ_RTC_BIT);
   2424                _SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);
   2425          
   2426                _CLEAR_BIT(control_i2c_taskes, TASK_WRITING_RTC_BIT);
   2427              }
   2428              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_SET_START_SETTINGS_RTC_BIT) !=0)
   2429              {
   2430                etap_settings_test_frequency++;
   2431                if (etap_settings_test_frequency > 2)
   2432                {
   2433                  etap_settings_test_frequency = -1;
   2434          
   2435                  //Повторно запускаємо читання регістрів RTC
   2436                  _SET_BIT(control_i2c_taskes, TASK_START_READ_RTC_BIT);
   2437                  _SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);
   2438          
   2439                  //Скидаємо біт виставляння бітів і полів у потрібні значення, якщо всі поля записані
   2440                  _CLEAR_BIT(control_i2c_taskes, TASK_SET_START_SETTINGS_RTC_BIT);
   2441                }
   2442              }
   2443              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_RESET_ST_RTC_BIT) !=0)
   2444              {
   2445                //Скидаємо біт запуску осцилятора RTC
   2446                _CLEAR_BIT(control_i2c_taskes, TASK_RESET_ST_RTC_BIT);
   2447              }
   2448              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_RESET_OF_RTC_BIT) !=0)
   2449              {
   2450                etap_reset_of_bit++;
   2451                if (etap_reset_of_bit == ETAP_CLEAR_OF_ST_START_WAITING_5S)
   2452                {
   2453                  //Скидаємо запущені операції попереднього  скидання OF-біту, але ще маємо витримати 5с для остаточного скидання OF-біту
   2454                  _CLEAR_BIT(control_i2c_taskes, TASK_RESET_OF_RTC_BIT);
   2455                }
   2456                else if (etap_reset_of_bit >= ETAP_CLEAR_OF_WRITE_OF_0)
   2457                {
   2458                  //Скидаємо запущені операції скидання OF-біту
   2459                  etap_reset_of_bit = ETAP_CLEAR_OF_NONE;
   2460                  _CLEAR_BIT(control_i2c_taskes, TASK_RESET_OF_RTC_BIT);
   2461                }
   2462              }
   2463              else
   2464              {
   2465                //Сюди, теоретично, ніколи не мала б дійти
   2466                //У всіх інакших випадках нічого не робимо
   2467              }
   2468              /*************************************************/
   2469            }
   2470            else if (driver_i2c.state_execution == 2)
   2471            {
   2472              /*************************************************/
   2473              //Обмін завершився з помилкою
   2474              /*************************************************/
   2475          
   2476              //Покищо просто очищаємо змінну, яка конкретизуєм помилку, у майбутньому її можна буде конкретизувати
   2477              type_error_of_exchanging_via_i2c = 0;
   2478              
   2479              //Виставляємо повідомлення, що I2C готовий до нової транзакції 
   2480              driver_i2c.state_execution = -1;
   2481          
   2482              //Визначаємося з наступними діями
   2483              if (
   2484                  (_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_CONFIG_EEPROM_BIT                 ) != 0) ||
   2485                  (_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_SETTINGS_EEPROM_BIT               ) != 0) ||
   2486                  (_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_USTUVANNJA_EEPROM_BIT             ) != 0) ||
   2487          //        (_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_TRG_FUNC_EEPROM_BIT               ) != 0) ||
   2488                  (_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT) != 0)
   2489                 )
   2490              {
   2491                //Стоїть умова запису блоку у EEPROM
   2492                //Залишаємо номер блоку для запису в EEPROM той самий, бо немає підтвердження, що він записався
   2493                //Виставляємо біт тимчасового блокування запису, щоб витримати певну павзу і запустити запис після більш пріоритетних завдвнь  
   2494                //Згідно документації операція запису відбувається до 5 мс
   2495                _SET_BIT(control_i2c_taskes, TASK_BLK_WRITING_EEPROM_BIT);
   2496              }
   2497              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_READING_CONFIG_EEPROM_BIT) !=0)
   2498              {
   2499                //Стоїть умова читання блоку у EEPROM конфігурації
   2500                
   2501                //Повторно запускаємо процес читання
   2502                _SET_BIT(control_i2c_taskes, TASK_START_READ_CONFIG_EEPROM_BIT);
   2503                _SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);        
   2504                _CLEAR_BIT(control_i2c_taskes, TASK_READING_CONFIG_EEPROM_BIT);
   2505              }
   2506              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_READING_SETTINGS_EEPROM_BIT) !=0)
   2507              {
   2508                //Стоїть умова читання блоку у EEPROM настройок
   2509                
   2510                //Повторно запускаємо процес читання
   2511                _SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);        
   2512                _CLEAR_BIT(control_i2c_taskes, TASK_READING_SETTINGS_EEPROM_BIT);
   2513              }
   2514              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_READING_USTUVANNJA_EEPROM_BIT) !=0)
   2515              {
   2516                //Стоїть умова читання блоку у EEPROM юстування
   2517                
   2518                //Повторно запускаємо процес читання
   2519                _SET_BIT(control_i2c_taskes, TASK_START_READ_USTUVANNJA_EEPROM_BIT);
   2520                _SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);        
   2521                _CLEAR_BIT(control_i2c_taskes, TASK_READING_USTUVANNJA_EEPROM_BIT);
   2522              }
   2523          //    else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_READING_TRG_FUNC_EEPROM_BIT) !=0)
   2524          //    {
   2525          //      //Стоїть умова читання блоку у EEPROM стану тригерної інформації
   2526          //      
   2527          //      //Повторно запускаємо процес читання
   2528          //      _SET_BIT(control_i2c_taskes, TASK_START_READ_TRG_FUNC_EEPROM_BIT);
   2529          //      _SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);        
   2530          //      _CLEAR_BIT(control_i2c_taskes, TASK_READING_TRG_FUNC_EEPROM_BIT);
   2531          //    }
   2532              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_READING_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT) !=0)
   2533              {
   2534                //Стоїть умова читання блоку у EEPROM по реєстраторі програмнихподій
   2535                
   2536                //Повторно запускаємо процес читання
   2537                _SET_BIT(control_i2c_taskes, TASK_START_READ_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT);
   2538                _SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);        
   2539                _CLEAR_BIT(control_i2c_taskes, TASK_READING_INFO_REJESTRATOR_PR_ERR_EEPROM_BIT);
   2540              }
   2541              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_READING_RTC_BIT) !=0)
   2542              {
   2543                //Стоїть умова читання RTC
   2544                
   2545                //Повторно запускаємо процес читання RTC
   2546                _SET_BIT(control_i2c_taskes, TASK_START_READ_RTC_BIT);
   2547                _SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);
   2548                _CLEAR_BIT(control_i2c_taskes, TASK_READING_RTC_BIT);
   2549              }
   2550              else if (_CHECK_SET_BIT(control_i2c_taskes, TASK_WRITING_RTC_BIT) !=0)
   2551              {
   2552                //Стоїть умова запису RTC
   2553                
   2554                //Повторно запускаємо процес запису RTC
   2555                _SET_BIT(control_i2c_taskes, TASK_START_WRITE_RTC_BIT);
   2556                _SET_BIT(control_i2c_taskes, TASK_BLK_OPERATION_BIT);        
   2557                _CLEAR_BIT(control_i2c_taskes, TASK_WRITING_RTC_BIT);
   2558              }
   2559              else if (
   2560                       (_CHECK_SET_BIT(control_i2c_taskes, TASK_RESET_OF_RTC_BIT          ) !=0) ||
   2561                       (_CHECK_SET_BIT(control_i2c_taskes, TASK_SET_START_SETTINGS_RTC_BIT) !=0) ||
   2562                       (_CHECK_SET_BIT(control_i2c_taskes, TASK_RESET_ST_RTC_BIT          ) !=0)
   2563                      )
   2564              {
   2565                //Повторно запускаємо операцію з того самого місця, яка не вийшла
   2566              }
   2567              else
   2568              {
   2569                //У всіх інакших випадках нічого не робимо
   2570              }
   2571              /*************************************************/
   2572            }
   2573          }
   2574          /*****************************************************/
   2575          
   2576          /*****************************************************/
   2577          //Перенастроювання I2C при періодичному неуспішному запуску трансакції
   2578          /*****************************************************/
   2579          void error_start_i2c(void)
   2580          {
   2581            _SET_BIT(set_diagnostyka, ERROR_START_VIA_I2C_BIT);
   2582                    
   2583            /**************/
   2584            //Переконфігуровуємо I2C
   2585            /**************/
   2586            //Зупиняємо геренацію переривань від I2C
   2587            I2C_ITConfig(I2C, I2C_IT_ERR | I2C_IT_EVT | I2C_IT_BUF, DISABLE);
   2588                     
   2589            //Зупиняємо потоки DMA якщо вони запущені
   2590            if ((DMA_StreamI2C_Tx->CR & (uint32_t)DMA_SxCR_EN) !=0) DMA_StreamI2C_Tx->CR &= ~(uint32_t)DMA_SxCR_EN;
   2591            if ((DMA_StreamI2C_Rx->CR & (uint32_t)DMA_SxCR_EN) !=0) DMA_StreamI2C_Rx->CR &= ~(uint32_t)DMA_SxCR_EN;
   2592                    
   2593            //Переконфігуровуємо I2C
   2594            Configure_I2C(I2C);
   2595            /**************/
   2596          }
   2597          /*****************************************************/
   2598          
   2599          /*****************************************************/
   2600          //
   2601          /*****************************************************/
   2602          /*****************************************************/
   2603          

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
       8   error_start_i2c
         8   -> Configure_I2C
         8   -> I2C_ITConfig
     144   main_routines_for_i2c
       144   -> allocate_dynamic_memory_for_settings
       144   -> copy_settings
       144   -> error_start_i2c
       144   -> free
       144   -> start_read_buffer_via_I2C
       144   -> start_write_buffer_via_I2C
       144   -> total_error_sw_fixed
      32   start_read_buffer_via_I2C
        32   -> I2C_AcknowledgeConfig
        32   -> I2C_ClearFlag
        32   -> I2C_GenerateSTART
        32   -> I2C_GenerateSTOP
        32   -> I2C_GetFlagStatus
        32   -> I2C_GetLastEvent
        32   -> I2C_ITConfig
        32   -> I2C_ReceiveData
      32   start_write_buffer_via_I2C
        32   -> I2C_AcknowledgeConfig
        32   -> I2C_ClearFlag
        32   -> I2C_GenerateSTART
        32   -> I2C_GenerateSTOP
        32   -> I2C_GetFlagStatus
        32   -> I2C_GetLastEvent
        32   -> I2C_ITConfig
        32   -> I2C_ReceiveData


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable1
       4  ??DataTable1_1
       4  ??DataTable1_2
       4  ??DataTable1_3
       4  ??DataTable1_4
       4  ??DataTable2
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_12
       4  ??DataTable3_13
       4  ??DataTable3_14
       4  ??DataTable3_15
       4  ??DataTable3_16
       4  ??DataTable3_17
       4  ??DataTable3_18
       4  ??DataTable3_19
       4  ??DataTable3_2
       4  ??DataTable3_20
       4  ??DataTable3_21
       4  ??DataTable3_22
       4  ??DataTable3_23
       4  ??DataTable3_24
       4  ??DataTable3_25
       4  ??DataTable3_26
       4  ??DataTable3_27
       4  ??DataTable3_28
       4  ??DataTable3_29
       4  ??DataTable3_3
       4  ??DataTable3_30
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
       1  block
       1  block
       1  crc_eeprom_settings
       1  crc_eeprom_settings
      60  current_config_comp
       4  difference
       4  empty_block
      74  error_start_i2c
      12  info_rejestrator_pr_err_comp
    8952  main_routines_for_i2c
       4  number_block_config_write_to_eeprom
       4  number_block_info_rejestrator_pr_err_write_to_eeprom
       4  number_block_settings_write_to_eeprom
       4  number_block_ustuvannja_write_to_eeprom
       4  serial_number_dev_comp
       4  shift
       4  shift
       4  shift_from_start_address_settings_in_eeprom
       4  size_settings
     244  start_read_buffer_via_I2C
     244  start_write_buffer_via_I2C
       4  temp_value_for_rtc
      20  ustuvannja_comp

 
   144 bytes in section .bss
 9 662 bytes in section .text
 
 9 662 bytes of CODE memory
   144 bytes of DATA memory

Errors: none
Warnings: none
