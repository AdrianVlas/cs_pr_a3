###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       24/Mar/2017  12:54:59
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\menu_timer.c
#    Command line =  
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\menu_timer.c" -D USE_STDPERIPH_DRIVER -D STM32F2XX -D
#        USE_USB_OTG_FS -D KEYBOARD_VER_1 -D SYSTEM_VIEWER_ENABLE -lc
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List" --remarks -o
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --enable_multibytes --fpu=None
#        --dlib_config G:\PRG\IAR7_50_2\arm\INC\c\DLib_Config_Full.h -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\usb\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_OTG_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Core\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\"
#        -I "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\Config\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\OS\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\SEGGER\" -On --use_c++_inline
#        --require_prototypes -I G:\PRG\IAR7_50_2\arm\CMSIS\Include\ -D
#        ARM_MATH_CM3
#    List file    =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List\menu_timer.lst
#    Object file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj\menu_timer.o
#
###############################################################################

G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working files\src\menu_timer.c
      1          #include "header.h"
      2          
      3          /*****************************************************/
      4          //Формуємо екран відображення часових параметнів для багатофункціональних таймерів
      5          /*****************************************************/
      6          void make_ekran_delay_timer(void)
      7          {
      8            if (
      9                (current_state_menu2.edition == ED_WARNING_EDITION_BUSY) ||
     10                (current_state_menu2.edition == ED_WARNING_ENTER_ESC)
     11               )   
     12            {
     13              const uint8_t information_about_info[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
     14              {
     15                "Ред.не разрешено",
     16                "Ред.не дозволене",
     17                "Ed.isn't allowed",
     18                "Ред.не разрешено",
     19              };
     20          
     21              const uint8_t information_about_error[MAX_NAMBER_LANGUAGE][MAX_COL_LCD + 1] = 
     22              {
     23                " Вых.за диапазон",
     24                " Вих.за діапазон",
     25                "  Out of Limits ",
     26                "Вых.за диапазон "
     27              };
     28          
     29              enum _edition_stats edition = current_state_menu2.edition;
     30              make_ekran_about_info(((edition == ED_WARNING_EDITION_BUSY) ? false : true), ((edition == ED_WARNING_EDITION_BUSY) ? information_about_info : information_about_error));
     31            }
     32            else
     33            {
     34              const uint8_t name_string[MAX_NAMBER_LANGUAGE][TIMER_SET_DELAYS][MAX_COL_LCD + 1] = 
     35              {
     36                {
     37                  "  Таймер паузы  ",
     38                  " Таймер работы  "
     39                },
     40                {
     41                  "  Таймер паузи  ",
     42                  " Таймер роботи  "
     43                },
     44                {
     45                  "  Pause Timer   ",
     46                  " Operation Timer"
     47                },
     48                {
     49                  "  Таймер паузы  ",
     50                  " Таймер работы  "
     51                }
     52              };
     53              
     54              int index_language = index_language_in_array(select_struct_settings_fix()->language);
     55            
     56              unsigned int position_temp = current_state_menu2.index_position;
     57              //Множення на два величини position_temp потрібне для того, бо на одну позицію ми використовуємо два рядки (назва + значення)
     58              unsigned int index_in_ekran = ((position_temp << 1) >> POWER_MAX_ROW_LCD) << POWER_MAX_ROW_LCD;
     59            
     60              unsigned int first_symbol;
     61              uint32_t vaga, value;
     62            
     63              __settings_for_TIMER *p_settings_for_timer;
     64              if (current_state_menu2.edition == ED_VIEWING) p_settings_for_timer = &((((__LN_TIMER*)spca_of_p_prt[ID_FB_TIMER - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection)->settings);
     65              else if (current_state_menu2.edition == ED_CAN_BE_EDITED) p_settings_for_timer = (((__settings_for_TIMER*)sca_of_p[ID_FB_TIMER - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection);
     66              else p_settings_for_timer = (((__settings_for_TIMER*)sca_of_p_edit[ID_FB_TIMER - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection);
     67              size_t col_begin, col_end, col_comma;
     68            
     69              for (size_t i = 0; i < MAX_ROW_LCD; i++)
     70              {
     71                unsigned int index_in_ekran_tmp = index_in_ekran >> 1;
     72                if (index_in_ekran_tmp < TIMER_SET_DELAYS)
     73                {
     74                  if ((i & 0x1) == 0)
     75                  {
     76                    //У непарному номері рядку виводимо заголовок
     77                    for (size_t j = 0; j<MAX_COL_LCD; j++) working_ekran[i][j] = name_string[index_language][index_in_ekran_tmp][j];
     78                    first_symbol = 0; //помічаємо, що ще ніодин значущий символ не виведений
     79          
     80                    switch (index_in_ekran_tmp)
     81                    {
     82                    case TIMER_SET_DELAY_PAUSE:
     83                      {
     84                        vaga = 100000; //максимальний ваговий коефіцієнт
     85                        col_begin = COL_DELAY_TIMER_PAUSE_BEGIN;
     86                        col_end = COL_DELAY_TIMER_PAUSE_END;
     87                        col_comma = COL_DELAY_TIMER_PAUSE_COMMA;
     88                      
     89                        value = p_settings_for_timer->set_delay[TIMER_SET_DELAY_PAUSE];
     90                      
     91                        break;
     92                      }
     93                    case TIMER_SET_DELAY_WORK:
     94                      {
     95                        vaga = 100000; //максимальний ваговий коефіцієнт
     96                        col_begin = COL_DELAY_TIMER_WORK_BEGIN;
     97                        col_end = COL_DELAY_TIMER_WORK_END;
     98                        col_comma = COL_DELAY_TIMER_WORK_COMMA;
     99                      
    100                        value = p_settings_for_timer->set_delay[TIMER_SET_DELAY_WORK];
    101                      
    102                        break;
    103                      }
    104                    }
    105                  }
    106                  else
    107                  {
    108                    //У парному номері рядку виводимо значення
    109                    for (size_t j = 0; j < MAX_COL_LCD; j++)
    110                    {
    111                      if (
    112                          ((j < col_begin) ||  (j > col_end )) &&
    113                          (j != (col_end + 2))
    114                         )working_ekran[i][j] = ' ';
    115                      else if (j == col_comma )working_ekran[i][j] = ',';
    116                      else if (j == (col_end + 2)) working_ekran[i][j] = odynyci_vymirjuvannja[index_language][INDEX_SECOND];
    117                      else
    118                        calc_symbol_and_put_into_working_ekran((working_ekran[i] + j), &value, &vaga, &first_symbol, j, col_comma, 0);
    119                    }
    120                  }
    121                  
    122                }
    123                else
    124                  for (size_t j = 0; j < MAX_COL_LCD; j++) working_ekran[i][j] = ' ';
    125          
    126                index_in_ekran++;
    127              }
    128          
    129              //Відображення курору по вертикалі і курсор завжди має бути у полі із значенням устаки
    130              current_state_menu2.position_cursor_y = ((position_temp<<1) + 1) & (MAX_ROW_LCD - 1);
    131              //Курсор по горизонталі відображається на першому символі у випадку, коли ми не в режимі редагування, інакше позиція буде визначена у функцї main_manu_function_ver2
    132              if (current_state_menu2.edition <= ED_CAN_BE_EDITED)
    133              {
    134                int last_position_cursor_x = MAX_COL_LCD;
    135                switch (current_state_menu2.index_position)
    136                {
    137                case TIMER_SET_DELAY_PAUSE:
    138                  {
    139                    current_state_menu2.position_cursor_x = COL_DELAY_TIMER_PAUSE_BEGIN;
    140                    last_position_cursor_x = COL_DELAY_TIMER_PAUSE_END;
    141                    break;
    142                  }
    143                case TIMER_SET_DELAY_WORK:
    144                  {
    145                    current_state_menu2.position_cursor_x = COL_DELAY_TIMER_WORK_BEGIN;
    146                    last_position_cursor_x = COL_DELAY_TIMER_WORK_END;
    147                    break;
    148                  }
    149                }
    150          
    151                //Підтягуємо курсор до першого символу
    152                while (
    153                       ((working_ekran[current_state_menu2.position_cursor_y][current_state_menu2.position_cursor_x + 1]) == ' ') && 
    154                       (current_state_menu2.position_cursor_x < (last_position_cursor_x -1))
    155                       )
    156                {
    157                  current_state_menu2.position_cursor_x++;
    158                }
    159          
    160                //Курсор ставимо так, щоб він був перед числом
    161                if (
    162                    ((working_ekran[current_state_menu2.position_cursor_y][current_state_menu2.position_cursor_x]) != ' ') && 
    163                    (current_state_menu2.position_cursor_x > 0)
    164                   )
    165                {
    166                  current_state_menu2.position_cursor_x--;
    167                }
    168              }
    169              //Курсор видимий
    170              current_state_menu2.cursor_on = 1;
    171              //Курсор не мигає
    172              if(current_state_menu2.edition <= ED_CAN_BE_EDITED) current_state_menu2.cursor_blinking_on = 0;
    173              else current_state_menu2.cursor_blinking_on = 1;
    174            }
    175            //Обновити повністю весь екран
    176            current_state_menu2.current_action = ACTION_WITH_CARRENT_EKRANE_FULL_UPDATE;
    177          }
    178          /*****************************************************/
    179          
    180          /*****************************************************/
    181          /*
    182          Натискування Enter у вікні відображення витримок багатофункціональних таймерів
    183          */
    184          /*****************************************************/
    185          enum _result_pressed_enter_during_edition press_enter_in_delay_timer(void)
    186          {
    187            enum _result_pressed_enter_during_edition result = RPEDE_NONE;
    188            switch (current_state_menu2.edition)
    189            {
    190            case ED_VIEWING:
    191            case ED_CAN_BE_EDITED:
    192              {
    193                switch (current_state_menu2.index_position)
    194                {
    195                case TIMER_SET_DELAY_PAUSE:
    196                  {
    197                    current_state_menu2.position_cursor_x = COL_DELAY_TIMER_PAUSE_BEGIN;
    198                    break;
    199                  }
    200                case TIMER_SET_DELAY_WORK:
    201                  {
    202                    current_state_menu2.position_cursor_x = COL_DELAY_TIMER_WORK_BEGIN;
    203                    break;
    204                  }
    205                }
    206                break;
    207              }
    208            case ED_EDITION:
    209              {
    210                //Перевіряємо, чи дані рельно змінилися
    211                result = RPEDE_DATA_NOT_CHANGED;
    212                
    213                __settings_for_TIMER *p_settings_for_timer_edit = (((__settings_for_TIMER*)sca_of_p_edit[ID_FB_TIMER - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection);
    214                __settings_for_TIMER *p_settings_for_timer_cont = (((__settings_for_TIMER*)sca_of_p[ID_FB_TIMER - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection);
    215                switch (current_state_menu2.index_position)
    216                {
    217                case TIMER_SET_DELAY_PAUSE:
    218                  {
    219                    if (p_settings_for_timer_cont->set_delay[TIMER_SET_DELAY_PAUSE] != p_settings_for_timer_edit->set_delay[TIMER_SET_DELAY_PAUSE]) 
    220                    {
    221                      if (check_data_setpoint(p_settings_for_timer_edit->set_delay[TIMER_SET_DELAY_PAUSE], TIMEOUT_TIMER_PAUSE_MIN, TIMEOUT_TIMER_PAUSE_MAX) == 1)
    222                      {
    223                        p_settings_for_timer_cont->set_delay[TIMER_SET_DELAY_PAUSE] = p_settings_for_timer_edit->set_delay[TIMER_SET_DELAY_PAUSE];
    224                        config_settings_modified |= MASKA_CHANGED_SETTINGS;
    225                        result = RPEDE_DATA_CHANGED_OK;
    226                      }
    227                      else result = RPEDE_DATA_CHANGED_OUT_OF_RANGE;
    228                    }
    229          
    230                    break;
    231                  }
    232                case TIMER_SET_DELAY_WORK:
    233                  {
    234                    if (p_settings_for_timer_cont->set_delay[TIMER_SET_DELAY_WORK] != p_settings_for_timer_edit->set_delay[TIMER_SET_DELAY_WORK]) 
    235                    {
    236                      if (check_data_setpoint(p_settings_for_timer_edit->set_delay[TIMER_SET_DELAY_WORK], TIMEOUT_TIMER_WORK_MIN, TIMEOUT_TIMER_WORK_MAX) == 1)
    237                      {
    238                        p_settings_for_timer_cont->set_delay[TIMER_SET_DELAY_WORK] = p_settings_for_timer_edit->set_delay[TIMER_SET_DELAY_WORK];
    239                        config_settings_modified |= MASKA_CHANGED_SETTINGS;
    240                        result = RPEDE_DATA_CHANGED_OK;
    241                      }
    242                      else result = RPEDE_DATA_CHANGED_OUT_OF_RANGE;
    243                    }
    244          
    245                    break;
    246                  }
    247                }
    248          
    249                break;
    250              }
    251            }
    252            
    253            return result;
    254          }
    255          /*****************************************************/
    256          
    257          /*****************************************************/
    258          /*
    259          Натискування ESC у вікні витримок багатофункціональних таймерів
    260          */
    261          /*****************************************************/
    262          void press_esc_in_delay_timer(void)
    263          {
    264            __settings_for_TIMER *p_settings_for_timer_edit = (((__settings_for_TIMER*)sca_of_p_edit[ID_FB_TIMER - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection);
    265            __settings_for_TIMER *p_settings_for_timer_cont = (((__settings_for_TIMER*)sca_of_p[ID_FB_TIMER - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection);
    266            switch (current_state_menu2.index_position)
    267            {
    268            case TIMER_SET_DELAY_PAUSE:
    269              {
    270                p_settings_for_timer_edit->set_delay[TIMER_SET_DELAY_PAUSE] = p_settings_for_timer_cont->set_delay[TIMER_SET_DELAY_PAUSE];
    271                break;
    272              }
    273            case TIMER_SET_DELAY_WORK:
    274              {
    275                p_settings_for_timer_edit->set_delay[TIMER_SET_DELAY_WORK] = p_settings_for_timer_cont->set_delay[TIMER_SET_DELAY_WORK];
    276                break;
    277              }
    278            }
    279          }
    280          /*****************************************************/
    281          
    282          /*****************************************************/
    283          //Зміна витримок БФ-таймерів
    284          /*****************************************************
    285          Вхідні параметри
    286          (1 << BIT_KEY_DOWN) - натснуто кнопку вниз
    287          (1 << BIT_KEY_UP)   - атиснуто кнопку вверх
    288          (1 << BIT_KEY_RIGHT)- натснуто кнопку праворуч
    289          (1 << BIT_KEY_LEFT) - атиснуто кнопку ліворуч
    290          
    291          Вхідні параметри
    292            Немає
    293          *****************************************************/
    294          void change_delay_timer(unsigned int action)
    295          {
    296            //Вводимо число у відповідне поле
    297            if (action & ((1 << BIT_KEY_DOWN) | (1 << BIT_KEY_UP)))
    298            {
    299              int32_t *p_value = (((__settings_for_TIMER*)sca_of_p_edit[ID_FB_TIMER - _ID_FB_FIRST_VAR]) + current_state_menu2.number_selection)->set_delay;
    300              unsigned int col_end, col_comma;
    301              switch (current_state_menu2.index_position)
    302              {
    303              case TIMER_SET_DELAY_PAUSE:
    304                {
    305                  col_end = COL_DELAY_TIMER_PAUSE_END;
    306                  col_comma = COL_DELAY_TIMER_PAUSE_COMMA;
    307                  break;
    308                }
    309              case TIMER_SET_DELAY_WORK:
    310                {
    311                  col_end = COL_DELAY_TIMER_WORK_END;
    312                  col_comma = COL_DELAY_TIMER_WORK_COMMA;
    313                  break;
    314                }
    315              }
    316              
    317              intptr_t index = current_state_menu2.index_position;
    318              p_value[index] = edit_setpoint(((action & (1 << BIT_KEY_UP)) != 0), p_value[index], 1, col_comma, col_end, 10);
    319            }
    320            else if (
    321                     ((action & (1 << BIT_KEY_LEFT )) != 0) ||
    322                     ((action & (1 << BIT_KEY_RIGHT)) != 0)
    323                    )   
    324            {
    325              int col_begin, col_end, col_comma;
    326              switch (current_state_menu2.index_position)
    327              {
    328              case TIMER_SET_DELAY_PAUSE:
    329                {
    330                  col_begin = COL_DELAY_TIMER_PAUSE_BEGIN;
    331                  col_end = COL_DELAY_TIMER_PAUSE_END;
    332                  col_comma = COL_DELAY_TIMER_PAUSE_COMMA;
    333                  break;
    334                }
    335              case TIMER_SET_DELAY_WORK:
    336                {
    337                  col_begin = COL_DELAY_TIMER_WORK_BEGIN;
    338                  col_end = COL_DELAY_TIMER_WORK_END;
    339                  col_comma = COL_DELAY_TIMER_WORK_COMMA;
    340                  break;
    341                }
    342              }
    343              
    344              if (action & (1 << BIT_KEY_LEFT ))
    345              {
    346                current_state_menu2.position_cursor_x--;
    347                if (current_state_menu2.position_cursor_x == col_comma )current_state_menu2.position_cursor_x--;
    348                if ((current_state_menu2.position_cursor_x < col_begin) ||
    349                    (current_state_menu2.position_cursor_x > col_end))
    350                  current_state_menu2.position_cursor_x = col_end;
    351              }
    352              else
    353              {
    354                current_state_menu2.position_cursor_x++;
    355                if (current_state_menu2.position_cursor_x == col_comma )current_state_menu2.position_cursor_x++;
    356                if ((current_state_menu2.position_cursor_x < col_begin) ||
    357                    (current_state_menu2.position_cursor_x > col_end))
    358                  current_state_menu2.position_cursor_x = col_begin;
    359              }
    360              
    361            }
    362          }
    363          /*****************************************************/
    364          
    365          /*****************************************************/
    366          //
    367          /*****************************************************/
    368          /*****************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   change_delay_timer
        32   -> edit_setpoint
     344   make_ekran_delay_timer
       344   -> __aeabi_memcpy4
       344   -> calc_symbol_and_put_into_working_ekran
       344   -> index_language_in_array
       344   -> make_ekran_about_info
       344   -> select_struct_settings_fix
      16   press_enter_in_delay_timer
        16   -> check_data_setpoint
       0   press_esc_in_delay_timer


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable3
       4  ??DataTable3_1
       4  ??DataTable3_10
       4  ??DataTable3_11
       4  ??DataTable3_2
       4  ??DataTable3_3
       4  ??DataTable3_4
       4  ??DataTable3_5
       4  ??DataTable3_6
       4  ??DataTable3_7
       4  ??DataTable3_8
       4  ??DataTable3_9
      68  ?_0
      68  ?_1
     136  ?_2
     260  change_delay_timer
     702  make_ekran_delay_timer
     200  press_enter_in_delay_timer
      52  press_esc_in_delay_timer

 
   272 bytes in section .rodata
 1 262 bytes in section .text
 
 1 262 bytes of CODE  memory
   272 bytes of CONST memory

Errors: none
Warnings: none
