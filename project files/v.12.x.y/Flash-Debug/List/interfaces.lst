###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       24/Mar/2017  12:54:55
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\interfaces.c
#    Command line =  
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\interfaces.c" -D USE_STDPERIPH_DRIVER -D STM32F2XX -D
#        USE_USB_OTG_FS -D KEYBOARD_VER_1 -D SYSTEM_VIEWER_ENABLE -lc
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List" --remarks -o
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --enable_multibytes --fpu=None
#        --dlib_config G:\PRG\IAR7_50_2\arm\INC\c\DLib_Config_Full.h -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\usb\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_OTG_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Core\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\"
#        -I "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\Config\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\OS\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\SEGGER\" -On --use_c++_inline
#        --require_prototypes -I G:\PRG\IAR7_50_2\arm\CMSIS\Include\ -D
#        ARM_MATH_CM3
#    List file    =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List\interfaces.lst
#    Object file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj\interfaces.o
#
###############################################################################

G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working files\src\interfaces.c
      1          #include "header.h"
      2          
      3          /***********************************************************************************/
      4          //Програма періодичного сканування USB і організації обміну даними
      5          /***********************************************************************************/
      6          void Usb_routines(void)
      7          {
      8            if (USB_OTG_dev.dev.device_status != USB_OTG_CONFIGURED)
      9            {
     10              data_usb_transmiting = false;
     11              return;
     12            }
     13            
     14            if (data_usb_transmiting == true)
     15            {
     16              if(USB_Tx_State != 1)
     17              {
     18                int usb_transmiting_count_tmp = usb_transmiting_count;
     19                usb_transmiting_count = 0;
     20                data_usb_transmiting = false;
     21                
     22                APP_FOPS.pIf_DataTx(usb_transmiting, usb_transmiting_count_tmp);
     23              }
     24            }
     25            else if (count_out != 0)
     26            {
     27              //Фіксуємо значення таймеру TIM4 у якго період тактування 10 мкс
     28              uint16_t current_count_tim4_USB = ((uint16_t)TIM4->CNT);
     29              uint16_t delta_USB = 0;//По замовчуванню 0, щоб коли прийде нова порція даних не обраховувати різницю, якщо і так зрозуміло, що вона рівна 0
     30              
     31              //Перевіряємо чи зафіксовані прийняті нові дані - і якщо так, то фіксуємо значення таймеру TIM4
     32              if (count_out_previous != count_out)
     33              {
     34                previous_count_tim4_USB = current_count_tim4_USB;
     35                count_out_previous = count_out;
     36              }
     37              else
     38              {
     39                //Після отаннього разу коли ми виконували цю частину коду - нової порції інформації не було отримано
     40                
     41                //Визначаємо скільки часу не отримуються нові дані по USB
     42                if (current_count_tim4_USB >= previous_count_tim4_USB) delta_USB = current_count_tim4_USB - previous_count_tim4_USB;
     43                else delta_USB = (0x10000 - previous_count_tim4_USB) + current_count_tim4_USB; //0x10000 - це повний період таймера, бо ми настроїли його тактуватиу інтервалі [0; 65535]
     44              }
     45              
     46              if (delta_USB > 188) /*1 - відповідає 10 мкс, бо TIM4 настроєний з тактуванням 10 мкс. 188 віщдповідає тоді 1880 мкс. 1880 мк це час 1,5 символа на швидкості 9600 у форматі 1-start + 8-data + pare + 2-stop*/
     47              {
     48                //Копіюємо кількість прийнятої інформації
     49                usb_received_count = count_out;
     50                //Повідомляємо драйверу USB - що можна починати прийом з початку
     51                count_out = 0;
     52                count_out_previous = 0; 
     53                
     54                //Перевіряємо чи ми можемо такий великий масив опрацьовувати
     55                if (
     56                    (usb_received_count > 0) && /*Теоретично ця умова мала б завжди виконуватися*/
     57                    (usb_received_count <= BUFFER_USB)
     58                   )   
     59                {
     60                  //Копіюємо отримані дані у робочий масив
     61                  for (int i = 0; i < usb_received_count; i++) usb_received[i] = buffer_out[i];
     62                  //Орацювання даних по протоколу MODBUS-RTU прийнятих з USB
     63                  modbus_rountines(USB_RECUEST);
     64                }
     65                else
     66                {
     67                  //Цей пакет не можливо орпацювати - тому просто починаємо очікувати новий пакет
     68                  usb_received_count = 0;
     69                }
     70              }
     71            }
     72          }  
     73          /***********************************************************************************/
     74          
     75          /***********************************************************************************/
     76          //Настройка/перенастройка USART для RS-485
     77          /***********************************************************************************/
     78          void USART_RS485_Configure(void)
     79          {
     80            USART_InitTypeDef USART_InitStructure;
     81          
     82            unsigned int baud_RS485;
     83            switch (settings_fix.baud_RS485)
     84            {
     85            case 0:
     86              {
     87                baud_RS485 = 9600;
     88                break;
     89              }
     90            case 1:
     91              {
     92                baud_RS485 = 14400;
     93                break;
     94              }
     95            case 2:
     96              {
     97                baud_RS485 = 19200;
     98                break;
     99              }
    100            case 3:
    101              {
    102                baud_RS485 = 28800;
    103                break;
    104              }
    105            case 4:
    106              {
    107                baud_RS485 = 38400;
    108                break;
    109              }
    110            case 5:
    111              {
    112                baud_RS485 = 57600;
    113                break;
    114              }
    115            default:
    116              {
    117                baud_RS485 = 115200;
    118                break;
    119              }
    120            }
    121            
    122            unsigned int pare_RS485;
    123            switch (settings_fix.pare_bit_RS485)
    124            {
    125            case 0:
    126              {
    127                pare_RS485 = USART_Parity_No;
    128                break;
    129              }
    130            case 1:
    131              {
    132                pare_RS485 = USART_Parity_Odd;
    133                break;
    134              }
    135            default:
    136              {
    137                pare_RS485 = USART_Parity_Even;
    138                break;
    139              }
    140            }
    141          
    142            //Переводимо мікросхкму на прийом
    143            GPIO_485DE->BSRRH = GPIO_PIN_485DE;
    144          
    145            //Забороняємо генерацію переривань
    146            USART_ITConfig(USART_RS485, USART_IT_TC, DISABLE);
    147            USART_ITConfig(USART_RS485, USART_IT_IDLE, DISABLE);
    148            USART_ITConfig(USART_RS485, USART_IT_LBD, DISABLE);
    149            USART_ITConfig(USART_RS485, USART_IT_PE, DISABLE);
    150            USART_ITConfig(USART_RS485, USART_IT_ERR, DISABLE);
    151          
    152            //Зупиняємо потік DMA_Tx якщо він запущений
    153            if ((DMA_StreamRS485_Tx->CR & (uint32_t)DMA_SxCR_EN) !=0) DMA_StreamRS485_Tx->CR &= ~(uint32_t)DMA_SxCR_EN;
    154            DMA_StreamRS485_Tx->NDTR = 0;
    155            //Забороняємо передачу через DMA, якщо він дозволений
    156            if ((USART_RS485->CR3 & USART_DMAReq_Tx) != 0) USART_RS485->CR3 &= (uint16_t)((~(uint32_t)USART_DMAReq_Tx) & 0xffff);
    157            // Очищаємо прапореці, що сигналізує про завершення передачі даних для DMA1 по потоку TX 
    158            DMA_ClearFlag(DMA_StreamRS485_Tx, DMA_FLAG_TCRS485_Tx | DMA_FLAG_HTRS485_Tx | DMA_FLAG_TEIRS485_Tx | DMA_FLAG_DMEIRS485_Tx | DMA_FLAG_FEIRS485_Tx);
    159          
    160            //Зупиняємо потік DMA_Rx якщо він запущений
    161            if ((DMA_StreamRS485_Rx->CR & (uint32_t)DMA_SxCR_EN) !=0) DMA_StreamRS485_Rx->CR &= ~(uint32_t)DMA_SxCR_EN;
    162            DMA_StreamRS485_Rx->NDTR = BUFFER_RS485;
    163            //Забороняємо передачу через DMA, якщо він дозволений
    164            if ((USART_RS485->CR3 & USART_DMAReq_Rx) != 0) USART_RS485->CR3 &= (uint16_t)((~(uint32_t)USART_DMAReq_Rx) & 0xffff);
    165            // Очищаємо прапореці, що сигналізує про завершення передачі даних для DMA1 по потоку RX 
    166            DMA_ClearFlag(DMA_StreamRS485_Rx, DMA_FLAG_TCRS485_Rx | DMA_FLAG_HTRS485_Rx | DMA_FLAG_TEIRS485_Rx | DMA_FLAG_DMEIRS485_Rx | DMA_FLAG_FEIRS485_Rx);
    167            
    168            //Скидаємо кількість прийнятих байт
    169            RxBuffer_RS485_count = 0;
    170          
    171            //Зумпиняємо USART
    172            USART_RS485->CR1 &= (uint16_t)(~USART_CR1_UE);
    173          
    174            //Заповняємо структуру
    175            USART_InitStructure.USART_BaudRate = baud_RS485;
    176            if (pare_RS485 == USART_Parity_No) USART_InitStructure.USART_WordLength = USART_WordLength_8b;
    177            else USART_InitStructure.USART_WordLength = USART_WordLength_9b;
    178            if (settings_fix.number_stop_bit_RS485 == 0) USART_InitStructure.USART_StopBits = USART_StopBits_1;
    179            else USART_InitStructure.USART_StopBits = USART_StopBits_2; 
    180            USART_InitStructure.USART_Parity = pare_RS485;
    181            USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
    182            USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
    183            
    184            //Виконуємо конфігупацію USART_RS485
    185            USART_Init(USART_RS485, &USART_InitStructure);
    186          
    187            //Дозволяємо передачу через DMA
    188            USART_RS485->CR3 |= USART_DMAReq_Rx;
    189            USART_RS485->CR3 |= USART_DMAReq_Tx;
    190          
    191            //Дозволяємо переривання від USART для RS-485 при фіксації помикли
    192            USART_ITConfig(USART_RS485, USART_IT_IDLE, ENABLE);
    193            USART_ITConfig(USART_RS485, USART_IT_LBD, ENABLE);
    194            USART_ITConfig(USART_RS485, USART_IT_PE, ENABLE);
    195            USART_ITConfig(USART_RS485, USART_IT_ERR, ENABLE);
    196          
    197            //Дозволяємо USART_RS485
    198            USART_RS485->CR1 |= USART_CR1_UE;
    199          }
    200          /***********************************************************************************/
    201          
    202          /***********************************************************************************/
    203          //Відновлення моніторингу каналу RS-485
    204          /***********************************************************************************/
    205          void restart_monitoring_RS485(void)
    206          {
    207            //Скидуємо всі можливі помилки
    208            USART_RS485->SR;
    209            (unsigned short int)(USART_RS485->DR & (uint16_t)0x01FF);
    210                
    211            if ((DMA_StreamRS485_Rx->CR & (uint32_t)DMA_SxCR_EN) !=0) DMA_StreamRS485_Rx->CR &= ~(uint32_t)DMA_SxCR_EN;
    212          
    213            // Очищаємо прапореці, що сигналізує про завершення передачі даних для DMA1 по каналу RS-485_RX 
    214            DMA_ClearFlag(DMA_StreamRS485_Rx, DMA_FLAG_TCRS485_Rx | DMA_FLAG_HTRS485_Rx | DMA_FLAG_TEIRS485_Rx | DMA_FLAG_DMEIRS485_Rx | DMA_FLAG_FEIRS485_Rx);
    215          
    216            DMA_StreamRS485_Rx->NDTR = BUFFER_RS485;
    217            RxBuffer_RS485_count_previous = 0;
    218            RxBuffer_RS485_count = 0;
    219            //Запускаємо очікування прийому
    220            DMA_StreamRS485_Rx->CR |= (uint32_t)DMA_SxCR_EN;
    221          }
    222          /***********************************************************************************/
    223          
    224          /***********************************************************************************/
    225          //
    226          /***********************************************************************************/
    227          /***********************************************************************************/

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
      32   USART_RS485_Configure
        32   -> DMA_ClearFlag
        32   -> USART_ITConfig
        32   -> USART_Init
      16   Usb_routines
        16   -- Indirect call
        16   -> modbus_rountines
       8   restart_monitoring_RS485
         8   -> DMA_ClearFlag


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_10
       4  ??DataTable2_11
       4  ??DataTable2_12
       4  ??DataTable2_13
       4  ??DataTable2_14
       4  ??DataTable2_15
       4  ??DataTable2_16
       4  ??DataTable2_17
       4  ??DataTable2_18
       4  ??DataTable2_19
       4  ??DataTable2_2
       4  ??DataTable2_20
       4  ??DataTable2_21
       4  ??DataTable2_22
       4  ??DataTable2_23
       4  ??DataTable2_24
       4  ??DataTable2_25
       4  ??DataTable2_26
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
       4  ??DataTable2_7
       4  ??DataTable2_8
       4  ??DataTable2_9
     478  USART_RS485_Configure
     220  Usb_routines
      76  restart_monitoring_RS485

 
 882 bytes in section .text
 
 882 bytes of CODE memory

Errors: none
Warnings: none
