///////////////////////////////////////////////////////////////////////////////
//
// IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM      24/Mar/2017  12:55:00
// Copyright 1999-2015 IAR Systems AB.
//
//    Cpu mode     =  thumb
//    Endian       =  little
//    Source file  =  
//        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
//        files\v_A_shm\Shematic.cpp
//    Command line =  
//        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
//        files\v_A_shm\Shematic.cpp" -D USE_STDPERIPH_DRIVER -D STM32F2XX -D
//        USE_USB_OTG_FS -D SYSTEM_VIEWER_ENABLE -lc
//        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
//        files\v.12.x.y\Flash-Debug\List" -lB
//        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
//        files\v.12.x.y\Flash-Debug\List" --remarks -o
//        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
//        files\v.12.x.y\Flash-Debug\Obj" --no_cse --no_unroll --no_inline
//        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
//        --endian=little --cpu=Cortex-M3 -e --enable_multibytes --fpu=None
//        --dlib_config G:\PRG\IAR7_50_2\arm\INC\c\DLib_Config_Full.h -I
//        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
//        files\v.12.x.y\..\..\working files\inc\" -I
//        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
//        files\v.12.x.y\..\..\working files\usb\" -I
//        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
//        files\v.12.x.y\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include\" -I
//        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
//        files\v.12.x.y\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I
//        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
//        files\v.12.x.y\..\..\Libraries\STM32_USB_OTG_Driver\inc\" -I
//        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
//        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Core\inc\" -I
//        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
//        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\"
//        -I "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
//        files\v.12.x.y\..\..\SystemView\Config\" -I
//        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
//        files\v.12.x.y\..\..\SystemView\OS\" -I
//        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
//        files\v.12.x.y\..\..\SystemView\SEGGER\" -On --eec++ -I
//        G:\PRG\IAR7_50_2\arm\CMSIS\Include\ -D ARM_MATH_CM3
//    List file    =  
//        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
//        files\v.12.x.y\Flash-Debug\List\Shematic.s
//
///////////////////////////////////////////////////////////////////////////////

        #define SHT_PROGBITS 0x1
        #define SHT_INIT_ARRAY 0xe

        EXTERN _Z10AND_Op_8_1Pv
        EXTERN _Z10READ_DI_OpPv
        EXTERN _Z10SET_LED_OpPv
        EXTERN _Z10SET_OUT_OpPv
        EXTERN _Z6Mft_OpPv
        EXTERN _Z7Null_OPPv
        EXTERN _ZN10CLUAnd_8_1C1Ecc
        EXTERN _ZN10CLUAnd_8_1D1Ev
        EXTERN _ZN10CLUNot_1_1C1Ecc
        EXTERN _ZN10CLUNot_1_1D1Ev
        EXTERN _ZN10CLUXor_8_1C1Ecc
        EXTERN _ZN10CLUXor_8_1D1Ev
        EXTERN _ZN11CLUDout_1_0C1Ecc
        EXTERN _ZN11CLUDout_1_0D1Ev
        EXTERN _ZN13CLUDInput_0_1C1Ecc
        EXTERN _ZN13CLUDInput_0_1D1Ev
        EXTERN _ZN4CMft10UpdateCMftEv
        EXTERN _ZN4CMft13LinkMftTimersEv
        EXTERN _ZN4CMftC1Ecc
        EXTERN _ZN4CMftD1Ev
        EXTERN _ZN6CLULedC1Ecc
        EXTERN _ZN6CLULedD1Ev
        EXTERN _ZN7CLUBase14SetOrderNumberEv
        EXTERN _ZN9CLUOr_8_1C1Ecc
        EXTERN _ZN9CLUOr_8_1D1Ev
        EXTERN __aeabi_atexit
        EXTERN __aeabi_memcpy
        EXTERN __dso_handle
        EXTERN __time32
        EXTERN rand
        EXTERN srand

        PUBLIC DoCalcWrp
        PUBLIC GlobalObjectMap
        PUBLIC InitSchematic
        PUBLIC LL_CryaCrya
        PUBLIC _Z10ResetarNumv
        PUBLIC _Z8GetHIDLUPvl
        PUBLIC _ZN8Shematic11EvalSizeObjEl
        PUBLIC _ZN8Shematic11printResultEv
        PUBLIC _ZN8Shematic12SetupLULinksEPv
        PUBLIC _ZN8Shematic15GetTrueOrderNumEv
        PUBLIC _ZN8Shematic16CreateTestSchemaEv
        PUBLIC _ZN8Shematic16PrintPointsStateEv
        PUBLIC _ZN8Shematic16SetupCircutLinksEPv
        PUBLIC _ZN8Shematic17DetectCircutLinksEv
        PUBLIC _ZN8Shematic19SetupCLUInternalRefEPv
        PUBLIC _ZN8Shematic20FillSBitFld_LUInInfoEPvS0_
        PUBLIC _ZN8Shematic20SetupCLULedStngParamEPv
        PUBLIC _ZN8Shematic23SetupCLUOr_8_1StngParamEPv
        PUBLIC _ZN8Shematic24SetupCLUAnd_8_1StngParamEPv
        PUBLIC _ZN8Shematic24SetupCLUMft_2_1StngParamEPv
        PUBLIC _ZN8Shematic24SetupCLUNot_1_1StngParamEPv
        PUBLIC _ZN8Shematic24SetupCLUXor_8_1StngParamEPv
        PUBLIC _ZN8Shematic25ChangeRelativeOnEvalLinksEv
        PUBLIC _ZN8Shematic25ChangeStngOrdnumRelOnBaseEl
        PUBLIC _ZN8Shematic25SetupCLUDout_1_0StngParamEPv
        PUBLIC _ZN8Shematic26EvalIdxinarrLUAreaListElemEl
        PUBLIC _ZN8Shematic27EvalAmtIn_arrLUAreaListElemEl
        PUBLIC _ZN8Shematic27SetupCLUDInput_0_1StngParamEPv
        PUBLIC _ZN8Shematic28EvalIdxibnarrSBitFldCRefInfoEl
        PUBLIC _ZN8Shematic28PrintShematicElemPointsStateEv
        PUBLIC _ZN8Shematic4InitEv
        PUBLIC _ZN8Shematic5Init1Ev
        PUBLIC _ZN8Shematic5Init2Ev
        PUBLIC _ZN8Shematic6DoCalcEv
        PUBLIC _ZN8Shematic8InsertLUElPv
        PUBLIC _ZN8ShematicC1Ev
        PUBLIC _ZN8ShematicC2Ev
        PUBLIC _ZN8ShematicD1Ev
        PUBLIC _ZN8ShematicD2Ev
        PUBLIC ar_n_Output_Dsc
        PUBLIC ar_n_and_Dsc
        PUBLIC ar_n_led_Dsc
        PUBLIC ar_n_output_CRDsc
        PUBLIC ar_n_output_Dsc
        PUBLIC arrSBitFldCRefInfo
        PUBLIC chGblGround
        PUBLIC chGblVcc
        PUBLIC gLUAreaMem
        PUBLIC gblLUAreaAuxVar
        PUBLIC lAmountOccupyMem
        PUBLIC lcUArea
        PUBLIC preSetUP
        PUBLIC sh
        PUBLIC shAmountTotalElem
        PUBLIC shIdxLUnit

// G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working files\v_A_shm\Shematic.cpp
//    1 #ifdef VISUAL_STUDIO
//    2 #include "StdAfx.h"
//    3 #endif
//    4 #include <stdlib.h>
//    5 #include "Shematic.h"
//    6 //#include "StructElem.h"
//    7 #include "BaseInPoint.h"
//    8 #include "InPoint.h"
//    9 #include "ExtPoint.h"
//   10 #include "LUBase.h"
//   11 #include "LUNot_1_1.h"
//   12 #include "LUDInput_0_1.h"
//   13 #include "LUDout_1_0.h"
//   14 #include "LUDInput_0_1.h"
//   15 #include "LULed.h"
//   16 #include "LUAnd_8_1.h"
//   17 #include "LUOr_8_1.h"
//   18 #include "LUXor_8_1.h"
//   19 #include "Mft.h"
//   20 
//   21 //#include <conio.h>
//   22 #include <string.h>
//   23 #include <ctime>
//   24 #include "stng.h"

        SECTION `.data`:DATA:REORDER:NOROOT(2)
        DATA
// __absolute LUOutDsc ar_n_output_Dsc[10]
ar_n_output_Dsc:
        DC16 11, 1
        DC8 1, 0
        DC16 11, 2
        DC8 1, 0
        DC16 11, 3
        DC8 1, 0
        DC16 11, 4
        DC8 1, 0
        DC16 11, 5
        DC8 1, 0
        DC16 11, 1
        DC8 1, 0
        DC16 11, 1
        DC8 1, 0
        DC16 11, 1
        DC8 1, 0
        DC16 11, 1
        DC8 1, 0
        DC16 11, 1
        DC8 1, 0

        SECTION `.data`:DATA:REORDER:NOROOT(2)
        DATA
// __absolute LUOutDsc ar_n_led_Dsc[10]
ar_n_led_Dsc:
        DC16 11, 1
        DC8 1, 0
        DC16 11, 2
        DC8 1, 0
        DC16 11, 3
        DC8 1, 0
        DC16 11, 4
        DC8 1, 0
        DC16 11, 5
        DC8 1, 0
        DC16 11, 1
        DC8 1, 0
        DC16 11, 1
        DC8 1, 0
        DC16 11, 1
        DC8 1, 0
        DC16 11, 1
        DC8 1, 0
        DC16 11, 1
        DC8 1, 0

        SECTION `.data`:DATA:REORDER:NOROOT(2)
        DATA
// __absolute LUOutDsc ar_n_and_Dsc[16]
ar_n_and_Dsc:
        DC16 11, 1
        DC8 1, 0
        DC16 11, 2
        DC8 1, 0
        DC16 11, 3
        DC8 1, 0
        DC16 11, 4
        DC8 1, 0
        DC16 11, 1
        DC8 1, 0
        DC16 11, 1
        DC8 1, 0
        DC16 11, 1
        DC8 1, 0
        DC16 11, 1
        DC8 1, 0
        DC16 11, 1
        DC8 1, 0
        DC16 11, 2
        DC8 1, 0
        DC16 11, 3
        DC8 1, 0
        DC16 11, 4
        DC8 1, 0
        DC16 11, 1
        DC8 1, 0
        DC16 11, 1
        DC8 1, 0
        DC16 11, 1
        DC8 1, 0
        DC16 11, 1
        DC8 1, 0

        SECTION NonZeroIniVars_RAM1:DATA:REORDER:NOROOT(2)
        DATA
// __absolute LUCrossRefDsc ar_n_output_CRDsc[28]
ar_n_output_CRDsc:
        DC16 12, 11, 11, 1
        DC8 1, 0
        DC16 12, 12, 11, 2
        DC8 1, 0
        DC16 12, 13, 11, 3
        DC8 1, 0
        DC16 12, 14, 11, 4
        DC8 1, 0
        DC16 12, 15, 11, 5
        DC8 1, 0
        DC16 12, 16, 11, 6
        DC8 1, 0
        DC16 12, 17, 11, 7
        DC8 1, 0
        DC16 12, 18, 11, 8
        DC8 1, 0
        DC16 12, 19, 11, 9
        DC8 1, 0
        DC16 12, 20, 11, 10
        DC8 1, 0
        DC16 13, 21, 11, 1
        DC8 1, 0
        DC16 13, 22, 11, 2
        DC8 1, 0
        DC16 13, 23, 11, 3
        DC8 1, 0
        DC16 13, 24, 11, 4
        DC8 1, 0
        DC16 13, 25, 11, 5
        DC8 1, 0
        DC16 13, 26, 11, 6
        DC8 1, 0
        DC16 13, 27, 11, 7
        DC8 1, 0
        DC16 13, 28, 11, 8
        DC8 1, 0
        DC16 13, 29, 11, 9
        DC8 1, 0
        DC16 13, 30, 11, 10
        DC8 1, 0
        DC16 4, 31, 11, 1
        DC8 1, 0
        DC16 4, 31, 11, 2
        DC8 1, 0
        DC16 4, 31, 11, 3
        DC8 1, 0
        DC16 4, 31, 11, 4
        DC8 1, 0
        DC16 4, 31, 11, 5
        DC8 1, 0
        DC16 4, 31, 11, 6
        DC8 1, 0
        DC16 4, 31, 11, 7
        DC8 1, 0
        DC16 4, 31, 11, 8
        DC8 1, 0

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DATA
// __absolute SBitFldCRefInfo arrSBitFldCRefInfo[400]
arrSBitFldCRefInfo:
        DS8 3200

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
// static __absolute SBitFld_LUInInfo const ar_n__Output_Dsc[10]
ar_n__Output_Dsc:
        DC8 1, 0, 1, 11, 1, 0, 2, 11, 1, 0, 3, 11, 1, 0, 4, 11, 1, 0, 5, 11, 1
        DC8 0, 1, 11, 1, 0, 1, 11, 1, 0, 1, 11, 1, 0, 1, 11, 1, 0, 1, 11

        SECTION `.data`:DATA:REORDER:NOROOT(2)
        DATA
// __absolute LUInInfoDsc ar_n_Output_Dsc[10]
ar_n_Output_Dsc:
        DC8 1, 0, 1, 11, 1, 0, 2, 11, 1, 0, 3, 11, 1, 0, 4, 11, 1, 0, 5, 11, 1
        DC8 0, 1, 11, 1, 0, 1, 11, 1, 0, 1, 11, 1, 0, 1, 11, 1, 0, 1, 11

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
// static __absolute LUInInfoDsc const ar_n_And_Dsc[160]
ar_n_And_Dsc:
        DC8 1, 0, 1, 11, 1, 0, 2, 11, 1, 0, 3, 11, 1, 0, 4, 11, 1, 0, 5, 11, 1
        DC8 0, 6, 11, 1, 0, 7, 11, 1, 0, 8, 11, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
// static __absolute LUInInfoDsc const ar_n_Or_Dsc[160]
ar_n_Or_Dsc:
        DC8 1, 0, 1, 11, 1, 0, 2, 11, 1, 0, 3, 11, 1, 0, 4, 11, 1, 0, 5, 11, 1
        DC8 0, 6, 11, 1, 0, 7, 11, 1, 0, 8, 11, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
// static __absolute LUInInfoDsc const ar_n_Xor_Dsc[40]
ar_n_Xor_Dsc:
        DC8 1, 0, 1, 11, 1, 0, 2, 11, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.rodata`:CONST:REORDER:NOROOT(2)
        DATA
// static __absolute LUInInfoDsc const ar_n_Not_Dsc[20]
ar_n_Not_Dsc:
        DC8 1, 0, 1, 11, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0

        SECTION `.data`:DATA:REORDER:NOROOT(2)
        DATA
//   25 __CONFIG_CPP preSetUP = {
preSetUP:
        DC32 0, 10, 10, 10, 1, 1, 1, 1, 1, 1, 1, 1
        DC8 2, 2, 2, 2, 2, 2, 2, 2
//   26     0, //uint32_t device_id;
//   27     10, 10, 10,
//   28     1, //uint32_t n_and;
//   29     1, //uint32_t n_or;
//   30     1, //uint32_t n_xor;
//   31     1, //uint32_t n_not;
//   32     1, //uint32_t n_timers;
//   33     1, //uint32_t n_triggers;
//   34     1, //uint32_t n_alarms;
//   35     1, //uint32_t n_meanders;
//   36     2, 2, 2, 2, 2, 2, 2, 2//uint8_t time_config[7+1];
//   37 
//   38 };
//   39 

        SECTION NonZeroIniVars_RAM1:DATA:REORDER:NOROOT(3)
        DATA
//   40 long long LL_CryaCrya @ "NonZeroIniVars_RAM1" = 15;
LL_CryaCrya:
        DC32 15, 0
//   41 

        SECTION NonZeroIniVars_RAM1:DATA:REORDER:NOROOT(2)
        DATA
//   42 UNN_LogicUnitArea gLUAreaMem @ "NonZeroIniVars_RAM1" = {
gLUAreaMem:
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        DC8 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
//   43 
//   44 };
//   45 

        SECTION `.data`:DATA:REORDER:NOROOT(2)
        DATA
//   46 LUAreaAuxVar gblLUAreaAuxVar  = {
gblLUAreaAuxVar:
        DC16 0, 0
        DC32 16376, 8, gLUAreaMem + 3FFFH, 0H
//   47     0, //.short shAmountPlacedLogicUnit;//counter placed
//   48     0, //.short shIdxLUAreaListElem;    //Index LU Area List Elem
//   49     (SIZE_MEM_BLK - sizeof (LUAreaListElem)), sizeof (LUAreaListElem), //.long  lAmountFreeMem, lAmountUsedMem;
//   50      static_cast<void*>( &(gLUAreaMem.chArRamPrgEvt[((SIZE_MEM_BLK) - 1)])),
//   51 	static_cast<void*>(0)
//   52 
//   53 };
//   54 
//   55 
//   56 
//   57 /*
//   58 //Declare 5 Points & 1 struct element
//   59 InPoint ar5Points[TOTAL_POINTS];
//   60 StructElem s3And = StructElem(3);
//   61  */
//   62 

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DATA
//   63 UNN_LogicUnitArea lcUArea;
lcUArea:
        DS8 16384

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
        DATA
//   64 short shAmountTotalElem = 0;
shAmountTotalElem:
        DS8 2

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DATA
//   65 long lAmountOccupyMem = 0;
lAmountOccupyMem:
        DS8 4
//   66 //long lIdxHead
//   67 //long lIdxTail

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
        DATA
//   68 short shIdxLUnit = 0;
shIdxLUnit:
        DS8 2
//   69 //Next List Header
//   70 //Prev List Header
//   71 //Insert function
//   72 //Delete function
//   73 /*
//   74 *	Main Object
//   75 *
//   76 */

        SECTION `.bss`:DATA:REORDER:NOROOT(2)
        DATA
//   77 Shematic sh;
sh:
        DS8 4

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        DATA
//   78 char chGblGround = 0;
chGblGround:
        DS8 1

        SECTION `.data`:DATA:REORDER:NOROOT(0)
        DATA
//   79 char chGblVcc    = 1;
chGblVcc:
        DC8 1
//   80 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// __code __interwork __softfp Shematic::subobject Shematic()
_ZN8ShematicC2Ev:
        PUSH     {R4,LR}
        MOVS     R4,R0
        MOVS     R0,R4
        BL       _ZN8ShematicC1Ev
        POP      {R4,PC}          ;; return

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// __code __interwork __softfp Shematic::subobject ~Shematic()
_ZN8ShematicD2Ev:
        PUSH     {R4,LR}
        MOVS     R4,R0
        MOVS     R0,R4
        BL       _ZN8ShematicD1Ev
        POP      {R4,PC}          ;; return

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// static __intrinsic __interwork __softfp void __sti__routine()
__sti__routine:
        PUSH     {R7,LR}
        LDR.W    R0,??DataTable5
        BL       _ZN8ShematicC1Ev
        LDR.W    R2,??DataTable5_1
        ADR.W    R1,_ZN8ShematicD1Ev
        BL       __aeabi_atexit
        POP      {R0,PC}          ;; return

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   81 Shematic::Shematic(void) {
//   82     //Debug Code
//   83     ar_n_Output_Dsc[0].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_OrdNumOut
//   84             = ar_n__Output_Dsc[0].bfInfo_OrdNumOut;
_ZN8ShematicC1Ev:
        LDR.W    R1,??DataTable5_2
        LDR      R1,[R1, #+0]
        LDR.W    R2,??DataTable5_3
        LDR      R2,[R2, #+0]
        BFI      R2,R1,#+0,#+16
        LDR.W    R1,??DataTable5_3
        STR      R2,[R1, #+0]
//   85     ar_n_Output_Dsc[0].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_OrdNumStng
//   86             = ar_n__Output_Dsc[0].bfInfo_OrdNumStng;
        LDR.W    R1,??DataTable5_2
        LDR      R1,[R1, #+0]
        LSRS     R1,R1,#+16
        LDR.W    R2,??DataTable5_3
        LDR      R2,[R2, #+0]
        BFI      R2,R1,#+16,#+8
        LDR.W    R1,??DataTable5_3
        STR      R2,[R1, #+0]
//   87     ar_n_Output_Dsc[0].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_IdLUStng
//   88             = ar_n__Output_Dsc[0].bfInfo_IdLUStng;
        LDR.W    R1,??DataTable5_2
        LDR      R1,[R1, #+0]
        LSRS     R1,R1,#+24
        LDR.W    R2,??DataTable5_3
        LDR      R2,[R2, #+0]
        BFI      R2,R1,#+24,#+8
        LDR.W    R1,??DataTable5_3
        STR      R2,[R1, #+0]
//   89     //Debug Code 
//   90 	LL_CryaCrya++;
        LDR.W    R1,??DataTable5_4
        LDRD     R2,R3,[R1, #+0]
        ADDS     R2,R2,#+1
        ADCS     R3,R3,#+0
        LDR.W    R1,??DataTable5_4
        STRD     R2,R3,[R1, #+0]
//   91     chInitTerminated = 0;
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
//   92     
//   93 }
        BX       LR               ;; return
//   94 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   95 void Shematic::Init(void) {
_ZN8Shematic4InitEv:
        PUSH     {R4,LR}
        MOVS     R4,R0
//   96 Init2();
        MOVS     R0,R4
        BL       _ZN8Shematic5Init2Ev
//   97 chInitTerminated = 1;
        MOVS     R0,#+1
        STRB     R0,[R4, #+0]
//   98 }
        POP      {R4,PC}          ;; return
//   99 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  100 void Shematic::DoCalc(void) {
_ZN8Shematic6DoCalcEv:
        PUSH     {R4-R7,LR}
        SUB      SP,SP,#+20
        MOVS     R4,R0
//  101 
//  102     register long i, j;
//  103     register void* pv;
//  104 
//  105     struct {
//  106         //long lId,lsizeobj;
//  107         short shAmountCalcLU, shRes;
//  108         void *pV;
//  109         LUAreaListElem* arrLUAreaListElem;
//  110         CLUBase* pCLUBase;
//  111     } sLV;
//  112     sLV.shAmountCalcLU = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
        LDR.W    R0,??DataTable5_5
        LDRSH    R0,[R0, #+0]
        STRH     R0,[SP, #+0]
//  113     sLV.arrLUAreaListElem = &gLUAreaMem.headLUAreaList;
        LDR.W    R0,??DataTable5_6
        STR      R0,[SP, #+8]
//  114     i = 0;
        MOVS     R0,#+0
        MOVS     R5,R0
//  115     if(chInitTerminated == 0)
        LDRB     R0,[R4, #+0]
        CMP      R0,#+0
        BEQ.N    ??DoCalc_0
//  116         return;
//  117     //j = ar_n_Output_Dsc[0].UN_BitFld_LUInInfo.lArUrgData[0];
//  118     //j+= ar_n__Output_Dsc[0].bfInfo_OrdNumOut;
//  119     //j+= ghj.UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_IdLUStng;
//  120     while (sLV.shAmountCalcLU--) {
??DoCalc_1:
        LDRSH    R0,[SP, #+0]
        SUBS     R1,R0,#+1
        STRH     R1,[SP, #+0]
        SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
        CMP      R0,#+0
        BEQ.N    ??DoCalc_2
//  121         pv = reinterpret_cast<void*>( &sLV.arrLUAreaListElem[i]);
        LDR      R0,[SP, #+8]
        ADDS     R0,R0,R5, LSL #+3
        MOVS     R7,R0
//  122         sLV.pCLUBase = reinterpret_cast<CLUBase*>( (reinterpret_cast<LUAreaListElem*> (pv))->pvLU);//(CLUBase*)
        LDR      R0,[R7, #+4]
        STR      R0,[SP, #+12]
//  123         pv = reinterpret_cast<void*>( sLV.pCLUBase); //->LogicFunc;
        LDR      R0,[SP, #+12]
        MOVS     R7,R0
//  124         if ((reinterpret_cast<CLUBase*>( pv))->shShemasOrdNumStng != 0 //&&
//  125                 ) {
        LDRSH    R0,[R7, #+12]
        CMP      R0,#+0
        BEQ.N    ??DoCalc_3
//  126             j = (reinterpret_cast<CLUBase*>( pv))->shShemasIdLUStng;
        LDRSH    R0,[R7, #+10]
        MOVS     R6,R0
//  127             switch (j) {
        CMP      R6,#+3
        BEQ.N    ??DoCalc_3
//  128                 case STNG_EXTENDED:
//  129                     break;
//  130                 default:
//  131                 {
//  132                     if (j > STNG_EXTENDED && j < STNG_LU_UPPER_BOUND) {
??DoCalc_4:
        CMP      R6,#+4
        BLT.N    ??DoCalc_3
        CMP      R6,#+16
        BGE.N    ??DoCalc_3
//  133                         if ((reinterpret_cast<CLUBase*>( pv))->LogicFunc != Null_OP) {
        LDR      R0,[R7, #+16]
        LDR.W    R1,??DataTable5_7
        CMP      R0,R1
        BEQ.N    ??DoCalc_3
//  134                             (reinterpret_cast<CLUBase*>( pv))->LogicFunc( reinterpret_cast<void*>(sLV.pCLUBase));
        LDR      R0,[SP, #+12]
        LDR      R1,[R7, #+16]
        BLX      R1
//  135                         }
//  136 
//  137                     }
//  138                 }
//  139             }
//  140 
//  141         }
//  142         i++;
??DoCalc_3:
        ADDS     R5,R5,#+1
        B.N      ??DoCalc_1
//  143     }
//  144 }
??DoCalc_2:
??DoCalc_0:
        ADD      SP,SP,#+20
        POP      {R4-R7,PC}       ;; return
//  145 

        SECTION `.text`:CODE:NOROOT(2)
        THUMB
//  146 Shematic::~Shematic(void) {
//  147 }
_ZN8ShematicD1Ev:
        BX       LR               ;; return
//  148 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  149 void Shematic::printResult(void) {
//  150     /*    int c = 0;
//  151         long lIdxPoint = NUM_IN_POINTS;
//  152         char chAmtInitPoints = NUM_OUT_POINTS-1;
//  153         InPoint*pInPont = &ar5Points[lIdxPoint];
//  154         printf("Result schematic:\n");
//  155         do{
//  156             printf("State ar5Points[");printf("%hhX %s",lIdxPoint,"]=");
//  157             putchar((int)pInPont ->chState+0x30);printf(" \n");
//  158             lIdxPoint++;
//  159             pInPont = &ar5Points[lIdxPoint];//Next Pointer
//  160 
//  161         }while(chAmtInitPoints--);
//  162         pInPont = &ar5Points[lIdxPoint];
//  163 
//  164         c = getch();*/
//  165 
//  166 }
_ZN8Shematic11printResultEv:
        BX       LR               ;; return
//  167 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  168 void Shematic::PrintPointsState(void) {
//  169     //Print state All Points which Shematic Use
//  170     //Name Logic Unit
//  171 }
_ZN8Shematic16PrintPointsStateEv:
        BX       LR               ;; return
//  172 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  173 void Shematic::PrintShematicElemPointsState(void) {
//  174     //Print Only Points Using?
//  175 }
_ZN8Shematic28PrintShematicElemPointsStateEv:
        BX       LR               ;; return
//  176 
//  177 //void Shematic::SetupCircutLinks(void *pv) {
//  178 //    //register long ik;
//  179 //    Init2LcVarArea& rsLV  = *((Init2LcVarArea*)pv);
//  180 //    rsLV.arrLUAreaListElem = &gLUAreaMem.headLUAreaList;
//  181 //}
//  182 //#ifdef RAND_MAX
//  183 // #define RAND_MAX 256
//  184 //#endif
//  185 //static long first_value,last_value;
//  186 //random_number = first_value + rand() % last_value;

        SECTION ZeroInivars_RAM1:DATA:REORDER:NOROOT(2)
        DATA
//  187 static long arNum[300] @ "ZeroInivars_RAM1";
arNum:
        DS8 1200

        SECTION `.bss`:DATA:REORDER:NOROOT(1)
        DATA
//  188 static short shCounterCalls_GLB;
shCounterCalls_GLB:
        DS8 2

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  189 long Shematic::GetTrueOrderNum(void) {
_ZN8Shematic15GetTrueOrderNumEv:
        PUSH     {R2-R6,LR}
//  190     register long i, j;
//  191 
//  192     struct {
//  193         char chNeedAnotherNumber, chCtrCalls;
//  194     } sLV;
//  195     volatile long random_number;
//  196     sLV.chNeedAnotherNumber = 0;
        MOVS     R0,#+0
        STRB     R0,[SP, #+0]
//  197     srand(time(0));
        MOVS     R6,#+0
        MOVS     R0,R6
        BL       __time32
        BL       srand
//  198     //i = (long) rand() % 255; //255 Max diapason
//  199     i = static_cast<long>(rand() % 255); //255 Max diapason
        BL       rand
        MOVS     R1,#+255
        SDIV     R2,R0,R1
        MLS      R0,R1,R2,R0
        MOVS     R4,R0
//  200 
//  201     random_number = i + 1; //1 - min diapason
        ADDS     R0,R4,#+1
        STR      R0,[SP, #+4]
//  202     sLV.chCtrCalls = 0;
        MOVS     R0,#+0
        STRB     R0,[SP, #+1]
//  203     do {
//  204 
//  205         for (j = 0; j < 300 && arNum[j] != 0; j++) {
??GetTrueOrderNum_0:
        MOVS     R0,#+0
        MOVS     R5,R0
??GetTrueOrderNum_1:
        CMP      R5,#+300
        BGE.N    ??GetTrueOrderNum_2
        LDR.W    R0,??DataTable5_8
        LDR      R0,[R0, R5, LSL #+2]
        CMP      R0,#+0
        BEQ.N    ??GetTrueOrderNum_2
//  206 
//  207             if (random_number == arNum[j]) {
        LDR      R0,[SP, #+4]
        LDR.W    R1,??DataTable5_8
        LDR      R1,[R1, R5, LSL #+2]
        CMP      R0,R1
        BNE.N    ??GetTrueOrderNum_3
//  208                 j = 300;
        MOV      R0,#+300
        MOVS     R5,R0
//  209                 sLV.chNeedAnotherNumber = 1;
        MOVS     R0,#+1
        STRB     R0,[SP, #+0]
//  210                 break;
        B.N      ??GetTrueOrderNum_2
//  211             }
//  212             if(arNum[j+1] == 0){
??GetTrueOrderNum_3:
        LDR.W    R0,??DataTable5_8
        ADDS     R0,R0,R5, LSL #+2
        LDR      R0,[R0, #+4]
        CMP      R0,#+0
        BNE.N    ??GetTrueOrderNum_4
//  213                 sLV.chNeedAnotherNumber = 0;
        MOVS     R0,#+0
        STRB     R0,[SP, #+0]
//  214                 break;
        B.N      ??GetTrueOrderNum_2
//  215             }
//  216         }
??GetTrueOrderNum_4:
        ADDS     R5,R5,#+1
        B.N      ??GetTrueOrderNum_1
//  217         //Another Number
//  218         if (sLV.chNeedAnotherNumber) {
??GetTrueOrderNum_2:
        LDRB     R0,[SP, #+0]
        CMP      R0,#+0
        BEQ.N    ??GetTrueOrderNum_5
//  219             sLV.chCtrCalls++;
        LDRB     R0,[SP, #+1]
        ADDS     R0,R0,#+1
        STRB     R0,[SP, #+1]
//  220             i = static_cast<long>( rand() % 255); //255 Max diapason
        BL       rand
        MOVS     R1,#+255
        SDIV     R2,R0,R1
        MLS      R0,R1,R2,R0
        MOVS     R4,R0
//  221             random_number = i + 1;
        ADDS     R0,R4,#+1
        STR      R0,[SP, #+4]
//  222         }
//  223     } while (sLV.chNeedAnotherNumber && sLV.chCtrCalls < 250);
??GetTrueOrderNum_5:
        LDRB     R0,[SP, #+0]
        CMP      R0,#+0
        BEQ.N    ??GetTrueOrderNum_6
        LDRB     R0,[SP, #+1]
        CMP      R0,#+250
        BLT.N    ??GetTrueOrderNum_0
//  224     if (sLV.chCtrCalls >= 250) {
??GetTrueOrderNum_6:
        LDRB     R0,[SP, #+1]
        CMP      R0,#+250
        BLT.N    ??GetTrueOrderNum_7
//  225         //Clr Mem
//  226         for (j = 0; j < 300; j++)
        MOVS     R0,#+0
        MOVS     R5,R0
??GetTrueOrderNum_8:
        CMP      R5,#+300
        BGE.N    ??GetTrueOrderNum_9
//  227             arNum[j] = 0;
        MOVS     R0,#+0
        LDR.W    R1,??DataTable5_8
        STR      R0,[R1, R5, LSL #+2]
        ADDS     R5,R5,#+1
        B.N      ??GetTrueOrderNum_8
//  228         shCounterCalls_GLB = 0;
??GetTrueOrderNum_9:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable5_9
        STRH     R0,[R1, #+0]
//  229     }
//  230     i = shCounterCalls_GLB;
??GetTrueOrderNum_7:
        LDR.W    R0,??DataTable5_9
        LDRSH    R0,[R0, #+0]
        MOVS     R4,R0
//  231     arNum[i] = random_number;
        LDR      R0,[SP, #+4]
        LDR.W    R1,??DataTable5_8
        STR      R0,[R1, R4, LSL #+2]
//  232     shCounterCalls_GLB = i+1;
        ADDS     R0,R4,#+1
        LDR.W    R1,??DataTable5_9
        STRH     R0,[R1, #+0]
//  233 
//  234     return random_number;
        LDR      R0,[SP, #+4]
        POP      {R1,R2,R4-R6,PC}  ;; return
//  235 }
//  236 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  237 void Shematic::CreateTestSchema(void) {
//  238     /*
//  239     register long i,j;
//  240     void* pv;
//  241     struct
//  242         {
//  243             //short shAmtLU,shIdxLUOut;//
//  244                     long lOrderNumber;
//  245             short shAmtLUDsc,shIdx;
//  246                     short shIdxLUOutDsc, shIdxLU;
//  247                     //SBitFld_LUInInfo locSBitFld;
//  248 		 
//  249         } sLV;
//  250 
//  251 		
//  252             //sLV.locSBitFldCRefInfo = 
//  253             //SetUP DOUT
//  254             //Form Additional Info
//  255             sLV.shAmtLUDsc = preSetUP.n_and;
//  256             sLV.shIdxLUOutDsc = sLV.shIdxLU = sLV.shIdx = 0;// 
//  257             sLV.shIdxLUOutDsc = MAX_AMOUNT_LU_OUTPUT+MAX_AMOUNT_LU_LED;
//  258             //SetUP Led
//  259             //SetUP And
//  260             while(sLV.shIdx < sLV.shAmtLUDsc){
//  261 		
//  262                     sLV.lOrderNumber = GetTrueOrderNum();//Take OrdNum F-Block From Taras Area
//  263                     locSBitFldCRefInfo.bfInfo_OrdNumOut  = 1;//Now use All ones
//  264                     locSBitFldCRefInfo.bfInfo_IdLUStng   = STNG_LU_INPUT;
//  265                     locSBitFldCRefInfo.bfInfo_BaseID     = sLV.lOrderNumber;
//  266                     for (long j = 0; j < 8 ; j++){//Create data for each Input
//  267                             locSBitFldCRefInfo.bfInfo_OrdNumStng = ORD_INPUT_01+j;
//  268                             arrSBitFldCRefInfo[sLV.shIdxLUOutDsc+j] = locSBitFldCRefInfo;
//  269                     }
//  270                     //locSBitFld.bfInfo_OrdNumOut 
//  271                     //locSBitFld.bfInfo_OrdNumStng
//  272                     //locSBitFld.bfInfo_IdLUStng  
//  273             }
//  274 
//  275 	
//  276             //SetUP OR
//  277             sLV.shIdxLUOutDsc = MAX_AMOUNT_LU_OUTPUT+MAX_AMOUNT_LU_LED
//  278             +(MAX_AMOUNT_LU_AND*8);
//  279             sLV.shAmtLUDsc = preSetUP.n_or;sLV.shIdx = 0;
//  280             while(sLV.shIdx < sLV.shAmtLUDsc){
//  281 		
//  282                     sLV.lOrderNumber = GetTrueOrderNum();//Take OrdNum F-Block From Taras Area
//  283                     locSBitFldCRefInfo.bfInfo_OrdNumOut  = 1;//Now use All ones
//  284                     locSBitFldCRefInfo.bfInfo_IdLUStng   = STNG_LU_INPUT;
//  285                     locSBitFldCRefInfo.bfInfo_BaseID     = sLV.lOrderNumber;
//  286                     for (long j = 0; j < 8 ; j++){//Create data for each Input
//  287                             locSBitFldCRefInfo.bfInfo_OrdNumStng = ORD_INPUT_01+j;
//  288                             arrSBitFldCRefInfo[sLV.shIdxLUOutDsc+j] = locSBitFldCRefInfo;
//  289                     }
//  290                     //locSBitFld.bfInfo_OrdNumOut 
//  291                     //locSBitFld.bfInfo_OrdNumStng
//  292                     //locSBitFld.bfInfo_IdLUStng  
//  293             }
//  294             //SetUP XOR
//  295             sLV.shIdxLUOutDsc = MAX_AMOUNT_LU_OUTPUT+MAX_AMOUNT_LU_LED
//  296             +(MAX_AMOUNT_LU_AND*8)+(MAX_AMOUNT_LU_OR*8 );
//  297             sLV.shAmtLUDsc = preSetUP.n_xor;sLV.shIdx = 0;
//  298             while(sLV.shIdx < sLV.shAmtLUDsc){
//  299 		
//  300                     sLV.lOrderNumber = GetTrueOrderNum();//Take OrdNum F-Block From Taras Area
//  301                     locSBitFldCRefInfo.bfInfo_OrdNumOut  = 1;//Now use All ones
//  302                     locSBitFldCRefInfo.bfInfo_IdLUStng   = STNG_LU_INPUT;
//  303                     locSBitFldCRefInfo.bfInfo_BaseID     = sLV.lOrderNumber;
//  304                     for (long j = 0; j < 8 ; j++){//Create data for each Input
//  305                             locSBitFldCRefInfo.bfInfo_OrdNumStng = ORD_INPUT_01+j;
//  306                             arrSBitFldCRefInfo[sLV.shIdxLUOutDsc+j] = locSBitFldCRefInfo;
//  307                     }
//  308                     //locSBitFld.bfInfo_OrdNumOut 
//  309                     //locSBitFld.bfInfo_OrdNumStng
//  310                     //locSBitFld.bfInfo_IdLUStng  
//  311             }
//  312             //SetUP NOT
//  313             sLV.shIdxLUOutDsc = MAX_AMOUNT_LU_OUTPUT+MAX_AMOUNT_LU_LED
//  314             +(MAX_AMOUNT_LU_AND*8)+(MAX_AMOUNT_LU_OR*8 )+(MAX_AMOUNT_LU_XOR*2);
//  315             sLV.shAmtLUDsc = preSetUP.n_not;sLV.shIdx = 0;
//  316             while(sLV.shIdx < sLV.shAmtLUDsc){
//  317 		
//  318                     sLV.lOrderNumber = GetTrueOrderNum();//Take OrdNum F-Block From Taras Area
//  319                     locSBitFldCRefInfo.bfInfo_OrdNumOut  = 1;//Now use All ones
//  320                     locSBitFldCRefInfo.bfInfo_IdLUStng   = STNG_LU_INPUT;
//  321                     locSBitFldCRefInfo.bfInfo_BaseID     = sLV.lOrderNumber;
//  322                     for (long j = 0; j < 8 ; j++){//Create data for each Input
//  323                             locSBitFldCRefInfo.bfInfo_OrdNumStng = ORD_INPUT_01+j;
//  324                             arrSBitFldCRefInfo[sLV.shIdxLUOutDsc+j] = locSBitFldCRefInfo;
//  325                     }
//  326                     //locSBitFld.bfInfo_OrdNumOut 
//  327                     //locSBitFld.bfInfo_OrdNumStng
//  328                     //locSBitFld.bfInfo_IdLUStng  
//  329             }
//  330      */
//  331 }
_ZN8Shematic16CreateTestSchemaEv:
        BX       LR               ;; return
//  332 
//  333 struct GlobalObjectMap_tag {
//  334 
//  335     CLUDInput_0_1 *arPCLUDInput_0_1[MAX_AMOUNT_LU_INPUT]; //NUM_STNG_IN
//  336     CLUDout_1_0   *arPCLUDout_1_0  [MAX_AMOUNT_LU_OUTPUT]; //NUM_STNG_OUT
//  337     CLULed        *arPCLULed       [MAX_AMOUNT_LU_LED]; //NUM_STNG_LED
//  338     CLUNot_1_1    *arPCLUNot_1_1   [MAX_AMOUNT_LU_NOT];
//  339     CLUOr_8_1     *arPCLUOr_8_1    [MAX_AMOUNT_LU_OR];
//  340     CLUAnd_8_1    *arPCLUAnd_8_1   [MAX_AMOUNT_LU_AND];
//  341     CLUXor_8_1    *arPCLUXor_8_1   [MAX_AMOUNT_LU_XOR];
//  342 	CMft          *arCMft          [MAX_AMOUNT_LU_TIMERS];

        SECTION variables_RAM1:DATA:REORDER:NOROOT(2)
        DATA
//  343 } GlobalObjectMap @ "variables_RAM1";
GlobalObjectMap:
        DS8 520
//  344 //Place 3 Unit
//  345 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  346 void Shematic::Init1(void) {
_ZN8Shematic5Init1Ev:
        PUSH     {R4-R9,LR}
        SUB      SP,SP,#+404
        MOVS     R4,R0
//  347     long i, j;
//  348     void* pv;
//  349     //char **pCh;
//  350 
//  351     struct {
//  352         char* pCh;
//  353         char** arrPchIn;
//  354         LUAreaListElem* arrLUAreaListElem;
//  355         CLUBase *pCLUBase, *pCLURef;
//  356         void *pV;
//  357         long lId, lsizeobj;
//  358         short shAmtLU, shIdxLUOut; //
//  359         short shAmtLUDsc, shIdx;
//  360         short shIdxLUOutDsc, shIdxLU; //shCountCmd;
//  361         char chVal, chErrCount, chBrk1, chBrk2;
//  362         //unsigned char uchVal;
//  363     } sLV;
//  364     sLV.shIdx = sLV.shIdxLU = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+42]
        LDRH     R0,[SP, #+42]
        STRH     R0,[SP, #+38]
//  365     sLV.chVal = static_cast<char> (preSetUP.n_input);
        LDR.W    R0,??DetectCircutLinks_0
        LDR      R0,[R0, #+4]
        STRB     R0,[SP, #+44]
//  366     sLV.arrLUAreaListElem = &gLUAreaMem.headLUAreaList;
        LDR.W    R0,??DataTable5_6
        STR      R0,[SP, #+8]
//  367     sLV.chErrCount = sLV.chBrk1 = sLV.chBrk2 = 0;
        MOVS     R0,#+0
        STRB     R0,[SP, #+47]
        STRB     R0,[SP, #+46]
        STRB     R0,[SP, #+45]
//  368     sLV.shIdxLUOutDsc = 1;
        MOVS     R0,#+1
        STRH     R0,[SP, #+40]
//  369     DetectCircutLinks();
        MOVS     R0,R4
        BL       _ZN8Shematic17DetectCircutLinksEv
//  370     if (sLV.chVal) {
        LDRB     R0,[SP, #+44]
        CMP      R0,#+0
        BEQ.N    ??Init1_0
//  371 
//  372         CLUDInput_0_1 locCLUDInput_0_1(10, 0); // = CLUDInput_0_1(0,10);
        MOVS     R2,#+0
        MOVS     R1,#+10
        ADD      R0,SP,#+84
        BL       _ZN13CLUDInput_0_1C1Ecc
//  373         j = i = 0;
        MOVS     R0,#+0
        MOVS     R5,R0
        MOVS     R6,R5
//  374         do {
//  375             j = InsertLU(LU_INPUT, static_cast<void*> (&locCLUDInput_0_1));
??Init1_1:
        ADD      R2,SP,#+84
        MOVS     R1,#+11
        MOVS     R0,R4
        BL       _ZN8Shematic8InsertLUElPv
        MOVS     R6,R0
//  376 
//  377             if (j) {//Success Bield
        CMP      R6,#+0
        BEQ.N    ??Init1_2
//  378                 //Additional Obj SetUP
//  379 
//  380                 i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
        LDR.W    R0,??DataTable5_5
        LDRSH    R0,[R0, #+0]
        MOVS     R5,R0
//  381                 pv = static_cast<void*>( &sLV.arrLUAreaListElem[i - 1]);
        LDR      R0,[SP, #+8]
        ADDS     R0,R0,R5, LSL #+3
        SUBS     R0,R0,#+8
        MOVS     R7,R0
//  382                 sLV.pCLUBase = static_cast<CLUBase*>( ( static_cast<LUAreaListElem*>(pv) )->pvLU);
        LDR      R0,[R7, #+4]
        STR      R0,[SP, #+12]
//  383                 sLV.pCLUBase->shShemasIdLUStng = STNG_LU_INPUT;
        MOVS     R0,#+11
        LDR      R1,[SP, #+12]
        STRH     R0,[R1, #+10]
//  384                 //sLV.uchVal = arrSBitFldCRefInfo[sLV.shIdxLUOutDsc-1].bfInfo_BaseID;
//  385                 sLV.pCLUBase->shShemasOrdNumStng = static_cast<unsigned char>(arrSBitFldCRefInfo[sLV.shIdxLUOutDsc-1].bfInfo_BaseID);
        LDR.W    R0,??DetectCircutLinks_0+0x4
        LDRSH    R1,[SP, #+40]
        ADDS     R0,R0,R1, LSL #+3
        LDR      R0,[R0, #-4]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDR      R1,[SP, #+12]
        STRH     R0,[R1, #+12]
//  386                     sLV.shIdxLUOutDsc++; //Temporary Numeration Discass It!!!!;
        LDRH     R0,[SP, #+40]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+40]
//  387                 CLUDInput_0_1* locPCLUDInput_0_1 = static_cast<CLUDInput_0_1*>(sLV.pCLUBase);
        LDR      R0,[SP, #+12]
//  388                 locPCLUDInput_0_1->pOut = static_cast<void*>( locPCLUDInput_0_1->arrOut);
        ADDS     R1,R0,#+24
        STR      R1,[R0, #+20]
//  389                 CLUDInput_0_1& locRef_CLUDInput_0_1 = *(static_cast<CLUDInput_0_1*>(sLV.pCLUBase));
        LDR      R1,[SP, #+12]
//  390                 locRef_CLUDInput_0_1.chTypeLogicFunction = LU_OP_READ_DI;
        MOVS     R2,#+7
        STRB     R2,[R1, #+8]
//  391                 locRef_CLUDInput_0_1.LogicFunc = READ_DI_Op; //???
        LDR.W    R2,??DataTable5_10
        STR      R2,[R1, #+16]
//  392 
//  393                 GlobalObjectMap.arPCLUDInput_0_1[sLV.shIdx++] = static_cast<CLUDInput_0_1*>(sLV.pCLUBase);
        LDR      R2,[SP, #+12]
        LDR.W    R3,??DataTable5_11
        LDRSH    R12,[SP, #+38]
        STR      R2,[R3, R12, LSL #+2]
        LDRH     R2,[SP, #+38]
        ADDS     R2,R2,#+1
        STRH     R2,[SP, #+38]
//  394                 sLV.shIdxLU++;
        LDRH     R2,[SP, #+42]
        ADDS     R2,R2,#+1
        STRH     R2,[SP, #+42]
//  395             }//Else Error
//  396 
//  397         } while (sLV.shIdxLU < preSetUP.n_input && j);
??Init1_2:
        LDRSH    R0,[SP, #+42]
        LDR.W    R1,??DetectCircutLinks_0
        LDR      R1,[R1, #+4]
        CMP      R0,R1
        BGE.N    ??Init1_3
        CMP      R6,#+0
        BNE.N    ??Init1_1
//  398         //Check State j
//  399     }
??Init1_3:
        ADD      R0,SP,#+84
        BL       _ZN13CLUDInput_0_1D1Ev
//  400     sLV.shIdx = 0;
??Init1_0:
        MOVS     R0,#+0
        STRH     R0,[SP, #+38]
//  401     if (preSetUP.n_output != 0) {
        LDR.W    R0,??DetectCircutLinks_0
        LDR      R0,[R0, #+8]
        CMP      R0,#+0
        BEQ.N    ??Init1_4
//  402         sLV.shIdxLU = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+42]
//  403         j = 0;
        MOVS     R0,#+0
        MOVS     R6,R0
//  404         CLUDout_1_0 locCLUDout_1_0(10, 0); // = CLUDout_1_0(0,10);
        MOVS     R2,#+0
        MOVS     R1,#+10
        ADD      R0,SP,#+340
        BL       _ZN11CLUDout_1_0C1Ecc
//  405         do {
//  406             j = InsertLU(LU_OUTPUT, static_cast<void*> (&locCLUDout_1_0));
??Init1_5:
        ADD      R2,SP,#+340
        MOVS     R1,#+12
        MOVS     R0,R4
        BL       _ZN8Shematic8InsertLUElPv
        MOVS     R6,R0
//  407             if (j) {//Success Bield
        CMP      R6,#+0
        BEQ.N    ??Init1_6
//  408                 //Additional Obj SetUP
//  409                 i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
        LDR.W    R0,??DataTable5_5
        LDRSH    R0,[R0, #+0]
        MOVS     R5,R0
//  410                 pv = static_cast<void*>(&sLV.arrLUAreaListElem[i - 1]);
        LDR      R0,[SP, #+8]
        ADDS     R0,R0,R5, LSL #+3
        SUBS     R0,R0,#+8
        MOVS     R7,R0
//  411                 sLV.pCLUBase = static_cast<CLUBase*>( 
//  412                         (static_cast<LUAreaListElem*>(pv))->pvLU);
        LDR      R0,[R7, #+4]
        STR      R0,[SP, #+12]
//  413                 sLV.pCLUBase->shShemasIdLUStng = STNG_LU_OUTPUT;
        MOVS     R0,#+12
        LDR      R1,[SP, #+12]
        STRH     R0,[R1, #+10]
//  414                 sLV.pCLUBase->shShemasOrdNumStng = arrSBitFldCRefInfo[sLV.shIdxLUOutDsc-1].bfInfo_BaseID;
        LDR.W    R0,??DetectCircutLinks_0+0x4
        LDRSH    R1,[SP, #+40]
        ADDS     R0,R0,R1, LSL #+3
        LDRB     R0,[R0, #-4]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDR      R1,[SP, #+12]
        STRH     R0,[R1, #+12]
//  415                         sLV.shIdxLUOutDsc++; //Temporary Numeration Discass It!!!!;
        LDRH     R0,[SP, #+40]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+40]
//  416                 CLUDout_1_0* locPCLUDout_1_0 = static_cast<CLUDout_1_0*>(sLV.pCLUBase);
        LDR      R0,[SP, #+12]
//  417                 locPCLUDout_1_0->pIn = static_cast<void*> (locPCLUDout_1_0->arrPchIn);
        ADDS     R1,R0,#+24
        STR      R1,[R0, #+0]
//  418                 locPCLUDout_1_0->chTypeLogicFunction = LU_OP_SET_OUT;
        MOVS     R1,#+8
        STRB     R1,[R0, #+8]
//  419                 locPCLUDout_1_0->LogicFunc = SET_OUT_Op; //???
        LDR.W    R1,??DataTable5_12
        STR      R1,[R0, #+16]
//  420 
//  421                 GlobalObjectMap.arPCLUDout_1_0[sLV.shIdx++] = static_cast<CLUDout_1_0*>(sLV.pCLUBase);
        LDR      R1,[SP, #+12]
        LDR.W    R2,??DataTable5_11
        LDRSH    R3,[SP, #+38]
        ADDS     R2,R2,R3, LSL #+2
        STR      R1,[R2, #+40]
        LDRH     R1,[SP, #+38]
        ADDS     R1,R1,#+1
        STRH     R1,[SP, #+38]
//  422                 sLV.shIdxLU++;
        LDRH     R1,[SP, #+42]
        ADDS     R1,R1,#+1
        STRH     R1,[SP, #+42]
//  423             }
//  424 
//  425         } while (sLV.shIdxLU < preSetUP.n_output && j);
??Init1_6:
        LDRSH    R0,[SP, #+42]
        LDR.W    R1,??DetectCircutLinks_0
        LDR      R1,[R1, #+8]
        CMP      R0,R1
        BGE.N    ??Init1_7
        CMP      R6,#+0
        BNE.N    ??Init1_5
//  426     }
??Init1_7:
        ADD      R0,SP,#+340
        BL       _ZN11CLUDout_1_0D1Ev
//  427     sLV.shIdx = 0;
??Init1_4:
        MOVS     R0,#+0
        STRH     R0,[SP, #+38]
//  428     if (preSetUP.n_led != 0) {
        LDR.W    R0,??DetectCircutLinks_0
        LDR      R0,[R0, #+12]
        CMP      R0,#+0
        BEQ.N    ??Init1_8
//  429         volatile short shIdxLU = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+48]
//  430         j = 0; //sLV.shIdxLU = 0;
        MOVS     R0,#+0
        MOVS     R6,R0
//  431         CLULed locCLULed(10, 0); // = CLULed(0,10);
        MOVS     R2,#+0
        MOVS     R1,#+10
        ADD      R0,SP,#+268
        BL       _ZN6CLULedC1Ecc
//  432         do {
//  433             j = InsertLU(LU_LED, static_cast<void*>(&locCLULed));
??Init1_9:
        ADD      R2,SP,#+268
        MOVS     R1,#+13
        MOVS     R0,R4
        BL       _ZN8Shematic8InsertLUElPv
        MOVS     R6,R0
//  434             //sLV.shIdxLU++;
//  435             if (j) {//Success Bield
        CMP      R6,#+0
        BEQ.N    ??Init1_10
//  436                 //Additional Obj SetUP
//  437                 i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
        LDR.W    R0,??DataTable5_5
        LDRSH    R0,[R0, #+0]
        MOVS     R5,R0
//  438                 //pv = (void*) &sLV.arrLUAreaListElem[i - 1];
//  439                 //sLV.pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
//  440 				pv = static_cast<void*>( &sLV.arrLUAreaListElem[i - 1]);
        LDR      R0,[SP, #+8]
        ADDS     R0,R0,R5, LSL #+3
        SUBS     R0,R0,#+8
        MOVS     R7,R0
//  441                 sLV.pCLUBase = static_cast<CLUBase*>( ( static_cast<LUAreaListElem*>(pv) )->pvLU);
        LDR      R0,[R7, #+4]
        STR      R0,[SP, #+12]
//  442                 sLV.pCLUBase->shShemasIdLUStng = STNG_LU_LED;
        MOVS     R0,#+13
        LDR      R1,[SP, #+12]
        STRH     R0,[R1, #+10]
//  443                 sLV.pCLUBase->shShemasOrdNumStng = arrSBitFldCRefInfo[sLV.shIdxLUOutDsc-1].bfInfo_BaseID;
        LDR.W    R0,??DetectCircutLinks_0+0x4
        LDRSH    R1,[SP, #+40]
        ADDS     R0,R0,R1, LSL #+3
        LDRB     R0,[R0, #-4]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDR      R1,[SP, #+12]
        STRH     R0,[R1, #+12]
//  444                         sLV.shIdxLUOutDsc++; //Temporary Numeration Discass It!!!!;
        LDRH     R0,[SP, #+40]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+40]
//  445                 CLULed* locPCLULed = static_cast<CLULed*>(sLV.pCLUBase);
        LDR      R0,[SP, #+12]
//  446                 locPCLULed->pIn = static_cast<void*>(locPCLULed->arrPchIn);
        ADDS     R1,R0,#+24
        STR      R1,[R0, #+0]
//  447                 CLULed& locRef_CLULed = *(static_cast<CLULed*>(sLV.pCLUBase));
        LDR      R1,[SP, #+12]
//  448                 locRef_CLULed.chTypeLogicFunction = LU_OP_SET_LED;
        MOVS     R2,#+9
        STRB     R2,[R1, #+8]
//  449                 locRef_CLULed.LogicFunc = SET_LED_Op; //???
        LDR.W    R2,??DataTable5_13
        STR      R2,[R1, #+16]
//  450                 GlobalObjectMap.arPCLULed[sLV.shIdx++] = static_cast<CLULed*>(sLV.pCLUBase);
        LDR      R2,[SP, #+12]
        LDR.W    R3,??DataTable5_11
        LDRSH    R12,[SP, #+38]
        ADDS     R3,R3,R12, LSL #+2
        STR      R2,[R3, #+80]
        LDRH     R2,[SP, #+38]
        ADDS     R2,R2,#+1
        STRH     R2,[SP, #+38]
//  451                 shIdxLU++; //
        LDRH     R2,[SP, #+48]
        ADDS     R2,R2,#+1
        STRH     R2,[SP, #+48]
//  452             }
//  453 
//  454         } while (shIdxLU < preSetUP.n_led && j);
??Init1_10:
        LDRSH    R0,[SP, #+48]
        LDR.W    R1,??DetectCircutLinks_0
        LDR      R1,[R1, #+12]
        CMP      R0,R1
        BGE.N    ??Init1_11
        CMP      R6,#+0
        BNE.N    ??Init1_9
//  455     }
??Init1_11:
        ADD      R0,SP,#+268
        BL       _ZN6CLULedD1Ev
//  456     sLV.shIdx = 0;
??Init1_8:
        MOVS     R0,#+0
        STRH     R0,[SP, #+38]
//  457     if (preSetUP.n_and != 0) {
        LDR.W    R0,??DetectCircutLinks_0
        LDR      R0,[R0, #+16]
        CMP      R0,#+0
        BEQ.N    ??Init1_12
//  458         sLV.shIdxLU = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+42]
//  459         j = 0;
        MOVS     R0,#+0
        MOVS     R6,R0
//  460         CLUAnd_8_1 locCLUAnd_8_1(10, 0); // = CLUAnd_8_1(0,10);
        MOVS     R2,#+0
        MOVS     R1,#+10
        ADD      R0,SP,#+208
        BL       _ZN10CLUAnd_8_1C1Ecc
//  461         do {
//  462             j = InsertLU(LU_AND, static_cast<void*>(&locCLUAnd_8_1));
??Init1_13:
        ADD      R2,SP,#+208
        MOVS     R1,#+4
        MOVS     R0,R4
        BL       _ZN8Shematic8InsertLUElPv
        MOVS     R6,R0
//  463             if (j) {//Success Bield
        CMP      R6,#+0
        BEQ.N    ??Init1_14
//  464                 //Additional Obj SetUP
//  465                 i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
        LDR.W    R0,??DataTable5_5
        LDRSH    R0,[R0, #+0]
        MOVS     R5,R0
//  466                 //pv = (void*) &sLV.arrLUAreaListElem[i - 1];
//  467                 //sLV.pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
//  468 				pv = static_cast<void*>( &sLV.arrLUAreaListElem[i - 1]);
        LDR      R0,[SP, #+8]
        ADDS     R0,R0,R5, LSL #+3
        SUBS     R0,R0,#+8
        MOVS     R7,R0
//  469                 sLV.pCLUBase = static_cast<CLUBase*>( ( static_cast<LUAreaListElem*>(pv) )->pvLU);
        LDR      R0,[R7, #+4]
        STR      R0,[SP, #+12]
//  470                 sLV.pCLUBase->shShemasIdLUStng = STNG_LU_AND;
        MOVS     R0,#+4
        LDR      R1,[SP, #+12]
        STRH     R0,[R1, #+10]
//  471                 sLV.pCLUBase->shShemasOrdNumStng = arrSBitFldCRefInfo[sLV.shIdxLUOutDsc-1].bfInfo_BaseID;
        LDR.W    R0,??DetectCircutLinks_0+0x4
        LDRSH    R1,[SP, #+40]
        ADDS     R0,R0,R1, LSL #+3
        LDRB     R0,[R0, #-4]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDR      R1,[SP, #+12]
        STRH     R0,[R1, #+12]
//  472                         sLV.shIdxLUOutDsc++; //Temporary Numeration Discass It!!!!;
        LDRH     R0,[SP, #+40]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+40]
//  473                 CLUAnd_8_1* locPCLUAnd_8_1 = static_cast<CLUAnd_8_1*>(sLV.pCLUBase);
        LDR      R0,[SP, #+12]
//  474                 locPCLUAnd_8_1->pOut = static_cast<void*>(locPCLUAnd_8_1->arrOut  );
        ADDS     R1,R0,#+56
        STR      R1,[R0, #+20]
//  475                 locPCLUAnd_8_1->pIn  = static_cast<void*>(locPCLUAnd_8_1->arrPchIn);
        ADDS     R1,R0,#+24
        STR      R1,[R0, #+0]
//  476                 CLUAnd_8_1& locRef_CLUAnd_8_1 = *(static_cast<CLUAnd_8_1*>(sLV.pCLUBase));
        LDR      R1,[SP, #+12]
//  477                 locRef_CLUAnd_8_1.chTypeLogicFunction = LU_OP_AND; //
        MOVS     R2,#+2
        STRB     R2,[R1, #+8]
//  478                 locRef_CLUAnd_8_1.LogicFunc = AND_Op_8_1; //???
        LDR.W    R2,??DataTable5_14
        STR      R2,[R1, #+16]
//  479 
//  480                 GlobalObjectMap.arPCLUAnd_8_1[sLV.shIdx++] = static_cast<CLUAnd_8_1*>(sLV.pCLUBase);
        LDR      R2,[SP, #+12]
        LDR.W    R3,??DataTable5_11
        LDRSH    R12,[SP, #+38]
        ADDS     R3,R3,R12, LSL #+2
        STR      R2,[R3, #+280]
        LDRH     R2,[SP, #+38]
        ADDS     R2,R2,#+1
        STRH     R2,[SP, #+38]
//  481                 sLV.shIdxLU++;
        LDRH     R2,[SP, #+42]
        ADDS     R2,R2,#+1
        STRH     R2,[SP, #+42]
//  482             }
//  483 
//  484         } while (sLV.shIdxLU < preSetUP.n_and && j);
??Init1_14:
        LDRSH    R0,[SP, #+42]
        LDR.W    R1,??DetectCircutLinks_0
        LDR      R1,[R1, #+16]
        CMP      R0,R1
        BGE.N    ??Init1_15
        CMP      R6,#+0
        BNE.N    ??Init1_13
//  485     }
??Init1_15:
        ADD      R0,SP,#+208
        BL       _ZN10CLUAnd_8_1D1Ev
//  486 
//  487     if (preSetUP.n_or != 0) {
??Init1_12:
        LDR.W    R0,??DetectCircutLinks_0
        LDR      R0,[R0, #+20]
        CMP      R0,#+0
        BEQ.N    ??Init1_16
//  488         sLV.shIdx = sLV.shIdxLU = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+42]
        LDRH     R0,[SP, #+42]
        STRH     R0,[SP, #+38]
//  489         j = 0;
        MOVS     R0,#+0
        MOVS     R6,R0
//  490         CLUOr_8_1 locCLUOr_8_1(10, 0); // = CLUOr_8_1(0,10);
        MOVS     R2,#+0
        MOVS     R1,#+10
        ADD      R0,SP,#+148
        BL       _ZN9CLUOr_8_1C1Ecc
//  491         do {
//  492             j = InsertLU(LU_OR, static_cast<void*>(&locCLUOr_8_1));
??Init1_17:
        ADD      R2,SP,#+148
        MOVS     R1,#+5
        MOVS     R0,R4
        BL       _ZN8Shematic8InsertLUElPv
        MOVS     R6,R0
//  493             if (j) {//Success Bield
        CMP      R6,#+0
        BEQ.N    ??Init1_18
//  494                 //Additional Obj SetUP
//  495                 i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
        LDR.W    R0,??DataTable5_5
        LDRSH    R0,[R0, #+0]
        MOVS     R5,R0
//  496                 //pv = (void*) &sLV.arrLUAreaListElem[i - 1];
//  497                 //sLV.pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
//  498 				pv = static_cast<void*>( &sLV.arrLUAreaListElem[i - 1]);
        LDR      R0,[SP, #+8]
        ADDS     R0,R0,R5, LSL #+3
        SUBS     R0,R0,#+8
        MOVS     R7,R0
//  499                 sLV.pCLUBase = static_cast<CLUBase*>( ( static_cast<LUAreaListElem*>(pv) )->pvLU);
        LDR      R0,[R7, #+4]
        STR      R0,[SP, #+12]
//  500                 sLV.pCLUBase->shShemasIdLUStng = STNG_LU_OR;
        MOVS     R0,#+5
        LDR      R1,[SP, #+12]
        STRH     R0,[R1, #+10]
//  501                 sLV.pCLUBase->shShemasOrdNumStng =
//  502                         sLV.shIdxLUOutDsc++; //Temporary Numeration Discass It!!!!;
        LDRH     R0,[SP, #+40]
        LDR      R1,[SP, #+12]
        STRH     R0,[R1, #+12]
        LDRH     R0,[SP, #+40]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+40]
//  503                 CLUOr_8_1* locPCLUOr_8_1 = static_cast<CLUOr_8_1*>(sLV.pCLUBase);
        LDR      R8,[SP, #+12]
//  504                 locPCLUOr_8_1->pOut = static_cast<void*>(locPCLUOr_8_1->arrOut  );
        ADDS     R0,R8,#+56
        STR      R0,[R8, #+20]
//  505                 locPCLUOr_8_1->pIn  = static_cast<void*>(locPCLUOr_8_1->arrPchIn);
        ADDS     R0,R8,#+24
        STR      R0,[R8, #+0]
//  506                 CLUOr_8_1& locRef_CLUOr_8_1 = *(static_cast<CLUOr_8_1*>(sLV.pCLUBase));
        LDR      R9,[SP, #+12]
//  507                 locRef_CLUOr_8_1.LogicFunc(sLV.pCLUBase);
        LDR      R0,[SP, #+12]
        LDR      R1,[R9, #+16]
        BLX      R1
//  508                 GlobalObjectMap.arPCLUOr_8_1[sLV.shIdx++] = static_cast<CLUOr_8_1*>(sLV.pCLUBase);
        LDR      R0,[SP, #+12]
        LDR.W    R1,??DataTable5_11
        LDRSH    R2,[SP, #+38]
        ADDS     R1,R1,R2, LSL #+2
        STR      R0,[R1, #+200]
        LDRH     R0,[SP, #+38]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+38]
//  509                 sLV.shIdxLU++;
        LDRH     R0,[SP, #+42]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+42]
//  510             }
//  511 
//  512         } while (sLV.shIdxLU < preSetUP.n_or && j);
??Init1_18:
        LDRSH    R0,[SP, #+42]
        LDR.W    R1,??DetectCircutLinks_0
        LDR      R1,[R1, #+20]
        CMP      R0,R1
        BGE.N    ??Init1_19
        CMP      R6,#+0
        BNE.N    ??Init1_17
//  513     }
??Init1_19:
        ADD      R0,SP,#+148
        BL       _ZN9CLUOr_8_1D1Ev
//  514     if (preSetUP.n_xor != 0) {
??Init1_16:
        LDR.W    R0,??DetectCircutLinks_0
        LDR      R0,[R0, #+24]
        CMP      R0,#+0
        BEQ.N    ??Init1_20
//  515         sLV.shIdx = sLV.shIdxLU = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+42]
        LDRH     R0,[SP, #+42]
        STRH     R0,[SP, #+38]
//  516         j = 0;
        MOVS     R0,#+0
        MOVS     R6,R0
//  517         CLUXor_8_1 locCLUXor_8_1(10, 0); // = CLUXor_8_1(0,10);
        MOVS     R2,#+0
        MOVS     R1,#+10
        ADD      R0,SP,#+112
        BL       _ZN10CLUXor_8_1C1Ecc
//  518         do {
//  519             j = InsertLU(LU_XOR, static_cast<void*>(&locCLUXor_8_1));
??Init1_21:
        ADD      R2,SP,#+112
        MOVS     R1,#+6
        MOVS     R0,R4
        BL       _ZN8Shematic8InsertLUElPv
        MOVS     R6,R0
//  520             if (j) {//Success Bield
        CMP      R6,#+0
        BEQ.N    ??Init1_22
//  521                 //Additional Obj SetUP
//  522                 i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
        LDR.W    R0,??DataTable5_5
        LDRSH    R0,[R0, #+0]
        MOVS     R5,R0
//  523                 //pv = (void*) &sLV.arrLUAreaListElem[i - 1];
//  524                 //sLV.pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
//  525 				pv = static_cast<void*>( &sLV.arrLUAreaListElem[i - 1]);
        LDR      R0,[SP, #+8]
        ADDS     R0,R0,R5, LSL #+3
        SUBS     R0,R0,#+8
        MOVS     R7,R0
//  526                 sLV.pCLUBase = static_cast<CLUBase*>( ( static_cast<LUAreaListElem*>(pv) )->pvLU);
        LDR      R0,[R7, #+4]
        STR      R0,[SP, #+12]
//  527                 sLV.pCLUBase->shShemasIdLUStng = STNG_LU_XOR;
        MOVS     R0,#+6
        LDR      R1,[SP, #+12]
        STRH     R0,[R1, #+10]
//  528                 sLV.pCLUBase->shShemasOrdNumStng =
//  529                         sLV.shIdxLUOutDsc++; //Temporary Numeration Discass It!!!!;
        LDRH     R0,[SP, #+40]
        LDR      R1,[SP, #+12]
        STRH     R0,[R1, #+12]
        LDRH     R0,[SP, #+40]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+40]
//  530                 CLUXor_8_1* locPCLUXor_8_1 = static_cast<CLUXor_8_1*>(sLV.pCLUBase);
        LDR      R8,[SP, #+12]
//  531                 locPCLUXor_8_1->pOut =  static_cast<void*>(locPCLUXor_8_1->arrOut  );
        ADDS     R0,R8,#+32
        STR      R0,[R8, #+20]
//  532                 locPCLUXor_8_1->pIn  =  static_cast<void*>(locPCLUXor_8_1->arrPchIn);
        ADDS     R0,R8,#+24
        STR      R0,[R8, #+0]
//  533                 CLUXor_8_1& locRef_CLUXor_8_1 = *(static_cast<CLUXor_8_1*>(sLV.pCLUBase));
        LDR      R9,[SP, #+12]
//  534                 locRef_CLUXor_8_1.LogicFunc(sLV.pCLUBase);
        LDR      R0,[SP, #+12]
        LDR      R1,[R9, #+16]
        BLX      R1
//  535                 GlobalObjectMap.arPCLUXor_8_1[sLV.shIdx++] = static_cast<CLUXor_8_1*>(sLV.pCLUBase);
        LDR      R0,[SP, #+12]
        LDR.W    R1,??DataTable5_11
        LDRSH    R2,[SP, #+38]
        ADDS     R1,R1,R2, LSL #+2
        STR      R0,[R1, #+360]
        LDRH     R0,[SP, #+38]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+38]
//  536                 sLV.shIdxLU++;
        LDRH     R0,[SP, #+42]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+42]
//  537             }
//  538 
//  539         } while (sLV.shIdxLU < preSetUP.n_xor && j);
??Init1_22:
        LDRSH    R0,[SP, #+42]
        LDR.W    R1,??DetectCircutLinks_0
        LDR      R1,[R1, #+24]
        CMP      R0,R1
        BGE.N    ??Init1_23
        CMP      R6,#+0
        BNE.N    ??Init1_21
//  540     }
??Init1_23:
        ADD      R0,SP,#+112
        BL       _ZN10CLUXor_8_1D1Ev
//  541     if (preSetUP.n_not != 0) {
??Init1_20:
        LDR.W    R0,??DetectCircutLinks_0
        LDR      R0,[R0, #+28]
        CMP      R0,#+0
        BEQ.N    ??Init1_24
//  542         sLV.shIdx = sLV.shIdxLU = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+42]
        LDRH     R0,[SP, #+42]
        STRH     R0,[SP, #+38]
//  543         j = 0;
        MOVS     R0,#+0
        MOVS     R6,R0
//  544         CLUNot_1_1 locCLUNot_1_1(10, 0); // = CLUNot_1_1(0,10);
        MOVS     R2,#+0
        MOVS     R1,#+10
        ADD      R0,SP,#+52
        BL       _ZN10CLUNot_1_1C1Ecc
//  545         do {
//  546             j = InsertLU(LU_NOT, static_cast<void*>(&locCLUNot_1_1));
??Init1_25:
        ADD      R2,SP,#+52
        MOVS     R1,#+14
        MOVS     R0,R4
        BL       _ZN8Shematic8InsertLUElPv
        MOVS     R6,R0
//  547             if (j) {//Success Bield
        CMP      R6,#+0
        BEQ.N    ??Init1_26
//  548                 //Additional Obj SetUP
//  549                 i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
        LDR.W    R0,??DataTable5_5
        LDRSH    R0,[R0, #+0]
        MOVS     R5,R0
//  550                 //pv = (void*) &sLV.arrLUAreaListElem[i - 1];
//  551                 //sLV.pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
//  552 				pv = static_cast<void*>( &sLV.arrLUAreaListElem[i - 1]);
        LDR      R0,[SP, #+8]
        ADDS     R0,R0,R5, LSL #+3
        SUBS     R0,R0,#+8
        MOVS     R7,R0
//  553                 sLV.pCLUBase = static_cast<CLUBase*>( ( static_cast<LUAreaListElem*>(pv) )->pvLU);
        LDR      R0,[R7, #+4]
        STR      R0,[SP, #+12]
//  554                 sLV.pCLUBase->shShemasIdLUStng = STNG_LU_NOT;
        MOVS     R0,#+14
        LDR      R1,[SP, #+12]
        STRH     R0,[R1, #+10]
//  555                 sLV.pCLUBase->shShemasOrdNumStng =
//  556                         sLV.shIdxLUOutDsc++; //Temporary Numeration Discass It!!!!;
        LDRH     R0,[SP, #+40]
        LDR      R1,[SP, #+12]
        STRH     R0,[R1, #+12]
        LDRH     R0,[SP, #+40]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+40]
//  557                 CLUNot_1_1* locPCLUNot_1_1 = static_cast<CLUNot_1_1*>(sLV.pCLUBase);
        LDR      R8,[SP, #+12]
//  558                 locPCLUNot_1_1->pOut = static_cast<void*>(locPCLUNot_1_1->arrOut  );
        ADDS     R0,R8,#+28
        STR      R0,[R8, #+20]
//  559                 locPCLUNot_1_1->pIn  = static_cast<void*>(locPCLUNot_1_1->arrPchIn);
        ADDS     R0,R8,#+24
        STR      R0,[R8, #+0]
//  560                 CLUNot_1_1& locRef_CLUNot_1_1 = *(static_cast<CLUNot_1_1*>(sLV.pCLUBase));
        LDR      R9,[SP, #+12]
//  561                 locRef_CLUNot_1_1.LogicFunc(sLV.pCLUBase);
        LDR      R0,[SP, #+12]
        LDR      R1,[R9, #+16]
        BLX      R1
//  562                 GlobalObjectMap.arPCLUNot_1_1[sLV.shIdx++] = static_cast<CLUNot_1_1*>(sLV.pCLUBase);
        LDR      R0,[SP, #+12]
        LDR.W    R1,??DataTable5_11
        LDRSH    R2,[SP, #+38]
        ADDS     R1,R1,R2, LSL #+2
        STR      R0,[R1, #+120]
        LDRH     R0,[SP, #+38]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+38]
//  563                 sLV.shIdxLU++;
        LDRH     R0,[SP, #+42]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+42]
//  564             }
//  565 
//  566         } while (sLV.shIdxLU < preSetUP.n_not && j);
??Init1_26:
        LDRSH    R0,[SP, #+42]
        LDR.W    R1,??DetectCircutLinks_0
        LDR      R1,[R1, #+28]
        CMP      R0,R1
        BGE.N    ??Init1_27
        CMP      R6,#+0
        BNE.N    ??Init1_25
//  567     }
??Init1_27:
        ADD      R0,SP,#+52
        BL       _ZN10CLUNot_1_1D1Ev
//  568 
//  569     //1 Place points In MemArea
//  570     //Place Unit
//  571     //If I try delete operation It shold move all data for efficiently
//  572     //memory Use
//  573 
//  574     //SetUP Links
//  575     sLV.arrLUAreaListElem = &gLUAreaMem.headLUAreaList;
??Init1_24:
        LDR.W    R0,??DataTable5_6
        STR      R0,[SP, #+8]
//  576     //Find 1st DO
//  577     i = j = sLV.shIdxLUOutDsc = sLV.shIdxLU = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+42]
        STRH     R0,[SP, #+40]
        SXTH     R0,R0            ;; SignExt  R0,R0,#+16,#+16
        MOVS     R6,R0
        MOVS     R5,R6
//  578     sLV.lId = 0;
        MOVS     R0,#+0
        STR      R0,[SP, #+24]
//  579     pv = static_cast<void*>(&sLV.arrLUAreaListElem[i]); //Last Elem
        LDR      R0,[SP, #+8]
        ADDS     R0,R0,R5, LSL #+3
        MOVS     R7,R0
//  580     sLV.shAmtLU = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
        LDR.W    R0,??DataTable5_5
        LDRH     R0,[R0, #+0]
        STRH     R0,[SP, #+32]
//  581     sLV.shAmtLUDsc = 10 + 10 + 8 * 1; //Demo Variant
        MOVS     R0,#+28
        STRH     R0,[SP, #+36]
//  582     while (sLV.shAmtLUDsc && sLV.chBrk2 == 0) {
??Init1_28:
        LDRSH    R0,[SP, #+36]
        CMP      R0,#+0
        BEQ.W    ??Init1_29
        LDRB     R0,[SP, #+47]
        CMP      R0,#+0
        BNE.W    ??Init1_29
//  583         while (sLV.shIdxLU < sLV.shAmtLU && sLV.chBrk1 == 0) {
??Init1_30:
        LDRSH    R0,[SP, #+42]
        LDRSH    R1,[SP, #+32]
        CMP      R0,R1
        BGE.W    ??Init1_31
        LDRB     R0,[SP, #+46]
        CMP      R0,#+0
        BNE.W    ??Init1_31
//  584             i = sLV.shIdxLU;
        LDRSH    R0,[SP, #+42]
        MOVS     R5,R0
//  585             pv = static_cast<void*>(&sLV.arrLUAreaListElem[i]);
        LDR      R0,[SP, #+8]
        ADDS     R0,R0,R5, LSL #+3
        MOVS     R7,R0
//  586             sLV.pCLUBase = static_cast<CLUBase*>( (static_cast<LUAreaListElem*>(pv))->pvLU);
        LDR      R0,[R7, #+4]
        STR      R0,[SP, #+12]
//  587             j = sLV.shIdxLUOutDsc;
        LDRSH    R0,[SP, #+40]
        MOVS     R6,R0
//  588             if (sLV.pCLUBase->shShemasIdLUStng == ar_n_output_CRDsc[j].shBaseIdLUStng &&
//  589                     sLV.pCLUBase->shShemasOrdNumStng == ar_n_output_CRDsc[j].shBaseOrdNumStng) {
        LDR      R0,[SP, #+12]
        LDRSH    R0,[R0, #+10]
        LDR.W    R1,??DataTable6
        MOVS     R2,#+10
        MLA      R1,R2,R6,R1
        LDRSH    R1,[R1, #+0]
        CMP      R0,R1
        BNE.W    ??Init1_32
        LDR      R0,[SP, #+12]
        LDRSH    R0,[R0, #+12]
        LDR.W    R1,??DataTable6
        MOVS     R2,#+10
        MLA      R1,R2,R6,R1
        LDRSH    R1,[R1, #+2]
        CMP      R0,R1
        BNE.W    ??Init1_32
//  590                 sLV.pV = pv; //save pv
        STR      R7,[SP, #+20]
//  591                 sLV.chVal = sLV.pCLUBase->chNumOutput;
        LDR      R0,[SP, #+12]
        LDRB     R0,[R0, #+7]
        STRB     R0,[SP, #+44]
//  592                 for (sLV.shIdx = 0; sLV.shIdx < sLV.pCLUBase->chNumInput; sLV.shIdx++) {//sLV.pCLUBase->chNumOutput
        MOVS     R0,#+0
        STRH     R0,[SP, #+38]
??Init1_33:
        LDRSH    R0,[SP, #+38]
        LDR      R1,[SP, #+12]
        LDRB     R1,[R1, #+6]
        SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
        CMP      R0,R1
        BGE.W    ??Init1_34
//  593                     //Find
//  594                     //,,pv = (void*)&sLV.arrLUAreaListElem[0];//Last Elem
//  595                     sLV.chVal = 0;
        MOVS     R0,#+0
        STRB     R0,[SP, #+44]
//  596                     i = 0;
        MOVS     R0,#+0
        MOVS     R5,R0
//  597                     sLV.pCh = static_cast<char*>(0);
        MOVS     R0,#+0
        STR      R0,[SP, #+0]
//  598                     j = sLV.shIdxLUOutDsc + sLV.shIdx;
        LDRSH    R0,[SP, #+40]
        LDRSH    R1,[SP, #+38]
        ADDS     R0,R1,R0
        MOVS     R6,R0
//  599                     while (i < sLV.shAmtLU) {
??Init1_35:
        LDRSH    R0,[SP, #+32]
        CMP      R5,R0
        BGE.N    ??Init1_36
//  600                         pv = static_cast<void*>(&sLV.arrLUAreaListElem[i]);
        LDR      R0,[SP, #+8]
        ADDS     R0,R0,R5, LSL #+3
        MOVS     R7,R0
//  601                         sLV.pCLURef = static_cast<CLUBase*>( (static_cast<LUAreaListElem*>(pv))->pvLU);
        LDR      R0,[R7, #+4]
        STR      R0,[SP, #+16]
//  602                         if ((sLV.pCLURef->shShemasIdLUStng == ar_n_output_CRDsc[j].shRefIdLUStng) &&
//  603                                 (sLV.pCLURef->shShemasOrdNumStng == ar_n_output_CRDsc[j].shRefOrdNumStng)
//  604                                 && (sLV.shIdx == (ar_n_output_CRDsc[j].chRefOrdNumOut - 1))) {
        LDR      R0,[SP, #+16]
        LDRSH    R0,[R0, #+10]
        LDR.W    R1,??DataTable6
        MOVS     R2,#+10
        MLA      R1,R2,R6,R1
        LDRSH    R1,[R1, #+4]
        CMP      R0,R1
        BNE.N    ??Init1_37
        LDR      R0,[SP, #+16]
        LDRSH    R0,[R0, #+12]
        LDR.W    R1,??DataTable6
        MOVS     R2,#+10
        MLA      R1,R2,R6,R1
        LDRSH    R1,[R1, #+6]
        CMP      R0,R1
        BNE.N    ??Init1_37
        LDRSH    R0,[SP, #+38]
        LDR.W    R1,??DataTable6
        MOVS     R2,#+10
        MLA      R1,R2,R6,R1
        LDRB     R1,[R1, #+8]
        SUBS     R1,R1,#+1
        CMP      R0,R1
        BNE.N    ??Init1_37
//  605                             sLV.pCh = static_cast<char*>(sLV.pCLURef->pOut);
        LDR      R0,[SP, #+16]
        LDR      R0,[R0, #+20]
        STR      R0,[SP, #+0]
//  606                             sLV.pCh += ar_n_output_CRDsc[j].chRefOrdNumOut - 1;
        LDR      R0,[SP, #+0]
        LDR.W    R1,??DataTable6
        MOVS     R2,#+10
        MLA      R1,R2,R6,R1
        LDRB     R1,[R1, #+8]
        ADDS     R0,R1,R0
        SUBS     R0,R0,#+1
        STR      R0,[SP, #+0]
//  607                             sLV.chVal++; //Counter success
        LDRB     R0,[SP, #+44]
        ADDS     R0,R0,#+1
        STRB     R0,[SP, #+44]
//  608                             break;
        B.N      ??Init1_36
//  609                         }
//  610                         i++;
??Init1_37:
        ADDS     R5,R5,#+1
        B.N      ??Init1_35
//  611                     }
//  612                     if (sLV.pCh) {
??Init1_36:
        LDR      R0,[SP, #+0]
        CMP      R0,#+0
        BEQ.N    ??Init1_38
//  613                         sLV.arrPchIn = static_cast<char**>(sLV.pCLUBase->pIn);
        LDR      R0,[SP, #+12]
        LDR      R0,[R0, #+0]
        STR      R0,[SP, #+4]
//  614                         sLV.arrPchIn[sLV.shIdx] = sLV.pCh;
        LDR      R0,[SP, #+4]
        LDRSH    R1,[SP, #+38]
        LDR      R2,[SP, #+0]
        STR      R2,[R0, R1, LSL #+2]
//  615                         j++;
        ADDS     R6,R6,#+1
//  616                         //Check Next Statment
//  617                         if (sLV.pCLUBase->shShemasIdLUStng != ar_n_output_CRDsc[j].shBaseIdLUStng
//  618                                 || sLV.pCLUBase->shShemasOrdNumStng != ar_n_output_CRDsc[j].shBaseOrdNumStng
//  619                                 ) {
        LDR      R0,[SP, #+12]
        LDRSH    R0,[R0, #+10]
        LDR.W    R1,??DataTable6
        MOVS     R2,#+10
        MLA      R1,R2,R6,R1
        LDRSH    R1,[R1, #+0]
        CMP      R0,R1
        BNE.N    ??Init1_39
        LDR      R0,[SP, #+12]
        LDRSH    R0,[R0, #+12]
        LDR.W    R1,??DataTable6
        MOVS     R2,#+10
        MLA      R1,R2,R6,R1
        LDRSH    R1,[R1, #+2]
        CMP      R0,R1
        BEQ.N    ??Init1_38
//  620                             sLV.shIdx = sLV.pCLUBase->chNumInput;
??Init1_39:
        LDR      R0,[SP, #+12]
        LDRB     R0,[R0, #+6]
        STRH     R0,[SP, #+38]
//  621                             break; //goto ;//Break For
        B.N      ??Init1_34
//  622                         }
//  623                     }
//  624                 }
??Init1_38:
        LDRH     R0,[SP, #+38]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+38]
        B.N      ??Init1_33
//  625                 if (sLV.chVal) {//Succes SetUP
??Init1_34:
        LDRB     R0,[SP, #+44]
        CMP      R0,#+0
        BEQ.N    ??Init1_40
//  626                     if (sLV.shAmtLUDsc >= sLV.chVal) {
        LDRSH    R0,[SP, #+36]
        LDRB     R1,[SP, #+44]
        SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
        CMP      R0,R1
        BLT.N    ??Init1_41
//  627                         sLV.shAmtLUDsc -= sLV.chVal;
        LDRH     R0,[SP, #+36]
        LDRB     R1,[SP, #+44]
        SUBS     R0,R0,R1
        STRH     R0,[SP, #+36]
//  628                         sLV.shIdxLUOutDsc += sLV.chVal;
        LDRH     R0,[SP, #+40]
        LDRB     R1,[SP, #+44]
        ADDS     R0,R1,R0
        STRH     R0,[SP, #+40]
        B.N      ??Init1_42
//  629                         //goto;
//  630                     } else {
//  631                         //Fix Error
//  632                         sLV.chErrCount++; //Wrong Setup Val
??Init1_41:
        LDRB     R0,[SP, #+45]
        ADDS     R0,R0,#+1
        STRB     R0,[SP, #+45]
//  633                         sLV.chBrk2 |= 1; //goto;Stop Execution
        LDRB     R0,[SP, #+47]
        ORRS     R0,R0,#0x1
        STRB     R0,[SP, #+47]
        B.N      ??Init1_42
//  634                     }
//  635 
//  636                 } else {
//  637                     sLV.chErrCount++; //Fix Error
??Init1_40:
        LDRB     R0,[SP, #+45]
        ADDS     R0,R0,#+1
        STRB     R0,[SP, #+45]
//  638                     //Not Found Out Elem Situation
//  639                     //sLV.chBrk2 |= ;//goto;
//  640                     sLV.lId |= 2;
        LDR      R0,[SP, #+24]
        ORRS     R0,R0,#0x2
        STR      R0,[SP, #+24]
//  641                 }
//  642                 sLV.chBrk1 |= 1;
??Init1_42:
        LDRB     R0,[SP, #+46]
        ORRS     R0,R0,#0x1
        STRB     R0,[SP, #+46]
//  643             }
//  644             //.if(sLV.chBrk1==0){
//  645             //.
//  646             //.}Next Iteration while(sLV.shIdxLU<sLV.shAmtLU)
//  647             sLV.shIdxLU++;
??Init1_32:
        LDRH     R0,[SP, #+42]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+42]
        B.N      ??Init1_30
//  648         }
//  649         sLV.shIdxLU = 0;
??Init1_31:
        MOVS     R0,#+0
        STRH     R0,[SP, #+42]
//  650         sLV.chBrk1 = 0;
        MOVS     R0,#+0
        STRB     R0,[SP, #+46]
//  651         //Check Error
//  652         if (sLV.lId & 2) {
        LDRB     R0,[SP, #+24]
        LSLS     R0,R0,#+30
        BPL.W    ??Init1_28
//  653             //Not Found Out Elem Situation
//  654             sLV.shAmtLUDsc -= 1;
        LDRH     R0,[SP, #+36]
        SUBS     R0,R0,#+1
        STRH     R0,[SP, #+36]
//  655             sLV.shIdxLUOutDsc += 1;
        LDRH     R0,[SP, #+40]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+40]
//  656             sLV.lId &= ~2;
        LDR      R0,[SP, #+24]
        BICS     R0,R0,#0x2
        STR      R0,[SP, #+24]
        B.N      ??Init1_28
//  657         }
//  658     }
//  659     //Scan Info on Leds
//  660 
//  661 
//  662 }
??Init1_29:
        ADD      SP,SP,#+404
        POP      {R4-R9,PC}       ;; return
//  663 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  664 long Shematic::EvalSizeObj(long lId) {
_ZN8Shematic11EvalSizeObjEl:
        MOVS     R2,R0
//  665     long lsizeObj;
//  666     switch (lId) {
        MOVS     R3,R1
        CMP      R3,#+1
        BEQ.N    ??EvalSizeObj_0
        CMP      R3,#+2
        BEQ.N    ??EvalSizeObj_1
        CMP      R3,#+3
        BEQ.N    ??EvalSizeObj_2
        CMP      R3,#+4
        BEQ.N    ??EvalSizeObj_3
        CMP      R3,#+5
        BEQ.N    ??EvalSizeObj_4
        CMP      R3,#+6
        BEQ.N    ??EvalSizeObj_5
        CMP      R3,#+11
        BEQ.N    ??EvalSizeObj_6
        CMP      R3,#+12
        BEQ.N    ??EvalSizeObj_7
        CMP      R3,#+13
        BEQ.N    ??EvalSizeObj_8
        CMP      R3,#+14
        BEQ.N    ??EvalSizeObj_9
        CMP      R3,#+15
        BEQ.N    ??EvalSizeObj_10
        B.N      ??EvalSizeObj_11
//  667         case BASE_POINT:
//  668             lsizeObj = SIZE_BASE_IN_POINT;
??EvalSizeObj_0:
        MOVS     R3,#+6
        MOVS     R0,R3
//  669             break;
        B.N      ??EvalSizeObj_12
//  670         case POINT:
//  671             lsizeObj = SIZE_IN_POINT;
??EvalSizeObj_1:
        MOVS     R3,#+6
        MOVS     R0,R3
//  672             break;
        B.N      ??EvalSizeObj_12
//  673         case EXTENDED:
//  674             lsizeObj = sizeof (ExtPoint);
??EvalSizeObj_2:
        MOVS     R3,#+6
        MOVS     R0,R3
//  675             break;
        B.N      ??EvalSizeObj_12
//  676         case LU_AND:
//  677             lsizeObj = sizeof (CLUAnd_8_1);
??EvalSizeObj_3:
        MOVS     R3,#+60
        MOVS     R0,R3
//  678             break;
        B.N      ??EvalSizeObj_12
//  679         case LU_OR:
//  680             lsizeObj = sizeof (CLUOr_8_1);
??EvalSizeObj_4:
        MOVS     R3,#+60
        MOVS     R0,R3
//  681             break;
        B.N      ??EvalSizeObj_12
//  682         case LU_XOR:
//  683             lsizeObj = sizeof (CLUXor_8_1);
??EvalSizeObj_5:
        MOVS     R3,#+36
        MOVS     R0,R3
//  684             break;
        B.N      ??EvalSizeObj_12
//  685         case LU_NOT:
//  686             lsizeObj = sizeof (CLUNot_1_1);
??EvalSizeObj_9:
        MOVS     R3,#+32
        MOVS     R0,R3
//  687             break;
        B.N      ??EvalSizeObj_12
//  688         case LU_MFT:
//  689             lsizeObj = sizeof (CMft);
??EvalSizeObj_10:
        MOVS     R3,#+80
        MOVS     R0,R3
//  690             break;
        B.N      ??EvalSizeObj_12
//  691         //case LU_TIMERS:
//  692             //case LU_TRIGGERS:
//  693             //case LU_ALARMS:
//  694             //case LU_MEANDERS:
//  695 
//  696         case LU_INPUT:
//  697             lsizeObj = sizeof (CLUDInput_0_1);
??EvalSizeObj_6:
        MOVS     R3,#+28
        MOVS     R0,R3
//  698             break;
        B.N      ??EvalSizeObj_12
//  699         case LU_OUTPUT:
//  700             lsizeObj = sizeof (CLUDout_1_0);
??EvalSizeObj_7:
        MOVS     R3,#+64
        MOVS     R0,R3
//  701             break;
        B.N      ??EvalSizeObj_12
//  702         case LU_LED:
//  703             lsizeObj = sizeof (CLULed);
??EvalSizeObj_8:
        MOVS     R3,#+72
        MOVS     R0,R3
//  704             break;
        B.N      ??EvalSizeObj_12
//  705 
//  706         default:
//  707             lsizeObj = 0;
??EvalSizeObj_11:
        MOVS     R3,#+0
        MOVS     R0,R3
//  708     }
//  709     //ExitEval
//  710     return lsizeObj;
??EvalSizeObj_12:
        BX       LR               ;; return
//  711 }
//  712 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  713 long Shematic::InsertLU(long lId, void*pvObjImage) {
_ZN8Shematic8InsertLUElPv:
        PUSH     {R4-R9,LR}
        SUB      SP,SP,#+20
        MOVS     R4,R0
        MOV      R8,R1
        MOVS     R5,R2
//  714     register long i;
//  715     register void* pv;
//  716 
//  717     struct {
//  718         long lId, lsizeobj;
//  719         void *pV;
//  720         LUAreaListElem* arrLUAreaListElem;
//  721         CLUBase* pCLUBase;
//  722     } sLV;
//  723     //check Id
//  724     sLV.lsizeobj = 0;
        MOVS     R0,#+0
        STR      R0,[SP, #+4]
//  725     i = EvalSizeObj(lId);
        MOV      R1,R8
        MOVS     R0,R4
        BL       _ZN8Shematic11EvalSizeObjEl
        MOVS     R6,R0
//  726     if (i) {
        CMP      R6,#+0
        BEQ.N    ??InsertLU_0
//  727 
//  728         //Check pvObjImage
//  729         if (pvObjImage != 0) {
        CMP      R5,#+0
        BEQ.N    ??InsertLU_1
//  730             //check Free Memory
//  731             pv = static_cast<void*>(&gblLUAreaAuxVar);
        LDR.N    R0,??DataTable5_5
        MOVS     R7,R0
//  732             if ((static_cast<LUAreaAuxVar*>(pv))->lAmountFreeMem >=
//  733                     static_cast<long>(i + SIZE_LU_AREA_LIST_ITEM)) {
        LDR      R0,[R7, #+4]
        ADDS     R1,R6,#+8
        CMP      R0,R1
        BLT.N    ??InsertLU_2
//  734                 sLV.lId = lId; //Save Id
        STR      R8,[SP, #+0]
//  735                 sLV.lsizeobj = i;
        STR      R6,[SP, #+4]
//  736                 sLV.pV = pv;
        STR      R7,[SP, #+8]
//  737                 sLV.arrLUAreaListElem = &gLUAreaMem.headLUAreaList;
        LDR.N    R0,??DataTable5_6
        STR      R0,[SP, #+12]
//  738                 i = (static_cast<LUAreaAuxVar*>(pv))->shAmountPlacedLogicUnit; //Now Index in LUAreaListElem
        LDRSH    R0,[R7, #+0]
        MOVS     R6,R0
//  739 
//  740                 if (i) {
        CMP      R6,#+0
        BEQ.N    ??InsertLU_3
//  741                     i--; //Detect Head
        SUBS     R6,R6,#+1
//  742                     pv = static_cast<void*>(&sLV.arrLUAreaListElem[i]); //Last Elem
        LDR      R0,[SP, #+12]
        ADDS     R0,R0,R6, LSL #+3
        MOVS     R7,R0
//  743                     //Mem Area
//  744                     lId = reinterpret_cast<long>(( static_cast<LUAreaListElem*>(pv))->pvLU);
        LDR      R0,[R7, #+4]
        MOV      R8,R0
//  745                     //Add size
//  746                     lId -= sLV.lsizeobj; //((LUAreaListElem*)pv)->shSizeLU;
        LDR      R0,[SP, #+4]
        SUBS     R8,R8,R0
//  747                     //gblLUAreaAuxVar.pvHead -= ((LUAreaListElem*)pv)->shSizeLU
//  748                     memcpy(reinterpret_cast<void*>(lId), pvObjImage, sLV.lsizeobj);
        LDR      R9,[SP, #+4]
        MOV      R2,R9
        MOVS     R1,R5
        MOV      R0,R8
        BL       __aeabi_memcpy
//  749                     pv = static_cast<void*>(&sLV.arrLUAreaListElem[i + 1]); //Next
        LDR      R0,[SP, #+12]
        ADDS     R0,R0,R6, LSL #+3
        ADDS     R0,R0,#+8
        MOVS     R7,R0
//  750                     (static_cast<LUAreaListElem*>(pv))->shSizeLU = static_cast<short>(sLV.lsizeobj);
        LDR      R0,[SP, #+4]
        STRH     R0,[R7, #+2]
//  751                     (static_cast<LUAreaListElem*>(pv))->shIdLU   = static_cast<short>(sLV.lId);
        LDR      R0,[SP, #+0]
        STRH     R0,[R7, #+0]
//  752                     (static_cast<LUAreaListElem*>(pv))->pvLU     = reinterpret_cast<void*>(lId);
        STR      R8,[R7, #+4]
//  753                     gblLUAreaAuxVar.pvHead = reinterpret_cast<void*>(lId); // (lId - sLV.lId);//For check Only
        LDR.N    R0,??DataTable5_5
        STR      R8,[R0, #+12]
//  754                     //sLV.pCLUBase = ((LUAreaListElem*) pv)->pvLU;
//  755                     sLV.pCLUBase = static_cast<CLUBase*> (
//  756                             (static_cast<LUAreaListElem*> (pv))->pvLU);
        LDR      R0,[R7, #+4]
        STR      R0,[SP, #+16]
        B.N      ??InsertLU_4
//  757                 } else {
//  758                     pv = static_cast<void*>(&gLUAreaMem.headLUAreaList);
??InsertLU_3:
        LDR.N    R0,??DataTable5_6
        MOVS     R7,R0
//  759 
//  760                     //First Init
//  761                     lId = reinterpret_cast<long>(&gLUAreaMem.chArRamPrgEvt[SIZE_MEM_BLK]);
        LDR.W    R0,??DataTable7
        MOV      R8,R0
//  762                     lId -= (sLV.lsizeobj);
        LDR      R0,[SP, #+4]
        SUBS     R8,R8,R0
//  763                     (static_cast<LUAreaListElem*>(pv))->pvLU = reinterpret_cast<void*>(lId);
        STR      R8,[R7, #+4]
//  764                     memcpy(reinterpret_cast<void*>(lId), pvObjImage, sLV.lsizeobj);
        LDR      R9,[SP, #+4]
        MOV      R2,R9
        MOVS     R1,R5
        MOV      R0,R8
        BL       __aeabi_memcpy
//  765                     (static_cast<LUAreaListElem*>(pv) )->shSizeLU = static_cast<short>(sLV.lsizeobj);
        LDR      R0,[SP, #+4]
        STRH     R0,[R7, #+2]
//  766                     (static_cast<LUAreaListElem*>(pv) )->shIdLU =   static_cast<short>(sLV.lId);
        LDR      R0,[SP, #+0]
        STRH     R0,[R7, #+0]
//  767                     gblLUAreaAuxVar.pvHead = gblLUAreaAuxVar.pvTail =
//  768                             (static_cast<LUAreaListElem*> (pv))->pvLU;
        LDR      R0,[R7, #+4]
        LDR.N    R1,??DataTable5_5
        STR      R0,[R1, #+16]
        LDR.N    R0,??DataTable5_5
        LDR      R0,[R0, #+16]
        LDR.N    R1,??DataTable5_5
        STR      R0,[R1, #+12]
//  769                     //sLV.pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
//  770                     sLV.pCLUBase = static_cast<CLUBase*> (
//  771                             (static_cast<LUAreaListElem*> (pv))->pvLU);
        LDR      R0,[R7, #+4]
        STR      R0,[SP, #+16]
//  772                 }
//  773                 //Bield Obj in Mem
//  774 
//  775 
//  776                 //((LUAreaAuxVar*)pv)-> pvHead
//  777                 sLV.pCLUBase->SetOrderNumber(); //((LUAreaAuxVar*)pv)->shAmountPlacedLogicUnit += 1;
??InsertLU_4:
        LDR      R0,[SP, #+16]
        BL       _ZN7CLUBase14SetOrderNumberEv
//  778                 pv = static_cast<void*>(&gblLUAreaAuxVar);
        LDR.N    R0,??DataTable5_5
        MOVS     R7,R0
//  779                 //?!!!((LUAreaAuxVar*) pv)->lAmountFreeMem -= ((short) sLV.lsizeobj + SIZE_LU_AREA_LIST_ITEM);
//  780                 //?!!!((LUAreaAuxVar*) pv)->lAmountUsedMem += ((short) sLV.lsizeobj + SIZE_LU_AREA_LIST_ITEM);
//  781                 (static_cast<LUAreaAuxVar*> (pv))->lAmountFreeMem -= (sLV.lsizeobj + SIZE_LU_AREA_LIST_ITEM);
        LDR      R0,[R7, #+4]
        LDR      R1,[SP, #+4]
        SUBS     R0,R0,R1
        SUBS     R0,R0,#+8
        STR      R0,[R7, #+4]
//  782                 (static_cast<LUAreaAuxVar*>(pv))->lAmountUsedMem += ( sLV.lsizeobj + SIZE_LU_AREA_LIST_ITEM);
        LDR      R0,[R7, #+8]
        LDR      R1,[SP, #+4]
        ADDS     R0,R1,R0
        ADDS     R0,R0,#+8
        STR      R0,[R7, #+8]
        B.N      ??InsertLU_1
//  783 				
//  784             } else sLV.lsizeobj = 0;
??InsertLU_2:
        MOVS     R0,#+0
        STR      R0,[SP, #+4]
//  785         }
//  786         return static_cast<long>(sLV.lsizeobj);
??InsertLU_1:
        LDR      R0,[SP, #+4]
        B.N      ??InsertLU_5
//  787     }
//  788 
//  789 
//  790 
//  791     return 0; //AmountObj
??InsertLU_0:
        MOVS     R0,#+0
??InsertLU_5:
        ADD      SP,SP,#+20
        POP      {R4-R9,PC}       ;; return
//  792 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5:
        DC32     sh

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_1:
        DC32     __dso_handle

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_2:
        DC32     ar_n__Output_Dsc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_3:
        DC32     ar_n_Output_Dsc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_4:
        DC32     LL_CryaCrya

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_5:
        DC32     gblLUAreaAuxVar

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_6:
        DC32     gLUAreaMem

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_7:
        DC32     _Z7Null_OPPv

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_8:
        DC32     arNum

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_9:
        DC32     shCounterCalls_GLB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_10:
        DC32     _Z10READ_DI_OpPv

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_11:
        DC32     GlobalObjectMap

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_12:
        DC32     _Z10SET_OUT_OpPv

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_13:
        DC32     _Z10SET_LED_OpPv

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable5_14:
        DC32     _Z10AND_Op_8_1Pv
//  793 

        SECTION `.text`:CODE:NOROOT(2)
        THUMB
//  794 void Shematic::DetectCircutLinks(void) {
_ZN8Shematic17DetectCircutLinksEv:
        PUSH     {R4-R7,LR}
        SUB      SP,SP,#+20
        MOVS     R4,R0
//  795     //Register Data In CrossRef Array
//  796     long i, j;
//  797     //    char **pCh;
//  798 
//  799     struct {
//  800         short shAmtLU, shIdx;
//  801         short shCounterScanedObj;
//  802         long lBaseOrdNumStng;
//  803         SBitFld_LUInInfo locSBitFld;
//  804     } sLV;
//  805 
//  806     sLV.shIdx = sLV.shAmtLU = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+0]
        LDRH     R0,[SP, #+0]
        STRH     R0,[SP, #+2]
//  807     if (preSetUP.n_input != 0) {
        LDR.W    R0,??DetectCircutLinks_0
        LDR      R0,[R0, #+4]
        CMP      R0,#+0
        BEQ.N    ??DetectCircutLinks_1
//  808         //Detect Number Input
//  809         sLV.shCounterScanedObj = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+4]
//  810         sLV.shAmtLU = preSetUP.n_input;
        LDR.W    R0,??DetectCircutLinks_0
        LDR      R0,[R0, #+4]
        STRH     R0,[SP, #+0]
//  811         sLV.lBaseOrdNumStng = 0;
        MOVS     R0,#+0
        STR      R0,[SP, #+8]
//  812         j = i = 0;
        MOVS     R0,#+0
        MOVS     R5,R0
        MOVS     R6,R5
//  813         ResetarNum();
        BL       _Z10ResetarNumv
//  814         do {
//  815             //Get Obj by Index
//  816             GetHIDLU(&sLV.lBaseOrdNumStng, sLV.shCounterScanedObj); //HashIdLU
??DetectCircutLinks_2:
        LDRSH    R1,[SP, #+4]
        ADD      R0,SP,#+8
        BL       _Z8GetHIDLUPvl
//  817             //In test read data from External Storage
//  818             if (sLV.lBaseOrdNumStng) {//Element present
        LDR      R0,[SP, #+8]
        CMP      R0,#+0
        BEQ.N    ??DetectCircutLinks_3
//  819                 // i = sLV.shCounterScanedObj; 
//  820                 arrSBitFldCRefInfo[i+ j].bfInfo_BaseID = sLV.lBaseOrdNumStng;
        LDR.W    R0,??DetectCircutLinks_0+0x4
        ADDS     R1,R6,R5
        ADDS     R0,R0,R1, LSL #+3
        LDR      R1,[SP, #+8]
        LDR.W    R2,??DetectCircutLinks_0+0x4
        ADDS     R3,R6,R5
        ADDS     R2,R2,R3, LSL #+3
        LDR      R2,[R2, #+4]
        BFI      R2,R1,#+0,#+8
        STR      R2,[R0, #+4]
//  821                 arrSBitFldCRefInfo[i+ j].bfInfo_OrdNumIn = 1;
        LDR.W    R0,??DetectCircutLinks_0+0x4
        ADDS     R1,R6,R5
        ADDS     R0,R0,R1, LSL #+3
        MOVS     R1,#+1
        LDR.W    R2,??DetectCircutLinks_0+0x4
        ADDS     R3,R6,R5
        ADDS     R2,R2,R3, LSL #+3
        LDR      R2,[R2, #+4]
        BFI      R2,R1,#+8,#+5
        STR      R2,[R0, #+4]
//  822                 arrSBitFldCRefInfo[i+ j].sBitLUInputInfo = ar_n__Output_Dsc[j];
        LDR.W    R0,??DataTable9
        LDR      R0,[R0, R6, LSL #+2]
        LDR.W    R1,??DetectCircutLinks_0+0x4
        ADDS     R2,R6,R5
        STR      R0,[R1, R2, LSL #+3]
//  823                 j++;
        ADDS     R6,R6,#+1
//  824             }
//  825         } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
??DetectCircutLinks_3:
        LDRH     R0,[SP, #+4]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+4]
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+0]
        CMP      R0,R1
        BLT.N    ??DetectCircutLinks_2
//  826     }
//  827     if (preSetUP.n_output != 0) {
??DetectCircutLinks_1:
        LDR.W    R0,??DetectCircutLinks_0
        LDR      R0,[R0, #+8]
        CMP      R0,#+0
        BEQ.N    ??DetectCircutLinks_4
//  828         //Detect Number Input
//  829         sLV.shCounterScanedObj = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+4]
//  830         sLV.shAmtLU = preSetUP.n_output;
        LDR.W    R0,??DetectCircutLinks_0
        LDR      R0,[R0, #+8]
        STRH     R0,[SP, #+0]
//  831         j = 0; //Idx in OutPut for Test
        MOVS     R0,#+0
        MOVS     R6,R0
//  832         sLV.shIdx += preSetUP.n_input;
        LDRH     R0,[SP, #+2]
        LDR.W    R1,??DetectCircutLinks_0
        LDR      R1,[R1, #+4]
        ADDS     R0,R1,R0
        STRH     R0,[SP, #+2]
//  833         i = sLV.shIdx;//Offset Output
        LDRSH    R0,[SP, #+2]
        MOVS     R5,R0
//  834         ResetarNum();
        BL       _Z10ResetarNumv
//  835         do {
//  836             //Get Obj
//  837             GetHIDLU(&sLV.lBaseOrdNumStng, sLV.shCounterScanedObj);
??DetectCircutLinks_5:
        LDRSH    R1,[SP, #+4]
        ADD      R0,SP,#+8
        BL       _Z8GetHIDLUPvl
//  838             //In test read data from External Storage
//  839             if (sLV.lBaseOrdNumStng) {//Element present
        LDR      R0,[SP, #+8]
        CMP      R0,#+0
        BEQ.N    ??DetectCircutLinks_6
//  840                 i = sLV.shCounterScanedObj+sLV.shIdx;
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+2]
        ADDS     R0,R1,R0
        MOVS     R5,R0
//  841                 arrSBitFldCRefInfo[i].bfInfo_BaseID = sLV.lBaseOrdNumStng;
        LDR      R0,[SP, #+8]
        LDR.N    R1,??DetectCircutLinks_0+0x4
        ADDS     R1,R1,R5, LSL #+3
        LDR      R1,[R1, #+4]
        BFI      R1,R0,#+0,#+8
        LDR.N    R0,??DetectCircutLinks_0+0x4
        ADDS     R0,R0,R5, LSL #+3
        STR      R1,[R0, #+4]
//  842                 arrSBitFldCRefInfo[i].bfInfo_OrdNumIn = 1;
        MOVS     R0,#+1
        LDR.N    R1,??DetectCircutLinks_0+0x4
        ADDS     R1,R1,R5, LSL #+3
        LDR      R1,[R1, #+4]
        BFI      R1,R0,#+8,#+5
        LDR.N    R0,??DetectCircutLinks_0+0x4
        ADDS     R0,R0,R5, LSL #+3
        STR      R1,[R0, #+4]
//  843                 arrSBitFldCRefInfo[i].sBitLUInputInfo = ar_n__Output_Dsc[j];//Take data from Taras
        LDR.W    R0,??DataTable9
        LDR      R0,[R0, R6, LSL #+2]
        LDR.N    R1,??DetectCircutLinks_0+0x4
        STR      R0,[R1, R5, LSL #+3]
//  844                 j++;
        ADDS     R6,R6,#+1
//  845             }
//  846         } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
??DetectCircutLinks_6:
        LDRH     R0,[SP, #+4]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+4]
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+0]
        CMP      R0,R1
        BLT.N    ??DetectCircutLinks_5
//  847     }
//  848     if (preSetUP.n_led != 0) {
??DetectCircutLinks_4:
        LDR.N    R0,??DetectCircutLinks_0
        LDR      R0,[R0, #+12]
        CMP      R0,#+0
        BEQ.N    ??DetectCircutLinks_7
//  849         //Detect Number Input
//  850         sLV.shCounterScanedObj = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+4]
//  851         sLV.shAmtLU = preSetUP.n_led;
        LDR.N    R0,??DetectCircutLinks_0
        LDR      R0,[R0, #+12]
        STRH     R0,[SP, #+0]
//  852         j = 0; //Idx in OutPut for Test
        MOVS     R0,#+0
        MOVS     R6,R0
//  853         sLV.shIdx += preSetUP.n_output*shCLUDout_1_0_AmtIn;
        LDRH     R0,[SP, #+2]
        LDR.N    R1,??DetectCircutLinks_0
        LDR      R1,[R1, #+8]
        ADDS     R0,R1,R0
        STRH     R0,[SP, #+2]
//  854         ResetarNum();
        BL       _Z10ResetarNumv
//  855         do {
//  856             //Get Obj
//  857             GetHIDLU(&sLV.lBaseOrdNumStng, sLV.shCounterScanedObj); //HashIdLU
??DetectCircutLinks_8:
        LDRSH    R1,[SP, #+4]
        ADD      R0,SP,#+8
        BL       _Z8GetHIDLUPvl
//  858             //In test read data from External Storage
//  859             if (sLV.lBaseOrdNumStng) {//Element present
        LDR      R0,[SP, #+8]
        CMP      R0,#+0
        BEQ.N    ??DetectCircutLinks_9
//  860                  i = sLV.shCounterScanedObj+sLV.shIdx;
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+2]
        ADDS     R0,R1,R0
        MOVS     R5,R0
//  861                 arrSBitFldCRefInfo[i].bfInfo_BaseID = sLV.lBaseOrdNumStng;
        LDR      R0,[SP, #+8]
        LDR.N    R1,??DetectCircutLinks_0+0x4
        ADDS     R1,R1,R5, LSL #+3
        LDR      R1,[R1, #+4]
        BFI      R1,R0,#+0,#+8
        LDR.N    R0,??DetectCircutLinks_0+0x4
        ADDS     R0,R0,R5, LSL #+3
        STR      R1,[R0, #+4]
//  862                 arrSBitFldCRefInfo[i].bfInfo_OrdNumIn = 1;
        MOVS     R0,#+1
        LDR.N    R1,??DetectCircutLinks_0+0x4
        ADDS     R1,R1,R5, LSL #+3
        LDR      R1,[R1, #+4]
        BFI      R1,R0,#+8,#+5
        LDR.N    R0,??DetectCircutLinks_0+0x4
        ADDS     R0,R0,R5, LSL #+3
        STR      R1,[R0, #+4]
//  863                 arrSBitFldCRefInfo[i].sBitLUInputInfo = ar_n__Output_Dsc[j];
        LDR.W    R0,??DataTable9
        LDR      R0,[R0, R6, LSL #+2]
        LDR.N    R1,??DetectCircutLinks_0+0x4
        STR      R0,[R1, R5, LSL #+3]
//  864                 j++;
        ADDS     R6,R6,#+1
//  865             }
//  866 
//  867         } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
??DetectCircutLinks_9:
        LDRH     R0,[SP, #+4]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+4]
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+0]
        CMP      R0,R1
        BLT.N    ??DetectCircutLinks_8
//  868     }
//  869     if (preSetUP.n_and != 0) {
??DetectCircutLinks_7:
        LDR.N    R0,??DetectCircutLinks_0
        LDR      R0,[R0, #+16]
        CMP      R0,#+0
        BEQ.N    ??DetectCircutLinks_10
//  870         //Detect Number Input
//  871         sLV.shCounterScanedObj = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+4]
//  872         sLV.shAmtLU = preSetUP.n_and;
        LDR.N    R0,??DetectCircutLinks_0
        LDR      R0,[R0, #+16]
        STRH     R0,[SP, #+0]
//  873         j = 0; //Idx in OutPut for Test
        MOVS     R0,#+0
        MOVS     R6,R0
//  874         sLV.shIdx += preSetUP.n_led*shCLULed_1_0_AmtIn;
        LDRH     R0,[SP, #+2]
        LDR.N    R1,??DetectCircutLinks_0
        LDR      R1,[R1, #+12]
        ADDS     R0,R1,R0
        STRH     R0,[SP, #+2]
//  875         i = sLV.shIdx;
        LDRSH    R0,[SP, #+2]
        MOVS     R5,R0
//  876         ResetarNum();
        BL       _Z10ResetarNumv
//  877         do {
//  878             //Get Obj
//  879             GetHIDLU(&sLV.lBaseOrdNumStng, sLV.shCounterScanedObj); //HashIdLU
??DetectCircutLinks_11:
        LDRSH    R1,[SP, #+4]
        ADD      R0,SP,#+8
        BL       _Z8GetHIDLUPvl
//  880             //In test read data from External Storage
//  881             if (sLV.lBaseOrdNumStng) {//Element present
        LDR      R0,[SP, #+8]
        CMP      R0,#+0
        BEQ.N    ??DetectCircutLinks_12
//  882                  i = sLV.shCounterScanedObj*shCLUAnd_8_1_AmtIn+sLV.shIdx;
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+2]
        ADDS     R0,R1,R0, LSL #+3
        MOVS     R5,R0
//  883                 SBitFld_LUInInfo locSBitFld_LUInInfo;//LUInInfoDsc locLUInInfoDsc; 
//  884                 for (long ik = 0; ik < shCLUAnd_8_1_AmtIn; ik++) {
        MOVS     R1,#+0
??DetectCircutLinks_13:
        CMP      R1,#+8
        BGE.N    ??DetectCircutLinks_12
//  885                     arrSBitFldCRefInfo[i+ik].bfInfo_BaseID = sLV.lBaseOrdNumStng;
        LDR.N    R2,??DetectCircutLinks_0+0x4
        ADDS     R3,R1,R5
        ADDS     R2,R2,R3, LSL #+3
        LDR      R3,[SP, #+8]
        LDR.N    R7,??DetectCircutLinks_0+0x4
        ADDS     R12,R1,R5
        ADDS     R7,R7,R12, LSL #+3
        LDR      R7,[R7, #+4]
        BFI      R7,R3,#+0,#+8
        STR      R7,[R2, #+4]
//  886                     arrSBitFldCRefInfo[i+ik].bfInfo_OrdNumIn = 1+ik;
        LDR.N    R2,??DetectCircutLinks_0+0x4
        ADDS     R3,R1,R5
        ADDS     R2,R2,R3, LSL #+3
        ADDS     R3,R1,#+1
        LDR.N    R7,??DetectCircutLinks_0+0x4
        ADDS     R12,R1,R5
        ADDS     R7,R7,R12, LSL #+3
        LDR      R7,[R7, #+4]
        BFI      R7,R3,#+8,#+5
        STR      R7,[R2, #+4]
//  887                     
//  888                     locSBitFld_LUInInfo.bfInfo_OrdNumOut  = ar_n_And_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_OrdNumOut;
        LDR.W    R2,??DataTable12
        LDR      R2,[R2, R6, LSL #+2]
        BFI      R0,R2,#+0,#+16
//  889                     locSBitFld_LUInInfo.bfInfo_IdLUStng   = ar_n_And_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_IdLUStng;
        LDR.W    R2,??DataTable12
        LDR      R2,[R2, R6, LSL #+2]
        LSRS     R2,R2,#+24
        BFI      R0,R2,#+24,#+8
//  890                     locSBitFld_LUInInfo.bfInfo_OrdNumStng = ar_n_And_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_OrdNumStng;
        LDR.W    R2,??DataTable12
        LDR      R2,[R2, R6, LSL #+2]
        LSRS     R2,R2,#+16
        BFI      R0,R2,#+16,#+8
//  891                     arrSBitFldCRefInfo[i+ik].sBitLUInputInfo = locSBitFld_LUInInfo;
        LDR.N    R2,??DetectCircutLinks_0+0x4
        ADDS     R3,R1,R5
        STR      R0,[R2, R3, LSL #+3]
//  892                             //ar_n_And_Dsc[j+i+ik].UN_BitFld_LUInInfo.sBitFld_LUInInfo;
//  893                     j++;//Can take change in any aviable way
        ADDS     R6,R6,#+1
//  894                     
//  895                 }
        ADDS     R1,R1,#+1
        B.N      ??DetectCircutLinks_13
//  896 
//  897                 
//  898             }
//  899 
//  900         } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
??DetectCircutLinks_12:
        LDRH     R0,[SP, #+4]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+4]
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+0]
        CMP      R0,R1
        BLT.N    ??DetectCircutLinks_11
//  901     }
//  902     if (preSetUP.n_or != 0) {
??DetectCircutLinks_10:
        LDR.N    R0,??DetectCircutLinks_0
        LDR      R0,[R0, #+20]
        CMP      R0,#+0
        BEQ.N    ??DetectCircutLinks_14
//  903         //Detect Number Input
//  904         sLV.shCounterScanedObj = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+4]
//  905         sLV.shAmtLU = preSetUP.n_or;
        LDR.N    R0,??DetectCircutLinks_0
        LDR      R0,[R0, #+20]
        STRH     R0,[SP, #+0]
//  906          j = 0; //Idx in OutPut for Test
        MOVS     R0,#+0
        MOVS     R6,R0
//  907         sLV.shIdx += preSetUP.n_and*shCLUAnd_8_1_AmtIn;
        LDRSH    R0,[SP, #+2]
        LDR.N    R1,??DetectCircutLinks_0
        LDR      R1,[R1, #+16]
        ADDS     R0,R0,R1, LSL #+3
        STRH     R0,[SP, #+2]
//  908         i = sLV.shIdx;
        LDRSH    R0,[SP, #+2]
        MOVS     R5,R0
//  909         ResetarNum();
        BL       _Z10ResetarNumv
//  910         do {
//  911             //Get Obj
//  912             GetHIDLU(&sLV.lBaseOrdNumStng, sLV.shCounterScanedObj);
??DetectCircutLinks_15:
        LDRSH    R1,[SP, #+4]
        ADD      R0,SP,#+8
        BL       _Z8GetHIDLUPvl
//  913             //In test read data from External Storage
//  914             if (sLV.lBaseOrdNumStng) {//Element present
        LDR      R0,[SP, #+8]
        CMP      R0,#+0
        BEQ.N    ??DetectCircutLinks_16
//  915                  i = sLV.shCounterScanedObj*shCLUOr_8_1_AmtIn+sLV.shIdx;
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+2]
        ADDS     R0,R1,R0, LSL #+3
        MOVS     R5,R0
//  916                 SBitFld_LUInInfo locSBitFld_LUInInfo;//LUInInfoDsc locLUInInfoDsc; 
//  917                 for (long ik = 0; ik < shCLUOr_8_1_AmtIn; ik++) {
        MOVS     R1,#+0
??DetectCircutLinks_17:
        CMP      R1,#+8
        BGE.N    ??DetectCircutLinks_16
//  918                     arrSBitFldCRefInfo[i+ik].bfInfo_BaseID = sLV.lBaseOrdNumStng;
        LDR.N    R2,??DetectCircutLinks_0+0x4
        ADDS     R3,R1,R5
        ADDS     R2,R2,R3, LSL #+3
        LDR      R3,[SP, #+8]
        LDR.N    R7,??DetectCircutLinks_0+0x4
        ADDS     R12,R1,R5
        ADDS     R7,R7,R12, LSL #+3
        LDR      R7,[R7, #+4]
        BFI      R7,R3,#+0,#+8
        STR      R7,[R2, #+4]
//  919                     arrSBitFldCRefInfo[i+ik].bfInfo_OrdNumIn = 1+ik;
        LDR.N    R2,??DetectCircutLinks_0+0x4
        ADDS     R3,R1,R5
        ADDS     R2,R2,R3, LSL #+3
        ADDS     R3,R1,#+1
        LDR.N    R7,??DetectCircutLinks_0+0x4
        ADDS     R12,R1,R5
        ADDS     R7,R7,R12, LSL #+3
        LDR      R7,[R7, #+4]
        BFI      R7,R3,#+8,#+5
        STR      R7,[R2, #+4]
//  920                     
//  921                     locSBitFld_LUInInfo.bfInfo_OrdNumOut  = ar_n_Or_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_OrdNumOut;
        LDR.W    R2,??DataTable13
        LDR      R2,[R2, R6, LSL #+2]
        BFI      R0,R2,#+0,#+16
//  922                     locSBitFld_LUInInfo.bfInfo_IdLUStng   = ar_n_Or_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_IdLUStng;
        LDR.W    R2,??DataTable13
        LDR      R2,[R2, R6, LSL #+2]
        LSRS     R2,R2,#+24
        BFI      R0,R2,#+24,#+8
//  923                     locSBitFld_LUInInfo.bfInfo_OrdNumStng = ar_n_Or_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_OrdNumStng;
        LDR.W    R2,??DataTable13
        LDR      R2,[R2, R6, LSL #+2]
        LSRS     R2,R2,#+16
        BFI      R0,R2,#+16,#+8
//  924                     arrSBitFldCRefInfo[i+ik].sBitLUInputInfo = locSBitFld_LUInInfo;
        LDR.N    R2,??DetectCircutLinks_0+0x4
        ADDS     R3,R1,R5
        STR      R0,[R2, R3, LSL #+3]
//  925                          
//  926                     j++;//Can take change in any aviable way
        ADDS     R6,R6,#+1
//  927                 }
        ADDS     R1,R1,#+1
        B.N      ??DetectCircutLinks_17
//  928             }
//  929         } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
??DetectCircutLinks_16:
        LDRH     R0,[SP, #+4]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+4]
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+0]
        CMP      R0,R1
        BLT.N    ??DetectCircutLinks_15
//  930     }
//  931     if (preSetUP.n_xor != 0) {
??DetectCircutLinks_14:
        LDR.N    R0,??DetectCircutLinks_0
        LDR      R0,[R0, #+24]
        CMP      R0,#+0
        BEQ.N    ??DetectCircutLinks_18
//  932         //Detect Number Input
//  933         sLV.shCounterScanedObj = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+4]
//  934         sLV.shAmtLU = preSetUP.n_xor;
        LDR.N    R0,??DetectCircutLinks_0
        LDR      R0,[R0, #+24]
        STRH     R0,[SP, #+0]
//  935          j = 0; //Idx in OutPut for Test
        MOVS     R0,#+0
        MOVS     R6,R0
//  936         sLV.shIdx += preSetUP.n_or*shCLUOr_8_1_AmtIn;
        LDRSH    R0,[SP, #+2]
        LDR.N    R1,??DetectCircutLinks_0
        LDR      R1,[R1, #+20]
        ADDS     R0,R0,R1, LSL #+3
        STRH     R0,[SP, #+2]
//  937         i = sLV.shIdx;
        LDRSH    R0,[SP, #+2]
        MOVS     R5,R0
//  938         ResetarNum();
        BL       _Z10ResetarNumv
//  939         do {
//  940             //Get Obj
//  941             GetHIDLU(&sLV.lBaseOrdNumStng, sLV.shCounterScanedObj);
??DetectCircutLinks_19:
        LDRSH    R1,[SP, #+4]
        ADD      R0,SP,#+8
        BL       _Z8GetHIDLUPvl
//  942             //In test read data from External Storage
//  943             if (sLV.lBaseOrdNumStng) {//Element present
        LDR      R0,[SP, #+8]
        CMP      R0,#+0
        BEQ.N    ??DetectCircutLinks_20
//  944                  i = sLV.shCounterScanedObj*shCLUXor_2_1_AmtIn+sLV.shIdx;
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+2]
        ADDS     R0,R1,R0, LSL #+1
        MOVS     R5,R0
//  945                 SBitFld_LUInInfo locSBitFld_LUInInfo;//LUInInfoDsc locLUInInfoDsc; 
//  946                 for (long ik = 0; ik < shCLUXor_2_1_AmtIn; ik++) {
        MOVS     R1,#+0
??DetectCircutLinks_21:
        CMP      R1,#+2
        BGE.N    ??DetectCircutLinks_20
//  947                     arrSBitFldCRefInfo[i+ik].bfInfo_BaseID = sLV.lBaseOrdNumStng;
        LDR.N    R2,??DetectCircutLinks_0+0x4
        ADDS     R3,R1,R5
        ADDS     R2,R2,R3, LSL #+3
        LDR      R3,[SP, #+8]
        LDR.N    R7,??DetectCircutLinks_0+0x4
        ADDS     R12,R1,R5
        ADDS     R7,R7,R12, LSL #+3
        LDR      R7,[R7, #+4]
        BFI      R7,R3,#+0,#+8
        STR      R7,[R2, #+4]
//  948                     arrSBitFldCRefInfo[i+ik].bfInfo_OrdNumIn = 1+ik;
        LDR.N    R2,??DetectCircutLinks_0+0x4
        ADDS     R3,R1,R5
        ADDS     R2,R2,R3, LSL #+3
        ADDS     R3,R1,#+1
        LDR.N    R7,??DetectCircutLinks_0+0x4
        ADDS     R12,R1,R5
        ADDS     R7,R7,R12, LSL #+3
        LDR      R7,[R7, #+4]
        BFI      R7,R3,#+8,#+5
        STR      R7,[R2, #+4]
//  949                     
//  950                     locSBitFld_LUInInfo.bfInfo_OrdNumOut  = ar_n_Xor_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_OrdNumOut;
        LDR.W    R2,??DataTable14
        LDR      R2,[R2, R6, LSL #+2]
        BFI      R0,R2,#+0,#+16
//  951                     locSBitFld_LUInInfo.bfInfo_IdLUStng   = ar_n_Xor_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_IdLUStng;
        LDR.W    R2,??DataTable14
        LDR      R2,[R2, R6, LSL #+2]
        LSRS     R2,R2,#+24
        BFI      R0,R2,#+24,#+8
//  952                     locSBitFld_LUInInfo.bfInfo_OrdNumStng = ar_n_Xor_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_OrdNumStng;
        LDR.W    R2,??DataTable14
        B.N      ??DetectCircutLinks_22
        DATA
??DetectCircutLinks_0:
        DC32     preSetUP
        DC32     arrSBitFldCRefInfo
        THUMB
??DetectCircutLinks_22:
        LDR      R2,[R2, R6, LSL #+2]
        LSRS     R2,R2,#+16
        BFI      R0,R2,#+16,#+8
//  953                     arrSBitFldCRefInfo[i+ik].sBitLUInputInfo = locSBitFld_LUInInfo;
        LDR.W    R2,??DataTable16
        ADDS     R3,R1,R5
        STR      R0,[R2, R3, LSL #+3]
//  954                          
//  955                     j++;//Can take change in any aviable way
        ADDS     R6,R6,#+1
//  956                 }
        ADDS     R1,R1,#+1
        B.N      ??DetectCircutLinks_21
//  957             }
//  958 
//  959         } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
??DetectCircutLinks_20:
        LDRH     R0,[SP, #+4]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+4]
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+0]
        CMP      R0,R1
        BLT.N    ??DetectCircutLinks_19
//  960     }
//  961     if (preSetUP.n_not != 0) {
??DetectCircutLinks_18:
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+28]
        CMP      R0,#+0
        BEQ.N    ??DetectCircutLinks_23
//  962         //Detect Number Input
//  963         sLV.shCounterScanedObj = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+4]
//  964         sLV.shAmtLU = preSetUP.n_not;
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+28]
        STRH     R0,[SP, #+0]
//  965          j = 0; //Idx in OutPut for Test
        MOVS     R0,#+0
        MOVS     R6,R0
//  966         sLV.shIdx += preSetUP.n_xor*shCLUXor_2_1_AmtIn;
        LDRSH    R0,[SP, #+2]
        LDR.W    R1,??DataTable17
        LDR      R1,[R1, #+24]
        ADDS     R0,R0,R1, LSL #+1
        STRH     R0,[SP, #+2]
//  967         i = sLV.shIdx;
        LDRSH    R0,[SP, #+2]
        MOVS     R5,R0
//  968         ResetarNum();
        BL       _Z10ResetarNumv
//  969         do {
//  970             //Get Obj
//  971             GetHIDLU(&sLV.lBaseOrdNumStng, sLV.shCounterScanedObj);
??DetectCircutLinks_24:
        LDRSH    R1,[SP, #+4]
        ADD      R0,SP,#+8
        BL       _Z8GetHIDLUPvl
//  972             //In test read data from External Storage
//  973             if (sLV.lBaseOrdNumStng) {//Element present
        LDR      R0,[SP, #+8]
        CMP      R0,#+0
        BEQ.N    ??DetectCircutLinks_25
//  974                  i = sLV.shCounterScanedObj*shCLUNot_1_1_AmtIn+sLV.shIdx;
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+2]
        ADDS     R0,R1,R0
        MOVS     R5,R0
//  975                 SBitFld_LUInInfo locSBitFld_LUInInfo;//LUInInfoDsc locLUInInfoDsc; 
//  976                 for (long ik = 0; ik < shCLUNot_1_1_AmtIn; ik++) {
        MOVS     R1,#+0
??DetectCircutLinks_26:
        CMP      R1,#+1
        BGE.N    ??DetectCircutLinks_25
//  977                     arrSBitFldCRefInfo[i+ik].bfInfo_BaseID = sLV.lBaseOrdNumStng;
        LDR.W    R2,??DataTable16
        ADDS     R3,R1,R5
        ADDS     R2,R2,R3, LSL #+3
        LDR      R3,[SP, #+8]
        LDR.W    R7,??DataTable16
        ADDS     R12,R1,R5
        ADDS     R7,R7,R12, LSL #+3
        LDR      R7,[R7, #+4]
        BFI      R7,R3,#+0,#+8
        STR      R7,[R2, #+4]
//  978                     arrSBitFldCRefInfo[i+ik].bfInfo_OrdNumIn = 1+ik;
        LDR.W    R2,??DataTable16
        ADDS     R3,R1,R5
        ADDS     R2,R2,R3, LSL #+3
        ADDS     R3,R1,#+1
        LDR.W    R7,??DataTable16
        ADDS     R12,R1,R5
        ADDS     R7,R7,R12, LSL #+3
        LDR      R7,[R7, #+4]
        BFI      R7,R3,#+8,#+5
        STR      R7,[R2, #+4]
//  979                     
//  980                     locSBitFld_LUInInfo.bfInfo_OrdNumOut  = ar_n_Not_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_OrdNumOut;
        LDR.W    R2,??DataTable15
        LDR      R2,[R2, R6, LSL #+2]
        BFI      R0,R2,#+0,#+16
//  981                     locSBitFld_LUInInfo.bfInfo_IdLUStng   = ar_n_Not_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_IdLUStng;
        LDR.W    R2,??DataTable15
        LDR      R2,[R2, R6, LSL #+2]
        LSRS     R2,R2,#+24
        BFI      R0,R2,#+24,#+8
//  982                     locSBitFld_LUInInfo.bfInfo_OrdNumStng = ar_n_Not_Dsc[j].UN_BitFld_LUInInfo.sBitFld_LUInInfo.bfInfo_OrdNumStng;
        LDR.W    R2,??DataTable15
        LDR      R2,[R2, R6, LSL #+2]
        LSRS     R2,R2,#+16
        BFI      R0,R2,#+16,#+8
//  983                     arrSBitFldCRefInfo[i+ik].sBitLUInputInfo = locSBitFld_LUInInfo;
        LDR.W    R2,??DataTable16
        ADDS     R3,R1,R5
        STR      R0,[R2, R3, LSL #+3]
//  984                          
//  985                     j++;//Can take change in any aviable way
        ADDS     R6,R6,#+1
//  986                 }
        ADDS     R1,R1,#+1
        B.N      ??DetectCircutLinks_26
//  987             }
//  988         } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
??DetectCircutLinks_25:
        LDRH     R0,[SP, #+4]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+4]
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+0]
        CMP      R0,R1
        BLT.N    ??DetectCircutLinks_24
//  989     }
//  990     sLV.shIdx = 0;
??DetectCircutLinks_23:
        MOVS     R0,#+0
        STRH     R0,[SP, #+2]
//  991 //Set Actual Links
//  992     if (preSetUP.n_input != 0) {
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+4]
        CMP      R0,#+0
        BEQ.W    ??DetectCircutLinks_27
//  993         //Detect Number Input
//  994         sLV.shCounterScanedObj = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+4]
//  995         sLV.shAmtLU = preSetUP.n_input;
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+4]
        STRH     R0,[SP, #+0]
//  996         sLV.lBaseOrdNumStng = 0;
        MOVS     R0,#+0
        STR      R0,[SP, #+8]
//  997         j = i = 0;
        MOVS     R0,#+0
        MOVS     R5,R0
        MOVS     R6,R5
//  998         SBitFld_LUInInfo locSBitFld_LUInInfo;
//  999         short shRelativeNumber = 0;
        MOVS     R1,#+0
// 1000         short shIdLUStng       = 0;
        MOVS     R2,#+0
// 1001         short shIdx_arrSBitFldCRefInfo = 0;
        MOVS     R3,#+0
// 1002         do {
// 1003             //Change offset on real Number 
// 1004             i = sLV.shCounterScanedObj; //
??DetectCircutLinks_28:
        LDRSH    R7,[SP, #+4]
        MOVS     R5,R7
// 1005             locSBitFld_LUInInfo = arrSBitFldCRefInfo[i].sBitLUInputInfo;
        LDR.W    R7,??DataTable16
        LDR      R7,[R7, R5, LSL #+3]
        MOVS     R0,R7
// 1006             shIdLUStng          = locSBitFld_LUInInfo.bfInfo_IdLUStng;
        LSRS     R7,R0,#+24
        MOVS     R2,R7
// 1007             //Get Index in LU sequence
// 1008             switch (shIdLUStng) {
        SXTH     R2,R2            ;; SignExt  R2,R2,#+16,#+16
        MOVS     R7,R2
        CMP      R7,#+4
        BEQ.N    ??DetectCircutLinks_29
        CMP      R7,#+5
        BEQ.N    ??DetectCircutLinks_30
        CMP      R7,#+6
        BEQ.N    ??DetectCircutLinks_31
        CMP      R7,#+11
        BEQ.N    ??DetectCircutLinks_32
        CMP      R7,#+12
        BEQ.N    ??DetectCircutLinks_33
        CMP      R7,#+13
        BEQ.N    ??DetectCircutLinks_34
        CMP      R7,#+14
        BEQ.N    ??DetectCircutLinks_35
        B.N      ??DetectCircutLinks_36
// 1009                 case STNG_LU_AND:
// 1010                     shIdx_arrSBitFldCRefInfo = preSetUP.n_input
// 1011                      + preSetUP.n_output + preSetUP.n_led;
??DetectCircutLinks_29:
        LDR.W    R7,??DataTable17
        LDR      R7,[R7, #+4]
        LDR.W    R12,??DataTable17
        LDR      R12,[R12, #+8]
        ADDS     R7,R12,R7
        LDR.W    R12,??DataTable17
        LDR      R12,[R12, #+12]
        ADDS     R7,R12,R7
        MOVS     R3,R7
// 1012                     break;
        B.N      ??DetectCircutLinks_37
// 1013                     
// 1014                 case STNG_LU_OR:
// 1015                      shIdx_arrSBitFldCRefInfo = preSetUP.n_input
// 1016                      + preSetUP.n_output + preSetUP.n_led + shCLUAnd_8_1_AmtIn*preSetUP.n_and;
??DetectCircutLinks_30:
        LDR.W    R7,??DataTable17
        LDR      R7,[R7, #+4]
        LDR.W    R12,??DataTable17
        LDR      R12,[R12, #+8]
        ADDS     R7,R12,R7
        LDR.W    R12,??DataTable17
        LDR      R12,[R12, #+12]
        ADDS     R7,R12,R7
        LDR.W    R12,??DataTable17
        LDR      R12,[R12, #+16]
        ADDS     R7,R7,R12, LSL #+3
        MOVS     R3,R7
// 1017                     break;
        B.N      ??DetectCircutLinks_37
// 1018                     
// 1019                 case STNG_LU_XOR:
// 1020                     shIdx_arrSBitFldCRefInfo = preSetUP.n_input
// 1021                      + preSetUP.n_output + preSetUP.n_led + shCLUAnd_8_1_AmtIn*preSetUP.n_and
// 1022                      + shCLUOr_8_1_AmtIn*preSetUP.n_or ;
??DetectCircutLinks_31:
        LDR.W    R7,??DataTable17
        LDR      R7,[R7, #+4]
        LDR.W    R12,??DataTable17
        LDR      R12,[R12, #+8]
        ADDS     R7,R12,R7
        LDR.W    R12,??DataTable17
        LDR      R12,[R12, #+12]
        ADDS     R7,R12,R7
        LDR.W    R12,??DataTable17
        LDR      R12,[R12, #+16]
        ADDS     R7,R7,R12, LSL #+3
        LDR.W    R12,??DataTable17
        LDR      R12,[R12, #+20]
        ADDS     R7,R7,R12, LSL #+3
        MOVS     R3,R7
// 1023                     break;
        B.N      ??DetectCircutLinks_37
// 1024                     
// 1025                 case STNG_LU_INPUT:
// 1026                     shIdx_arrSBitFldCRefInfo = 0;
??DetectCircutLinks_32:
        MOVS     R7,#+0
        MOVS     R3,R7
// 1027                     break;
        B.N      ??DetectCircutLinks_37
// 1028                     
// 1029                 case STNG_LU_OUTPUT:
// 1030                     shIdx_arrSBitFldCRefInfo = preSetUP.n_input;
??DetectCircutLinks_33:
        LDR.W    R7,??DataTable17
        LDR      R7,[R7, #+4]
        MOVS     R3,R7
// 1031                     break;
        B.N      ??DetectCircutLinks_37
// 1032                     
// 1033                 case STNG_LU_LED:
// 1034                     shIdx_arrSBitFldCRefInfo = preSetUP.n_input
// 1035                         +preSetUP.n_output;
??DetectCircutLinks_34:
        LDR.W    R7,??DataTable17
        LDR      R7,[R7, #+4]
        LDR.W    R12,??DataTable17
        LDR      R12,[R12, #+8]
        ADDS     R7,R12,R7
        MOVS     R3,R7
// 1036                     break;
        B.N      ??DetectCircutLinks_37
// 1037                     
// 1038                 case STNG_LU_NOT:
// 1039                        shIdx_arrSBitFldCRefInfo = preSetUP.n_input
// 1040                      + preSetUP.n_output + preSetUP.n_led + shCLUAnd_8_1_AmtIn*preSetUP.n_and
// 1041                      + shCLUOr_8_1_AmtIn*preSetUP.n_or + shCLUXor_2_1_AmtIn*preSetUP.n_xor ;
??DetectCircutLinks_35:
        LDR.W    R7,??DataTable17
        LDR      R7,[R7, #+4]
        LDR.W    R12,??DataTable17
        LDR      R12,[R12, #+8]
        ADDS     R7,R12,R7
        LDR.W    R12,??DataTable17
        LDR      R12,[R12, #+12]
        ADDS     R7,R12,R7
        LDR.W    R12,??DataTable17
        LDR      R12,[R12, #+16]
        ADDS     R7,R7,R12, LSL #+3
        LDR.W    R12,??DataTable17
        LDR      R12,[R12, #+20]
        ADDS     R7,R7,R12, LSL #+3
        LDR.W    R12,??DataTable17
        LDR      R12,[R12, #+24]
        ADDS     R7,R7,R12, LSL #+1
        MOVS     R3,R7
// 1042                     break;
        B.N      ??DetectCircutLinks_37
// 1043                     
// 1044                     
// 1045                 default:
// 1046                     shIdx_arrSBitFldCRefInfo = -1;
??DetectCircutLinks_36:
        MOVS     R7,#-1
        MOVS     R3,R7
// 1047             }
// 1048              
// 1049             shRelativeNumber = locSBitFld_LUInInfo.bfInfo_OrdNumStng;
??DetectCircutLinks_37:
        LSRS     R7,R0,#+16
        UXTB     R7,R7            ;; ZeroExt  R7,R7,#+24,#+24
        MOVS     R1,R7
// 1050             if(shIdx_arrSBitFldCRefInfo!= (-1)){
        SXTH     R3,R3            ;; SignExt  R3,R3,#+16,#+16
        CMN      R3,#+1
        BEQ.N    ??DetectCircutLinks_38
// 1051             //Find Element
// 1052                     j = shIdx_arrSBitFldCRefInfo + shRelativeNumber-1;//Only Now
        SXTH     R3,R3            ;; SignExt  R3,R3,#+16,#+16
        SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
        ADDS     R7,R1,R3
        SUBS     R7,R7,#+1
        MOVS     R6,R7
// 1053                     locSBitFld_LUInInfo.bfInfo_OrdNumStng = arrSBitFldCRefInfo[j].bfInfo_BaseID; //sLV.lBaseOrdNumStng
        LDR.W    R7,??DataTable16
        ADDS     R7,R7,R6, LSL #+3
        LDR      R7,[R7, #+4]
        BFI      R0,R7,#+16,#+8
// 1054                     arrSBitFldCRefInfo[i].sBitLUInputInfo.bfInfo_OrdNumStng
// 1055                             = locSBitFld_LUInInfo.bfInfo_OrdNumStng;
        LSRS     R7,R0,#+16
        LDR.W    R12,??DataTable16
        LDR      R12,[R12, R5, LSL #+3]
        BFI      R12,R7,#+16,#+8
        LDR.W    R7,??DataTable16
        STR      R12,[R7, R5, LSL #+3]
// 1056             }
// 1057             
// 1058         } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
??DetectCircutLinks_38:
        LDRH     R7,[SP, #+4]
        ADDS     R7,R7,#+1
        STRH     R7,[SP, #+4]
        LDRSH    R7,[SP, #+4]
        LDRSH    R12,[SP, #+0]
        CMP      R7,R12
        BLT.W    ??DetectCircutLinks_28
// 1059         sLV.shIdx += preSetUP.n_input;
        LDRH     R7,[SP, #+2]
        LDR.W    R12,??DataTable17
        LDR      R12,[R12, #+4]
        ADDS     R7,R12,R7
        STRH     R7,[SP, #+2]
// 1060     }
// 1061     
// 1062     if (preSetUP.n_output != 0) {
??DetectCircutLinks_27:
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+8]
        CMP      R0,#+0
        BEQ.N    ??DetectCircutLinks_39
// 1063         sLV.shCounterScanedObj = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+4]
// 1064         sLV.shAmtLU = preSetUP.n_output;
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+8]
        STRH     R0,[SP, #+0]
// 1065         sLV.lBaseOrdNumStng = 0;
        MOVS     R0,#+0
        STR      R0,[SP, #+8]
// 1066         do {
// 1067             i = sLV.shIdx + sLV.shCounterScanedObj;
??DetectCircutLinks_40:
        LDRSH    R0,[SP, #+2]
        LDRSH    R1,[SP, #+4]
        ADDS     R0,R1,R0
        MOVS     R5,R0
// 1068             ChangeStngOrdnumRelOnBase(i);
        MOVS     R1,R5
        MOVS     R0,R4
        BL       _ZN8Shematic25ChangeStngOrdnumRelOnBaseEl
// 1069         } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
        LDRH     R0,[SP, #+4]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+4]
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+0]
        CMP      R0,R1
        BLT.N    ??DetectCircutLinks_40
// 1070         sLV.shIdx += sLV.shCounterScanedObj;
        LDRH     R0,[SP, #+2]
        LDRH     R1,[SP, #+4]
        ADDS     R0,R1,R0
        STRH     R0,[SP, #+2]
// 1071     }
// 1072     if (preSetUP.n_led != 0) {
??DetectCircutLinks_39:
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+12]
        CMP      R0,#+0
        BEQ.N    ??DetectCircutLinks_41
// 1073         sLV.shCounterScanedObj = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+4]
// 1074         sLV.shAmtLU = preSetUP.n_led;
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+12]
        STRH     R0,[SP, #+0]
// 1075         sLV.lBaseOrdNumStng = 0;
        MOVS     R0,#+0
        STR      R0,[SP, #+8]
// 1076         do {
// 1077             i = sLV.shIdx + sLV.shCounterScanedObj;
??DetectCircutLinks_42:
        LDRSH    R0,[SP, #+2]
        LDRSH    R1,[SP, #+4]
        ADDS     R0,R1,R0
        MOVS     R5,R0
// 1078             ChangeStngOrdnumRelOnBase(i);
        MOVS     R1,R5
        MOVS     R0,R4
        BL       _ZN8Shematic25ChangeStngOrdnumRelOnBaseEl
// 1079         } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
        LDRH     R0,[SP, #+4]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+4]
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+0]
        CMP      R0,R1
        BLT.N    ??DetectCircutLinks_42
// 1080         sLV.shIdx += sLV.shCounterScanedObj;
        LDRH     R0,[SP, #+2]
        LDRH     R1,[SP, #+4]
        ADDS     R0,R1,R0
        STRH     R0,[SP, #+2]
// 1081     }
// 1082     if (preSetUP.n_and != 0) {
??DetectCircutLinks_41:
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+16]
        CMP      R0,#+0
        BEQ.N    ??DetectCircutLinks_43
// 1083         sLV.shCounterScanedObj = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+4]
// 1084         sLV.shAmtLU = preSetUP.n_and;
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+16]
        STRH     R0,[SP, #+0]
// 1085         sLV.lBaseOrdNumStng = 0;
        MOVS     R0,#+0
        STR      R0,[SP, #+8]
// 1086         do {
// 1087             i = sLV.shIdx + shCLUAnd_8_1_AmtIn*sLV.shCounterScanedObj;
??DetectCircutLinks_44:
        LDRSH    R0,[SP, #+2]
        LDRSH    R1,[SP, #+4]
        ADDS     R0,R0,R1, LSL #+3
        MOVS     R5,R0
// 1088             for(long ik = 0; ik < shCLUAnd_8_1_AmtIn; ik++){
        MOVS     R7,#+0
??DetectCircutLinks_45:
        CMP      R7,#+8
        BGE.N    ??DetectCircutLinks_46
// 1089                 ChangeStngOrdnumRelOnBase(i+ik);
        ADDS     R1,R7,R5
        MOVS     R0,R4
        BL       _ZN8Shematic25ChangeStngOrdnumRelOnBaseEl
// 1090             }
        ADDS     R7,R7,#+1
        B.N      ??DetectCircutLinks_45
// 1091         } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
??DetectCircutLinks_46:
        LDRH     R0,[SP, #+4]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+4]
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+0]
        CMP      R0,R1
        BLT.N    ??DetectCircutLinks_44
// 1092         sLV.shIdx += shCLUAnd_8_1_AmtIn*sLV.shCounterScanedObj;
        LDRSH    R0,[SP, #+2]
        LDRSH    R1,[SP, #+4]
        ADDS     R0,R0,R1, LSL #+3
        STRH     R0,[SP, #+2]
// 1093     }
// 1094     if (preSetUP.n_or != 0) {
??DetectCircutLinks_43:
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+20]
        CMP      R0,#+0
        BEQ.N    ??DetectCircutLinks_47
// 1095         sLV.shCounterScanedObj = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+4]
// 1096         sLV.shAmtLU = preSetUP.n_or;
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+20]
        STRH     R0,[SP, #+0]
// 1097         sLV.lBaseOrdNumStng = 0;
        MOVS     R0,#+0
        STR      R0,[SP, #+8]
// 1098         do {
// 1099             i = sLV.shIdx + shCLUOr_8_1_AmtIn*sLV.shCounterScanedObj;
??DetectCircutLinks_48:
        LDRSH    R0,[SP, #+2]
        LDRSH    R1,[SP, #+4]
        ADDS     R0,R0,R1, LSL #+3
        MOVS     R5,R0
// 1100             for(long ik = 0; ik < shCLUOr_8_1_AmtIn; ik++){
        MOVS     R7,#+0
??DetectCircutLinks_49:
        CMP      R7,#+8
        BGE.N    ??DetectCircutLinks_50
// 1101                 ChangeStngOrdnumRelOnBase(i+ik);
        ADDS     R1,R7,R5
        MOVS     R0,R4
        BL       _ZN8Shematic25ChangeStngOrdnumRelOnBaseEl
// 1102             }
        ADDS     R7,R7,#+1
        B.N      ??DetectCircutLinks_49
// 1103         } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
??DetectCircutLinks_50:
        LDRH     R0,[SP, #+4]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+4]
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+0]
        CMP      R0,R1
        BLT.N    ??DetectCircutLinks_48
// 1104         sLV.shIdx += shCLUOr_8_1_AmtIn*sLV.shCounterScanedObj;
        LDRSH    R0,[SP, #+2]
        LDRSH    R1,[SP, #+4]
        ADDS     R0,R0,R1, LSL #+3
        STRH     R0,[SP, #+2]
// 1105     }
// 1106     if (preSetUP.n_xor != 0) {
??DetectCircutLinks_47:
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+24]
        CMP      R0,#+0
        BEQ.N    ??DetectCircutLinks_51
// 1107         sLV.shCounterScanedObj = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+4]
// 1108         sLV.shAmtLU = preSetUP.n_xor;
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+24]
        STRH     R0,[SP, #+0]
// 1109         sLV.lBaseOrdNumStng = 0;
        MOVS     R0,#+0
        STR      R0,[SP, #+8]
// 1110         do {
// 1111             i = sLV.shIdx + shCLUXor_2_1_AmtIn*sLV.shCounterScanedObj;
??DetectCircutLinks_52:
        LDRSH    R0,[SP, #+2]
        LDRSH    R1,[SP, #+4]
        ADDS     R0,R0,R1, LSL #+1
        MOVS     R5,R0
// 1112             for(long ik = 0; ik < shCLUXor_2_1_AmtIn; ik++){
        MOVS     R7,#+0
??DetectCircutLinks_53:
        CMP      R7,#+2
        BGE.N    ??DetectCircutLinks_54
// 1113                 ChangeStngOrdnumRelOnBase(i+ik);
        ADDS     R1,R7,R5
        MOVS     R0,R4
        BL       _ZN8Shematic25ChangeStngOrdnumRelOnBaseEl
// 1114             }
        ADDS     R7,R7,#+1
        B.N      ??DetectCircutLinks_53
// 1115         } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
??DetectCircutLinks_54:
        LDRH     R0,[SP, #+4]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+4]
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+0]
        CMP      R0,R1
        BLT.N    ??DetectCircutLinks_52
// 1116         sLV.shIdx += shCLUXor_2_1_AmtIn*sLV.shCounterScanedObj;
        LDRSH    R0,[SP, #+2]
        LDRSH    R1,[SP, #+4]
        ADDS     R0,R0,R1, LSL #+1
        STRH     R0,[SP, #+2]
// 1117     }
// 1118     if (preSetUP.n_not != 0) {
??DetectCircutLinks_51:
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+28]
        CMP      R0,#+0
        BEQ.N    ??DetectCircutLinks_55
// 1119         sLV.shCounterScanedObj = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+4]
// 1120         sLV.shAmtLU = preSetUP.n_not;
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+28]
        STRH     R0,[SP, #+0]
// 1121         sLV.lBaseOrdNumStng = 0;
        MOVS     R0,#+0
        STR      R0,[SP, #+8]
// 1122         do {
// 1123             i = sLV.shIdx + shCLUNot_1_1_AmtIn*sLV.shCounterScanedObj;
??DetectCircutLinks_56:
        LDRSH    R0,[SP, #+2]
        LDRSH    R1,[SP, #+4]
        ADDS     R0,R1,R0
        MOVS     R5,R0
// 1124             for(long ik = 0; ik < shCLUNot_1_1_AmtIn; ik++){
        MOVS     R7,#+0
??DetectCircutLinks_57:
        CMP      R7,#+1
        BGE.N    ??DetectCircutLinks_58
// 1125                 ChangeStngOrdnumRelOnBase(i+ik);
        ADDS     R1,R7,R5
        MOVS     R0,R4
        BL       _ZN8Shematic25ChangeStngOrdnumRelOnBaseEl
// 1126             }
        ADDS     R7,R7,#+1
        B.N      ??DetectCircutLinks_57
// 1127         } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
??DetectCircutLinks_58:
        LDRH     R0,[SP, #+4]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+4]
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+0]
        CMP      R0,R1
        BLT.N    ??DetectCircutLinks_56
// 1128         sLV.shIdx += shCLUNot_1_1_AmtIn*sLV.shCounterScanedObj;
        LDRH     R0,[SP, #+2]
        LDRH     R1,[SP, #+4]
        ADDS     R0,R1,R0
        STRH     R0,[SP, #+2]
// 1129     }
// 1130     
// 1131 }
??DetectCircutLinks_55:
        ADD      SP,SP,#+20
        POP      {R4-R7,PC}       ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable6:
        DC32     ar_n_output_CRDsc

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1132 void Shematic::ChangeRelativeOnEvalLinks(void){
// 1133 
// 1134 //Scan OutPut
// 1135 
// 1136    
// 1137 
// 1138 
// 1139 }
_ZN8Shematic25ChangeRelativeOnEvalLinksEv:
        BX       LR               ;; return
// 1140 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1141 void Shematic::ChangeStngOrdnumRelOnBase(long lIdxScanedObj) {
_ZN8Shematic25ChangeStngOrdnumRelOnBaseEl:
        PUSH     {R4-R7,LR}
// 1142     register long i,j;
// 1143     SBitFld_LUInInfo locSBitFld_LUInInfo;
// 1144     short shRelativeNumber = 0;
        MOVS     R5,#+0
// 1145     short shIdLUStng       = 0;
        MOVS     R6,#+0
// 1146     short shIdx_arrSBitFldCRefInfo = 0;
        MOVS     R7,#+0
// 1147     i = j = 0;
        MOVS     R12,#+0
        MOV      R3,R12
        MOVS     R2,R3
// 1148  //   do {
// 1149             //Change offset on real Number 
// 1150             i = lIdxScanedObj; //i = sLV.shCounterScanedObj; //
        MOVS     R2,R1
// 1151     locSBitFld_LUInInfo = arrSBitFldCRefInfo[i].sBitLUInputInfo;
        LDR.W    R12,??DataTable16
        LDR      R12,[R12, R2, LSL #+3]
        MOV      R4,R12
// 1152     shIdLUStng = locSBitFld_LUInInfo.bfInfo_IdLUStng;
        LSRS     R12,R4,#+24
        MOV      R6,R12
// 1153     //Get Index in LU sequence
// 1154     switch (shIdLUStng) {
        SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
        MOV      R12,R6
        CMP      R12,#+4
        BEQ.N    ??ChangeStngOrdnumRelOnBase_0
        CMP      R12,#+5
        BEQ.N    ??ChangeStngOrdnumRelOnBase_1
        CMP      R12,#+6
        BEQ.N    ??ChangeStngOrdnumRelOnBase_2
        CMP      R12,#+11
        BEQ.N    ??ChangeStngOrdnumRelOnBase_3
        CMP      R12,#+12
        BEQ.N    ??ChangeStngOrdnumRelOnBase_4
        CMP      R12,#+13
        BEQ.N    ??ChangeStngOrdnumRelOnBase_5
        CMP      R12,#+14
        BEQ.N    ??ChangeStngOrdnumRelOnBase_6
        B.N      ??ChangeStngOrdnumRelOnBase_7
// 1155         case STNG_LU_AND:
// 1156             shIdx_arrSBitFldCRefInfo = preSetUP.n_input
// 1157                     + preSetUP.n_output + preSetUP.n_led;
??ChangeStngOrdnumRelOnBase_0:
        LDR.W    R12,??DataTable17
        LDR      R12,[R12, #+4]
        LDR.W    LR,??DataTable17
        LDR      LR,[LR, #+8]
        ADDS     R12,LR,R12
        LDR.W    LR,??DataTable17
        LDR      LR,[LR, #+12]
        ADDS     R12,LR,R12
        MOV      R7,R12
// 1158             break;
        B.N      ??ChangeStngOrdnumRelOnBase_8
// 1159 
// 1160         case STNG_LU_OR:
// 1161             shIdx_arrSBitFldCRefInfo = preSetUP.n_input
// 1162                     + preSetUP.n_output + preSetUP.n_led + shCLUAnd_8_1_AmtIn * preSetUP.n_and;
??ChangeStngOrdnumRelOnBase_1:
        LDR.W    R12,??DataTable17
        LDR      R12,[R12, #+4]
        LDR.W    LR,??DataTable17
        LDR      LR,[LR, #+8]
        ADDS     R12,LR,R12
        LDR.W    LR,??DataTable17
        LDR      LR,[LR, #+12]
        ADDS     R12,LR,R12
        LDR.W    LR,??DataTable17
        LDR      LR,[LR, #+16]
        ADDS     R12,R12,LR, LSL #+3
        MOV      R7,R12
// 1163             break;
        B.N      ??ChangeStngOrdnumRelOnBase_8
// 1164 
// 1165         case STNG_LU_XOR:
// 1166             shIdx_arrSBitFldCRefInfo = preSetUP.n_input
// 1167                     + preSetUP.n_output + preSetUP.n_led + shCLUAnd_8_1_AmtIn * preSetUP.n_and
// 1168                     + shCLUOr_8_1_AmtIn * preSetUP.n_or;
??ChangeStngOrdnumRelOnBase_2:
        LDR.W    R12,??DataTable17
        LDR      R12,[R12, #+4]
        LDR.W    LR,??DataTable17
        LDR      LR,[LR, #+8]
        ADDS     R12,LR,R12
        LDR.W    LR,??DataTable17
        LDR      LR,[LR, #+12]
        ADDS     R12,LR,R12
        LDR.W    LR,??DataTable17
        LDR      LR,[LR, #+16]
        ADDS     R12,R12,LR, LSL #+3
        LDR.W    LR,??DataTable17
        LDR      LR,[LR, #+20]
        ADDS     R12,R12,LR, LSL #+3
        MOV      R7,R12
// 1169             break;
        B.N      ??ChangeStngOrdnumRelOnBase_8
// 1170 
// 1171         case STNG_LU_INPUT:
// 1172             shIdx_arrSBitFldCRefInfo = 0;
??ChangeStngOrdnumRelOnBase_3:
        MOVS     R12,#+0
        MOV      R7,R12
// 1173             break;
        B.N      ??ChangeStngOrdnumRelOnBase_8
// 1174 
// 1175         case STNG_LU_OUTPUT:
// 1176             shIdx_arrSBitFldCRefInfo = preSetUP.n_input;
??ChangeStngOrdnumRelOnBase_4:
        LDR.W    R12,??DataTable17
        LDR      R12,[R12, #+4]
        MOV      R7,R12
// 1177             break;
        B.N      ??ChangeStngOrdnumRelOnBase_8
// 1178 
// 1179         case STNG_LU_LED:
// 1180             shIdx_arrSBitFldCRefInfo = preSetUP.n_input
// 1181                     + preSetUP.n_output;
??ChangeStngOrdnumRelOnBase_5:
        LDR.W    R12,??DataTable17
        LDR      R12,[R12, #+4]
        LDR.W    LR,??DataTable17
        LDR      LR,[LR, #+8]
        ADDS     R12,LR,R12
        MOV      R7,R12
// 1182             break;
        B.N      ??ChangeStngOrdnumRelOnBase_8
// 1183 
// 1184         case STNG_LU_NOT:
// 1185             shIdx_arrSBitFldCRefInfo = preSetUP.n_input
// 1186                     + preSetUP.n_output + preSetUP.n_led + shCLUAnd_8_1_AmtIn * preSetUP.n_and
// 1187                     + shCLUOr_8_1_AmtIn * preSetUP.n_or + shCLUXor_2_1_AmtIn * preSetUP.n_xor;
??ChangeStngOrdnumRelOnBase_6:
        LDR.W    R12,??DataTable17
        LDR      R12,[R12, #+4]
        LDR.W    LR,??DataTable17
        LDR      LR,[LR, #+8]
        ADDS     R12,LR,R12
        LDR.W    LR,??DataTable17
        LDR      LR,[LR, #+12]
        ADDS     R12,LR,R12
        LDR.W    LR,??DataTable17
        LDR      LR,[LR, #+16]
        ADDS     R12,R12,LR, LSL #+3
        LDR.W    LR,??DataTable17
        LDR      LR,[LR, #+20]
        ADDS     R12,R12,LR, LSL #+3
        LDR.W    LR,??DataTable17
        LDR      LR,[LR, #+24]
        ADDS     R12,R12,LR, LSL #+1
        MOV      R7,R12
// 1188             break;
        B.N      ??ChangeStngOrdnumRelOnBase_8
// 1189 
// 1190 
// 1191         default:
// 1192             shIdx_arrSBitFldCRefInfo = -1;
??ChangeStngOrdnumRelOnBase_7:
        MOVS     R12,#-1
        MOV      R7,R12
// 1193     }
// 1194 
// 1195     shRelativeNumber = locSBitFld_LUInInfo.bfInfo_OrdNumStng;
??ChangeStngOrdnumRelOnBase_8:
        LSRS     R12,R4,#+16
        UXTB     R12,R12          ;; ZeroExt  R12,R12,#+24,#+24
        MOV      R5,R12
// 1196     if (shIdx_arrSBitFldCRefInfo != (-1)) {
        SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
        CMN      R7,#+1
        BEQ.N    ??ChangeStngOrdnumRelOnBase_9
// 1197         //Find Element
// 1198         j = shIdx_arrSBitFldCRefInfo + shRelativeNumber - 1; //Only Now
        SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
        SXTH     R5,R5            ;; SignExt  R5,R5,#+16,#+16
        ADDS     R12,R5,R7
        SUBS     R12,R12,#+1
        MOV      R3,R12
// 1199         locSBitFld_LUInInfo.bfInfo_OrdNumStng = arrSBitFldCRefInfo[j].bfInfo_BaseID; //sLV.lBaseOrdNumStng
        LDR.W    R12,??DataTable16
        ADDS     R12,R12,R3, LSL #+3
        LDR      R12,[R12, #+4]
        BFI      R4,R12,#+16,#+8
// 1200         arrSBitFldCRefInfo[i].sBitLUInputInfo.bfInfo_OrdNumStng
// 1201                 = locSBitFld_LUInInfo.bfInfo_OrdNumStng;
        LSRS     R12,R4,#+16
        LDR.W    LR,??DataTable16
        LDR      LR,[LR, R2, LSL #+3]
        BFI      LR,R12,#+16,#+8
        LDR.W    R12,??DataTable16
        STR      LR,[R12, R2, LSL #+3]
// 1202     }
// 1203     
// 1204 //        } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
// 1205     
// 1206 }
??ChangeStngOrdnumRelOnBase_9:
        POP      {R4-R7,PC}       ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7:
        DC32     gLUAreaMem+0x4000
// 1207 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1208 void Shematic::Init2(void) {
_ZN8Shematic5Init2Ev:
        PUSH     {R4-R7,LR}
        SUB      SP,SP,#+484
        MOVS     R4,R0
// 1209     register long  j;
// 1210 //    register void* pv;  
// 1211     Init2LcVarArea lsLcVarArea;//lsLc -local struct Local Area
// 1212     lsLcVarArea.arrLUAreaListElem = &gLUAreaMem.headLUAreaList;
        LDR.W    R0,??SetupCircutLinks_0
        STR      R0,[SP, #+8]
// 1213     DetectCircutLinks();
        MOVS     R0,R4
        BL       _ZN8Shematic17DetectCircutLinksEv
// 1214     lsLcVarArea.shCounterInitCLUObj = 1;
        MOVS     R0,#+1
        STRH     R0,[SP, #+20]
// 1215     if( preSetUP.n_input ){
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+4]
        CMP      R0,#+0
        BEQ.N    ??Init2_0
// 1216         CLUDInput_0_1 locCLUDInput_0_1(10, 0); // = CLUDInput_0_1(0,10);
        MOVS     R2,#+0
        MOVS     R1,#+10
        ADD      R0,SP,#+84
        BL       _ZN13CLUDInput_0_1C1Ecc
// 1217         short shLC__n_input = preSetUP.n_input;
        LDR.W    R0,??DataTable17
        LDR      R6,[R0, #+4]
// 1218         short shCounterInitCLUDIn = 0;
        MOVS     R7,#+0
// 1219         lsLcVarArea.shIdxGlobalObjectMapPointers = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+22]
// 1220         j = 0;
        MOVS     R0,#+0
        MOVS     R5,R0
// 1221         do {
// 1222             j = InsertLU(LU_INPUT, static_cast<void*>(&locCLUDInput_0_1));
??Init2_1:
        ADD      R2,SP,#+84
        MOVS     R1,#+11
        MOVS     R0,R4
        BL       _ZN8Shematic8InsertLUElPv
        MOVS     R5,R0
// 1223             
// 1224             if (j) {//Success Bield
        CMP      R5,#+0
        BEQ.N    ??Init2_2
// 1225                 SetupCLUDInput_0_1StngParam(static_cast<void*>(&lsLcVarArea));
        MOV      R1,SP
        MOVS     R0,R4
        BL       _ZN8Shematic27SetupCLUDInput_0_1StngParamEPv
// 1226                 shCounterInitCLUDIn++;
        ADDS     R7,R7,#+1
// 1227             }//Else Error
// 1228             
// 1229         } while (shCounterInitCLUDIn < shLC__n_input && j);
??Init2_2:
        SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
        SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
        CMP      R7,R6
        BGE.N    ??Init2_3
        CMP      R5,#+0
        BNE.N    ??Init2_1
// 1230     }
??Init2_3:
        ADD      R0,SP,#+84
        BL       _ZN13CLUDInput_0_1D1Ev
// 1231     if (preSetUP.n_output != 0) {
??Init2_0:
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+8]
        CMP      R0,#+0
        BEQ.N    ??Init2_4
// 1232         CLUDout_1_0 locCLUDout_1_0(10, 0);
        MOVS     R2,#+0
        MOVS     R1,#+10
        ADD      R0,SP,#+420
        BL       _ZN11CLUDout_1_0C1Ecc
// 1233         short shLC__n_output = preSetUP.n_output;
        LDR.W    R0,??DataTable17
        LDR      R6,[R0, #+8]
// 1234         short shCounterInitCLUDout = 0;
        MOVS     R7,#+0
// 1235         lsLcVarArea.shIdxGlobalObjectMapPointers = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+22]
// 1236         j = 0;
        MOVS     R0,#+0
        MOVS     R5,R0
// 1237         do {
// 1238             j = InsertLU(LU_OUTPUT, static_cast<void*>(&locCLUDout_1_0));
??Init2_5:
        ADD      R2,SP,#+420
        MOVS     R1,#+12
        MOVS     R0,R4
        BL       _ZN8Shematic8InsertLUElPv
        MOVS     R5,R0
// 1239             
// 1240             if (j) {//Success Bield
        CMP      R5,#+0
        BEQ.N    ??Init2_6
// 1241                 SetupCLUDout_1_0StngParam(static_cast<void*>(&lsLcVarArea));
        MOV      R1,SP
        MOVS     R0,R4
        BL       _ZN8Shematic25SetupCLUDout_1_0StngParamEPv
// 1242                 shCounterInitCLUDout++;
        ADDS     R7,R7,#+1
// 1243             }//Else Error
// 1244         } while (shCounterInitCLUDout < shLC__n_output && j);
??Init2_6:
        SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
        SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
        CMP      R7,R6
        BGE.N    ??Init2_7
        CMP      R5,#+0
        BNE.N    ??Init2_5
// 1245     }
??Init2_7:
        ADD      R0,SP,#+420
        BL       _ZN11CLUDout_1_0D1Ev
// 1246     if (preSetUP.n_led != 0) {
??Init2_4:
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+12]
        CMP      R0,#+0
        BEQ.N    ??Init2_8
// 1247         CLULed locCLULed(10, 0);
        MOVS     R2,#+0
        MOVS     R1,#+10
        ADD      R0,SP,#+348
        BL       _ZN6CLULedC1Ecc
// 1248         short shLC__n_led = preSetUP.n_led;
        LDR.W    R0,??DataTable17
        LDR      R6,[R0, #+12]
// 1249         short shCounterInitCLULed = 0;
        MOVS     R7,#+0
// 1250         lsLcVarArea.shIdxGlobalObjectMapPointers = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+22]
// 1251         j = 0;
        MOVS     R0,#+0
        MOVS     R5,R0
// 1252         do {
// 1253             j = InsertLU(LU_LED, static_cast<void*>(&locCLULed));
??Init2_9:
        ADD      R2,SP,#+348
        MOVS     R1,#+13
        MOVS     R0,R4
        BL       _ZN8Shematic8InsertLUElPv
        MOVS     R5,R0
// 1254         if (j) {//Success Bield
        CMP      R5,#+0
        BEQ.N    ??Init2_10
// 1255                 SetupCLULedStngParam(static_cast<void*>(&lsLcVarArea));
        MOV      R1,SP
        MOVS     R0,R4
        BL       _ZN8Shematic20SetupCLULedStngParamEPv
// 1256                 shCounterInitCLULed++;
        ADDS     R7,R7,#+1
// 1257             }//Else Error
// 1258         } while (shCounterInitCLULed < shLC__n_led && j);
??Init2_10:
        SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
        SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
        CMP      R7,R6
        BGE.N    ??Init2_11
        CMP      R5,#+0
        BNE.N    ??Init2_9
// 1259     }
??Init2_11:
        ADD      R0,SP,#+348
        BL       _ZN6CLULedD1Ev
// 1260     if (preSetUP.n_and != 0) {
??Init2_8:
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+16]
        CMP      R0,#+0
        BEQ.N    ??Init2_12
// 1261         CLUAnd_8_1 locCLUAnd_8_1(10, 0);
        MOVS     R2,#+0
        MOVS     R1,#+10
        ADD      R0,SP,#+288
        BL       _ZN10CLUAnd_8_1C1Ecc
// 1262         short shLC__n_and = preSetUP.n_and;
        LDR.W    R0,??DataTable17
        LDR      R6,[R0, #+16]
// 1263         short shCounterInitCLUAnd = 0;
        MOVS     R7,#+0
// 1264         lsLcVarArea.shIdxGlobalObjectMapPointers = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+22]
// 1265         j = 0;
        MOVS     R0,#+0
        MOVS     R5,R0
// 1266         do {
// 1267             j = InsertLU(LU_AND, static_cast<void*>(&locCLUAnd_8_1));
??Init2_13:
        ADD      R2,SP,#+288
        MOVS     R1,#+4
        MOVS     R0,R4
        BL       _ZN8Shematic8InsertLUElPv
        MOVS     R5,R0
// 1268         if (j) {//Success Bield
        CMP      R5,#+0
        BEQ.N    ??Init2_14
// 1269                 SetupCLUAnd_8_1StngParam(static_cast<void*>(&lsLcVarArea));
        MOV      R1,SP
        MOVS     R0,R4
        BL       _ZN8Shematic24SetupCLUAnd_8_1StngParamEPv
// 1270                 shCounterInitCLUAnd++;
        ADDS     R7,R7,#+1
// 1271             }//Else Error
// 1272         } while (shCounterInitCLUAnd < shLC__n_and && j);
??Init2_14:
        SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
        SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
        CMP      R7,R6
        BGE.N    ??Init2_15
        CMP      R5,#+0
        BNE.N    ??Init2_13
// 1273     }
??Init2_15:
        ADD      R0,SP,#+288
        BL       _ZN10CLUAnd_8_1D1Ev
// 1274     if (preSetUP.n_or != 0) {
??Init2_12:
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+20]
        CMP      R0,#+0
        BEQ.N    ??Init2_16
// 1275         CLUOr_8_1 locCLUOr_8_1(10, 0);
        MOVS     R2,#+0
        MOVS     R1,#+10
        ADD      R0,SP,#+228
        BL       _ZN9CLUOr_8_1C1Ecc
// 1276         short shLC__n_or = preSetUP.n_or;
        LDR.W    R0,??DataTable17
        LDR      R6,[R0, #+20]
// 1277         short shCounterInitCLUOr = 0;
        MOVS     R7,#+0
// 1278         lsLcVarArea.shIdxGlobalObjectMapPointers = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+22]
// 1279         j = 0;
        MOVS     R0,#+0
        MOVS     R5,R0
// 1280         do {
// 1281             j = InsertLU(LU_OR, static_cast<void*>(&locCLUOr_8_1));
??Init2_17:
        ADD      R2,SP,#+228
        MOVS     R1,#+5
        MOVS     R0,R4
        BL       _ZN8Shematic8InsertLUElPv
        MOVS     R5,R0
// 1282         if (j) {//Success Bield
        CMP      R5,#+0
        BEQ.N    ??Init2_18
// 1283                 SetupCLUOr_8_1StngParam(static_cast<void*>(&lsLcVarArea));
        MOV      R1,SP
        MOVS     R0,R4
        BL       _ZN8Shematic23SetupCLUOr_8_1StngParamEPv
// 1284                 shCounterInitCLUOr++;
        ADDS     R7,R7,#+1
// 1285             }//Else Error
// 1286         } while (shCounterInitCLUOr < shLC__n_or && j);
??Init2_18:
        SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
        SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
        CMP      R7,R6
        BGE.N    ??Init2_19
        CMP      R5,#+0
        BNE.N    ??Init2_17
// 1287     }
??Init2_19:
        ADD      R0,SP,#+228
        BL       _ZN9CLUOr_8_1D1Ev
// 1288     if (preSetUP.n_xor != 0) {
??Init2_16:
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+24]
        CMP      R0,#+0
        BEQ.N    ??Init2_20
// 1289         CLUXor_8_1 locCLUXor_8_1(10, 0);
        MOVS     R2,#+0
        MOVS     R1,#+10
        ADD      R0,SP,#+192
        BL       _ZN10CLUXor_8_1C1Ecc
// 1290         short shLC__n_xor = preSetUP.n_xor;
        LDR.W    R0,??DataTable17
        LDR      R6,[R0, #+24]
// 1291         short shCounterInitCLUXor = 0;
        MOVS     R7,#+0
// 1292         lsLcVarArea.shIdxGlobalObjectMapPointers = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+22]
// 1293         j = 0;
        MOVS     R0,#+0
        MOVS     R5,R0
// 1294         do {
// 1295             j = InsertLU(LU_XOR, static_cast<void*>(&locCLUXor_8_1));
??Init2_21:
        ADD      R2,SP,#+192
        MOVS     R1,#+6
        MOVS     R0,R4
        BL       _ZN8Shematic8InsertLUElPv
        MOVS     R5,R0
// 1296         if (j) {//Success Bield
        CMP      R5,#+0
        BEQ.N    ??Init2_22
// 1297                 SetupCLUXor_8_1StngParam(static_cast<void*>(&lsLcVarArea));
        MOV      R1,SP
        MOVS     R0,R4
        BL       _ZN8Shematic24SetupCLUXor_8_1StngParamEPv
// 1298                 shCounterInitCLUXor++;
        ADDS     R7,R7,#+1
// 1299             }//Else Error
// 1300         } while (shCounterInitCLUXor < shLC__n_xor && j);
??Init2_22:
        SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
        SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
        CMP      R7,R6
        BGE.N    ??Init2_23
        CMP      R5,#+0
        BNE.N    ??Init2_21
// 1301     }
??Init2_23:
        ADD      R0,SP,#+192
        BL       _ZN10CLUXor_8_1D1Ev
// 1302     if (preSetUP.n_not != 0) {
??Init2_20:
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+28]
        CMP      R0,#+0
        BEQ.N    ??Init2_24
// 1303         CLUNot_1_1 locCLUNot_1_1(10, 0);
        MOVS     R2,#+0
        MOVS     R1,#+10
        ADD      R0,SP,#+52
        BL       _ZN10CLUNot_1_1C1Ecc
// 1304         short shLC__n_not = preSetUP.n_not;
        LDR.W    R0,??DataTable17
        LDR      R6,[R0, #+28]
// 1305         short shCounterInitCLUNot = 0;
        MOVS     R7,#+0
// 1306         lsLcVarArea.shIdxGlobalObjectMapPointers = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+22]
// 1307         j = 0;
        MOVS     R0,#+0
        MOVS     R5,R0
// 1308         do {
// 1309             j = InsertLU(LU_NOT, static_cast<void*>(&locCLUNot_1_1));
??Init2_25:
        ADD      R2,SP,#+52
        MOVS     R1,#+14
        MOVS     R0,R4
        BL       _ZN8Shematic8InsertLUElPv
        MOVS     R5,R0
// 1310         if (j) {//Success Bield
        CMP      R5,#+0
        BEQ.N    ??Init2_26
// 1311                 SetupCLUNot_1_1StngParam(static_cast<void*>(&lsLcVarArea));
        MOV      R1,SP
        MOVS     R0,R4
        BL       _ZN8Shematic24SetupCLUNot_1_1StngParamEPv
// 1312                 shCounterInitCLUNot++;
        ADDS     R7,R7,#+1
// 1313             }//Else Error
// 1314         } while (shCounterInitCLUNot < shLC__n_not && j);
??Init2_26:
        SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
        SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
        CMP      R7,R6
        BGE.N    ??Init2_27
        CMP      R5,#+0
        BNE.N    ??Init2_25
// 1315     }
??Init2_27:
        ADD      R0,SP,#+52
        BL       _ZN10CLUNot_1_1D1Ev
// 1316     if (preSetUP.n_timers != 0) {
??Init2_24:
        LDR.W    R0,??DataTable17
        LDR      R0,[R0, #+32]
        CMP      R0,#+0
        BEQ.N    ??Init2_28
// 1317         CMft locCMft(10, 0);
        MOVS     R2,#+0
        MOVS     R1,#+10
        ADD      R0,SP,#+112
        BL       _ZN4CMftC1Ecc
// 1318         short shLC__n_timers = preSetUP.n_timers;
        LDR.W    R0,??DataTable17
        LDR      R6,[R0, #+32]
// 1319         short shCounterInitCMft = 0;
        MOVS     R7,#+0
// 1320         lsLcVarArea.shIdxGlobalObjectMapPointers = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+22]
// 1321         j = 0;
        MOVS     R0,#+0
        MOVS     R5,R0
// 1322         do {
// 1323             j = InsertLU(LU_MFT, static_cast<void*>(&locCMft));
??Init2_29:
        ADD      R2,SP,#+112
        MOVS     R1,#+15
        MOVS     R0,R4
        BL       _ZN8Shematic8InsertLUElPv
        MOVS     R5,R0
// 1324         if (j) {//Success Bield
        CMP      R5,#+0
        BEQ.N    ??Init2_30
// 1325                 SetupCLUMft_2_1StngParam(static_cast<void*>(&lsLcVarArea));
        MOV      R1,SP
        MOVS     R0,R4
        BL       _ZN8Shematic24SetupCLUMft_2_1StngParamEPv
// 1326                 shCounterInitCMft++;
        ADDS     R7,R7,#+1
// 1327             }//Else Error
// 1328         } while (shCounterInitCMft < shLC__n_timers && j);
??Init2_30:
        SXTH     R7,R7            ;; SignExt  R7,R7,#+16,#+16
        SXTH     R6,R6            ;; SignExt  R6,R6,#+16,#+16
        CMP      R7,R6
        BGE.N    ??Init2_31
        CMP      R5,#+0
        BNE.N    ??Init2_29
// 1329     }
??Init2_31:
        ADD      R0,SP,#+112
        BL       _ZN4CMftD1Ev
// 1330     
// 1331 SetupCircutLinks(static_cast<void*>(&lsLcVarArea));
??Init2_28:
        MOV      R1,SP
        MOVS     R0,R4
        BL       _ZN8Shematic16SetupCircutLinksEPv
// 1332 
// 1333 }
        ADD      SP,SP,#+484
        POP      {R4-R7,PC}       ;; return
// 1334 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1335 void Shematic::SetupCLUDInput_0_1StngParam(void *pv){
_ZN8Shematic27SetupCLUDInput_0_1StngParamEPv:
        PUSH     {R4-R7}
// 1336     register long i;
// 1337     register Init2LcVarArea *pInit2LcVarArea = static_cast<Init2LcVarArea*>(pv);
        MOVS     R3,R1
// 1338     i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
        LDR.W    R4,??DataTable27
        LDRSH    R4,[R4, #+0]
        MOVS     R2,R4
// 1339     pv = static_cast<void*>(&(pInit2LcVarArea->arrLUAreaListElem[i-1]));
        LDR      R4,[R3, #+8]
        ADDS     R4,R4,R2, LSL #+3
        SUBS     R4,R4,#+8
        MOVS     R1,R4
// 1340     //pInit2LcVarArea->pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
// 1341     pInit2LcVarArea->pCLUBase = static_cast<CLUBase*>( 
// 1342                         (static_cast<LUAreaListElem*>(pv))->pvLU);
        LDR      R4,[R1, #+4]
        STR      R4,[R3, #+12]
// 1343 	
// 1344     pInit2LcVarArea->pCLUBase->shShemasIdLUStng = STNG_LU_INPUT;
        MOVS     R4,#+11
        LDR      R5,[R3, #+12]
        STRH     R4,[R5, #+10]
// 1345     i = pInit2LcVarArea->shCounterInitCLUObj-1; //sLV.shIdxLUOutDsc-1
        LDRSH    R4,[R3, #+20]
        SUBS     R4,R4,#+1
        MOVS     R2,R4
// 1346     pInit2LcVarArea->pCLUBase->shShemasOrdNumStng = static_cast<unsigned char>(
// 1347     arrSBitFldCRefInfo[i].bfInfo_BaseID);
        LDR.W    R4,??DataTable16
        ADDS     R4,R4,R2, LSL #+3
        LDR      R4,[R4, #+4]
        UXTB     R4,R4            ;; ZeroExt  R4,R4,#+24,#+24
        LDR      R5,[R3, #+12]
        STRH     R4,[R5, #+12]
// 1348     pInit2LcVarArea->shCounterInitCLUObj++;// sLV.shIdxLUOutDsc++;
        LDRH     R4,[R3, #+20]
        ADDS     R4,R4,#+1
        STRH     R4,[R3, #+20]
// 1349     CLUDInput_0_1* locPCLUDInput_0_1 = static_cast<CLUDInput_0_1*>(pInit2LcVarArea->pCLUBase);
        LDR      R4,[R3, #+12]
// 1350     locPCLUDInput_0_1->pOut = static_cast<void*>(locPCLUDInput_0_1->arrOut);
        ADDS     R5,R4,#+24
        STR      R5,[R4, #+20]
// 1351     CLUDInput_0_1& locRef_CLUDInput_0_1 =
// 1352             *(static_cast<CLUDInput_0_1*>(pInit2LcVarArea->pCLUBase));
        LDR      R5,[R3, #+12]
// 1353     locRef_CLUDInput_0_1.chTypeLogicFunction = LU_OP_READ_DI;
        MOVS     R6,#+7
        STRB     R6,[R5, #+8]
// 1354     locRef_CLUDInput_0_1.LogicFunc = READ_DI_Op; //???
        LDR.W    R6,??DataTable27_1
        STR      R6,[R5, #+16]
// 1355     i = pInit2LcVarArea->shIdxGlobalObjectMapPointers;//
        LDRSH    R6,[R3, #+22]
        MOVS     R2,R6
// 1356             
// 1357     GlobalObjectMap.arPCLUDInput_0_1[i] = static_cast<CLUDInput_0_1*>(
// 1358             pInit2LcVarArea->pCLUBase); //sLV.pCLUBase;
        LDR      R6,[R3, #+12]
        LDR.W    R7,??DataTable27_2
        STR      R6,[R7, R2, LSL #+2]
// 1359     pInit2LcVarArea->shIdxGlobalObjectMapPointers++;//sLV.shIdx++           
        LDRH     R6,[R3, #+22]
        ADDS     R6,R6,#+1
        STRH     R6,[R3, #+22]
// 1360 }
        POP      {R4-R7}
        BX       LR               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable9:
        DC32     ar_n__Output_Dsc

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1361 void Shematic::SetupCLUDout_1_0StngParam(void *pv){
_ZN8Shematic25SetupCLUDout_1_0StngParamEPv:
        PUSH     {R4-R7}
// 1362     register long i,j;
// 1363     register Init2LcVarArea *pInit2LcVarArea = static_cast<Init2LcVarArea*>(pv);
        MOVS     R4,R1
// 1364     i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
        LDR.W    R5,??DataTable27
        LDRSH    R5,[R5, #+0]
        MOVS     R2,R5
// 1365     pv = static_cast<void*>(&(pInit2LcVarArea->arrLUAreaListElem[i-1]));
        LDR      R5,[R4, #+8]
        ADDS     R5,R5,R2, LSL #+3
        SUBS     R5,R5,#+8
        MOVS     R1,R5
// 1366     //pInit2LcVarArea->pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
// 1367     pInit2LcVarArea->pCLUBase = static_cast<CLUBase*>( 
// 1368 	(static_cast<LUAreaListElem*>(pv))->pvLU);
        LDR      R5,[R1, #+4]
        STR      R5,[R4, #+12]
// 1369     pInit2LcVarArea->pCLUBase->shShemasIdLUStng =  STNG_LU_OUTPUT;
        MOVS     R5,#+12
        LDR      R6,[R4, #+12]
        STRH     R5,[R6, #+10]
// 1370     i = pInit2LcVarArea->shCounterInitCLUObj - 1;
        LDRSH    R5,[R4, #+20]
        SUBS     R5,R5,#+1
        MOVS     R2,R5
// 1371     pInit2LcVarArea->pCLUBase->shShemasOrdNumStng = static_cast<unsigned char>(
// 1372     arrSBitFldCRefInfo[i].bfInfo_BaseID);
        LDR.W    R5,??DataTable16
        ADDS     R5,R5,R2, LSL #+3
        LDR      R5,[R5, #+4]
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        LDR      R6,[R4, #+12]
        STRH     R5,[R6, #+12]
// 1373     pInit2LcVarArea->shCounterInitCLUObj++;// sLV.shIdxLUOutDsc++;
        LDRH     R5,[R4, #+20]
        ADDS     R5,R5,#+1
        STRH     R5,[R4, #+20]
// 1374     CLUDout_1_0* locPCLUDout_1_0 = static_cast<CLUDout_1_0*>(pInit2LcVarArea->pCLUBase);
        LDR      R5,[R4, #+12]
// 1375     locPCLUDout_1_0->pIn = static_cast<void*>(locPCLUDout_1_0->arrPchIn);
        ADDS     R6,R5,#+24
        STR      R6,[R5, #+0]
// 1376     locPCLUDout_1_0->arrPchIn[0] = &chGblGround;
        LDR.W    R6,??DataTable27_3
        STR      R6,[R5, #+24]
// 1377     locPCLUDout_1_0->chTypeLogicFunction = LU_OP_SET_OUT;
        MOVS     R6,#+8
        STRB     R6,[R5, #+8]
// 1378     locPCLUDout_1_0->LogicFunc = SET_OUT_Op; //???
        LDR.W    R6,??DataTable27_4
        STR      R6,[R5, #+16]
// 1379     j = pInit2LcVarArea->shIdxGlobalObjectMapPointers;
        LDRSH    R6,[R4, #+22]
        MOVS     R3,R6
// 1380     GlobalObjectMap.arPCLUDout_1_0[j] = static_cast<CLUDout_1_0*>(
// 1381        pInit2LcVarArea->pCLUBase);
        LDR      R6,[R4, #+12]
        LDR.W    R7,??DataTable27_2
        ADDS     R7,R7,R3, LSL #+2
        STR      R6,[R7, #+40]
// 1382     pInit2LcVarArea->shIdxGlobalObjectMapPointers++;//sLV.shIdx++           
        LDRH     R6,[R4, #+22]
        ADDS     R6,R6,#+1
        STRH     R6,[R4, #+22]
// 1383 }
        POP      {R4-R7}
        BX       LR               ;; return

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1384 void Shematic::SetupCLULedStngParam(void *pv){
_ZN8Shematic20SetupCLULedStngParamEPv:
        PUSH     {R4-R7}
// 1385     register long i,j;
// 1386     register Init2LcVarArea *pInit2LcVarArea = static_cast<Init2LcVarArea*>(pv);
        MOVS     R4,R1
// 1387     i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
        LDR.W    R5,??DataTable27
        LDRSH    R5,[R5, #+0]
        MOVS     R2,R5
// 1388     pv = static_cast<void*>(&(pInit2LcVarArea->arrLUAreaListElem[i-1]));
        LDR      R5,[R4, #+8]
        ADDS     R5,R5,R2, LSL #+3
        SUBS     R5,R5,#+8
        MOVS     R1,R5
// 1389     //pInit2LcVarArea->pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
// 1390     pInit2LcVarArea->pCLUBase = static_cast<CLUBase*>( 
// 1391                         (static_cast<LUAreaListElem*>(pv))->pvLU);
        LDR      R5,[R1, #+4]
        STR      R5,[R4, #+12]
// 1392     pInit2LcVarArea->pCLUBase->shShemasIdLUStng =  STNG_LU_LED;
        MOVS     R5,#+13
        LDR      R6,[R4, #+12]
        STRH     R5,[R6, #+10]
// 1393     i = pInit2LcVarArea->shCounterInitCLUObj - 1;
        LDRSH    R5,[R4, #+20]
        SUBS     R5,R5,#+1
        MOVS     R2,R5
// 1394     pInit2LcVarArea->pCLUBase->shShemasOrdNumStng = static_cast<unsigned char>(
// 1395     arrSBitFldCRefInfo[i].bfInfo_BaseID);
        LDR.N    R5,??DataTable16
        ADDS     R5,R5,R2, LSL #+3
        LDR      R5,[R5, #+4]
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        LDR      R6,[R4, #+12]
        STRH     R5,[R6, #+12]
// 1396     pInit2LcVarArea->shCounterInitCLUObj++;// sLV.shIdxLUOutDsc++;
        LDRH     R5,[R4, #+20]
        ADDS     R5,R5,#+1
        STRH     R5,[R4, #+20]
// 1397     CLULed* locPCLULed = static_cast<CLULed*>(pInit2LcVarArea->pCLUBase);
        LDR      R5,[R4, #+12]
// 1398     locPCLULed->pIn = static_cast<void*>(locPCLULed->arrPchIn);
        ADDS     R6,R5,#+24
        STR      R6,[R5, #+0]
// 1399     CLULed& locRef_CLULed = *(static_cast<CLULed*>(pInit2LcVarArea->pCLUBase));
        LDR      R6,[R4, #+12]
// 1400     locRef_CLULed.arrPchIn[0] = &chGblGround;
        LDR.W    R7,??DataTable27_3
        STR      R7,[R6, #+24]
// 1401     locRef_CLULed.chTypeLogicFunction = LU_OP_SET_LED;
        MOVS     R7,#+9
        STRB     R7,[R6, #+8]
// 1402     locRef_CLULed.LogicFunc = SET_LED_Op; //???
        LDR.W    R7,??DataTable27_5
        STR      R7,[R6, #+16]
// 1403     j = pInit2LcVarArea->shIdxGlobalObjectMapPointers;
        LDRSH    R7,[R4, #+22]
        MOVS     R3,R7
// 1404     
// 1405     GlobalObjectMap.arPCLULed[j] = static_cast<CLULed*>(
// 1406       pInit2LcVarArea->pCLUBase);
        LDR      R7,[R4, #+12]
        LDR.W    R12,??DataTable27_2
        ADDS     R12,R12,R3, LSL #+2
        STR      R7,[R12, #+80]
// 1407     pInit2LcVarArea->shIdxGlobalObjectMapPointers++;//sLV.shIdx++          
        LDRH     R7,[R4, #+22]
        ADDS     R7,R7,#+1
        STRH     R7,[R4, #+22]
// 1408 }
        POP      {R4-R7}
        BX       LR               ;; return

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1409 void Shematic::SetupCLUAnd_8_1StngParam(void *pv){
_ZN8Shematic24SetupCLUAnd_8_1StngParamEPv:
        PUSH     {R4-R7}
// 1410     register long i,j;
// 1411     register Init2LcVarArea *pInit2LcVarArea = static_cast<Init2LcVarArea*>(pv);
        MOVS     R4,R1
// 1412     i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
        LDR.W    R5,??DataTable27
        LDRSH    R5,[R5, #+0]
        MOVS     R2,R5
// 1413     pv = static_cast<void*>(&(pInit2LcVarArea->arrLUAreaListElem[i-1]));
        LDR      R5,[R4, #+8]
        ADDS     R5,R5,R2, LSL #+3
        SUBS     R5,R5,#+8
        MOVS     R1,R5
// 1414     //pInit2LcVarArea->pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
// 1415 	pInit2LcVarArea->pCLUBase = static_cast<CLUBase*>( 
// 1416                         (static_cast<LUAreaListElem*>(pv))->pvLU);
        LDR      R5,[R1, #+4]
        STR      R5,[R4, #+12]
// 1417     pInit2LcVarArea->pCLUBase->shShemasIdLUStng =  STNG_LU_AND;
        MOVS     R5,#+4
        LDR      R6,[R4, #+12]
        STRH     R5,[R6, #+10]
// 1418     i = pInit2LcVarArea->shCounterInitCLUObj - 1;
        LDRSH    R5,[R4, #+20]
        SUBS     R5,R5,#+1
        MOVS     R2,R5
// 1419     pInit2LcVarArea->pCLUBase->shShemasOrdNumStng = static_cast<unsigned char>(
// 1420     arrSBitFldCRefInfo[i].bfInfo_BaseID);
        LDR.N    R5,??DataTable16
        ADDS     R5,R5,R2, LSL #+3
        LDR      R5,[R5, #+4]
        UXTB     R5,R5            ;; ZeroExt  R5,R5,#+24,#+24
        LDR      R6,[R4, #+12]
        STRH     R5,[R6, #+12]
// 1421     pInit2LcVarArea->shCounterInitCLUObj++;// sLV.shIdxLUOutDsc++;
        LDRH     R5,[R4, #+20]
        ADDS     R5,R5,#+1
        STRH     R5,[R4, #+20]
// 1422     CLUAnd_8_1* locPCLUAnd_8_1 = static_cast<CLUAnd_8_1*>(pInit2LcVarArea->pCLUBase);
        LDR      R5,[R4, #+12]
// 1423     locPCLUAnd_8_1->pOut = static_cast<void*>(locPCLUAnd_8_1->arrOut);
        ADDS     R6,R5,#+56
        STR      R6,[R5, #+20]
// 1424     locPCLUAnd_8_1->pIn  = static_cast<void*>(locPCLUAnd_8_1->arrPchIn);
        ADDS     R6,R5,#+24
        STR      R6,[R5, #+0]
// 1425     CLUAnd_8_1& locRef_CLUAnd_8_1 = *(static_cast<CLUAnd_8_1*>(pInit2LcVarArea->pCLUBase));
        LDR      R6,[R4, #+12]
// 1426     locRef_CLUAnd_8_1.chTypeLogicFunction = LU_OP_AND; //
        MOVS     R7,#+2
        STRB     R7,[R6, #+8]
// 1427      for(i = 0; i < locRef_CLUAnd_8_1.chNumInput;i++)
        MOVS     R7,#+0
        MOVS     R2,R7
??SetupCLUAnd_8_1StngParam_0:
        LDRB     R7,[R6, #+6]
        CMP      R2,R7
        BGE.N    ??SetupCLUAnd_8_1StngParam_1
// 1428     locRef_CLUAnd_8_1.arrPchIn[i] = &chGblVcc;
        LDR.W    R7,??DataTable27_6
        ADDS     R12,R6,R2, LSL #+2
        STR      R7,[R12, #+24]
        ADDS     R2,R2,#+1
        B.N      ??SetupCLUAnd_8_1StngParam_0
// 1429     locRef_CLUAnd_8_1.LogicFunc = AND_Op_8_1; //???
??SetupCLUAnd_8_1StngParam_1:
        LDR.W    R7,??DataTable27_7
        STR      R7,[R6, #+16]
// 1430 
// 1431     j = pInit2LcVarArea->shIdxGlobalObjectMapPointers;
        LDRSH    R7,[R4, #+22]
        MOVS     R3,R7
// 1432     
// 1433     GlobalObjectMap.arPCLUAnd_8_1[j] = static_cast<CLUAnd_8_1*>(pInit2LcVarArea->pCLUBase);
        LDR      R7,[R4, #+12]
        LDR.W    R12,??DataTable27_2
        ADDS     R12,R12,R3, LSL #+2
        STR      R7,[R12, #+280]
// 1434     pInit2LcVarArea->shIdxGlobalObjectMapPointers++;//sLV.shIdx++          
        LDRH     R7,[R4, #+22]
        ADDS     R7,R7,#+1
        STRH     R7,[R4, #+22]
// 1435 }
        POP      {R4-R7}
        BX       LR               ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable12:
        DC32     ar_n_And_Dsc

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1436 void Shematic::SetupCLUOr_8_1StngParam(void *pv){
_ZN8Shematic23SetupCLUOr_8_1StngParamEPv:
        PUSH     {R4-R10,LR}
        MOVS     R4,R0
        MOVS     R5,R1
// 1437     register long i,j;
// 1438     register Init2LcVarArea *pInit2LcVarArea = static_cast<Init2LcVarArea*>(pv);
        MOV      R8,R5
// 1439     i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
        LDR.W    R0,??DataTable27
        LDRSH    R0,[R0, #+0]
        MOVS     R6,R0
// 1440     pv = static_cast<void*>(&(pInit2LcVarArea->arrLUAreaListElem[i-1]));
        LDR      R0,[R8, #+8]
        ADDS     R0,R0,R6, LSL #+3
        SUBS     R0,R0,#+8
        MOVS     R5,R0
// 1441     //pInit2LcVarArea->pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
// 1442 	pInit2LcVarArea->pCLUBase = static_cast<CLUBase*>( 
// 1443                         (static_cast<LUAreaListElem*>(pv))->pvLU);
        LDR      R0,[R5, #+4]
        STR      R0,[R8, #+12]
// 1444     pInit2LcVarArea->pCLUBase->shShemasIdLUStng =  STNG_LU_OR;
        MOVS     R0,#+5
        LDR      R1,[R8, #+12]
        STRH     R0,[R1, #+10]
// 1445     i = pInit2LcVarArea->shCounterInitCLUObj - 1;
        LDRSH    R0,[R8, #+20]
        SUBS     R0,R0,#+1
        MOVS     R6,R0
// 1446     pInit2LcVarArea->pCLUBase->shShemasOrdNumStng = static_cast<unsigned char>(
// 1447     arrSBitFldCRefInfo[i].bfInfo_BaseID);
        LDR.N    R0,??DataTable16
        ADDS     R0,R0,R6, LSL #+3
        LDR      R0,[R0, #+4]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDR      R1,[R8, #+12]
        STRH     R0,[R1, #+12]
// 1448     pInit2LcVarArea->shCounterInitCLUObj++;// sLV.shIdxLUOutDsc++;
        LDRH     R0,[R8, #+20]
        ADDS     R0,R0,#+1
        STRH     R0,[R8, #+20]
// 1449     CLUOr_8_1* locPCLUOr_8_1 = static_cast<CLUOr_8_1*>(pInit2LcVarArea->pCLUBase);
        LDR      R9,[R8, #+12]
// 1450     locPCLUOr_8_1->pOut = static_cast<void*>(locPCLUOr_8_1->arrOut);
        ADDS     R0,R9,#+56
        STR      R0,[R9, #+20]
// 1451     locPCLUOr_8_1->pIn  = static_cast<void*>(locPCLUOr_8_1->arrPchIn);
        ADDS     R0,R9,#+24
        STR      R0,[R9, #+0]
// 1452     CLUOr_8_1& locRef_CLUOr_8_1 = *(static_cast<CLUOr_8_1*>(pInit2LcVarArea->pCLUBase));
        LDR      R10,[R8, #+12]
// 1453     for(i = 0; i < locRef_CLUOr_8_1.chNumInput;i++)
        MOVS     R0,#+0
        MOVS     R6,R0
??SetupCLUOr_8_1StngParam_0:
        LDRB     R0,[R10, #+6]
        CMP      R6,R0
        BGE.N    ??SetupCLUOr_8_1StngParam_1
// 1454     locRef_CLUOr_8_1.arrPchIn[i] = &chGblGround;
        LDR.W    R0,??DataTable27_3
        ADDS     R1,R10,R6, LSL #+2
        STR      R0,[R1, #+24]
        ADDS     R6,R6,#+1
        B.N      ??SetupCLUOr_8_1StngParam_0
// 1455     locRef_CLUOr_8_1.LogicFunc(pInit2LcVarArea->pCLUBase);
??SetupCLUOr_8_1StngParam_1:
        LDR      R0,[R8, #+12]
        LDR      R1,[R10, #+16]
        BLX      R1
// 1456     j = pInit2LcVarArea->shIdxGlobalObjectMapPointers;
        LDRSH    R0,[R8, #+22]
        MOVS     R7,R0
// 1457     
// 1458     GlobalObjectMap.arPCLUOr_8_1[j] = 
// 1459       static_cast<CLUOr_8_1*>(pInit2LcVarArea->pCLUBase);
        LDR      R0,[R8, #+12]
        LDR.W    R1,??DataTable27_2
        ADDS     R1,R1,R7, LSL #+2
        STR      R0,[R1, #+200]
// 1460     pInit2LcVarArea->shIdxGlobalObjectMapPointers++;//sLV.shIdx++          
        LDRH     R0,[R8, #+22]
        ADDS     R0,R0,#+1
        STRH     R0,[R8, #+22]
// 1461 }
        POP      {R4-R10,PC}      ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable13:
        DC32     ar_n_Or_Dsc

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1462 void Shematic::SetupCLUXor_8_1StngParam(void *pv){
_ZN8Shematic24SetupCLUXor_8_1StngParamEPv:
        PUSH     {R4-R10,LR}
        MOVS     R4,R0
        MOVS     R5,R1
// 1463     register long i,j;
// 1464     register Init2LcVarArea *pInit2LcVarArea = static_cast<Init2LcVarArea*>(pv);
        MOV      R8,R5
// 1465     i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
        LDR.W    R0,??DataTable27
        LDRSH    R0,[R0, #+0]
        MOVS     R6,R0
// 1466     pv = static_cast<void*>(&(pInit2LcVarArea->arrLUAreaListElem[i-1]));
        LDR      R0,[R8, #+8]
        ADDS     R0,R0,R6, LSL #+3
        SUBS     R0,R0,#+8
        MOVS     R5,R0
// 1467     //pInit2LcVarArea->pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
// 1468 	pInit2LcVarArea->pCLUBase = static_cast<CLUBase*>( 
// 1469                         (static_cast<LUAreaListElem*>(pv))->pvLU);
        LDR      R0,[R5, #+4]
        STR      R0,[R8, #+12]
// 1470     pInit2LcVarArea->pCLUBase->shShemasIdLUStng =  STNG_LU_XOR;
        MOVS     R0,#+6
        LDR      R1,[R8, #+12]
        STRH     R0,[R1, #+10]
// 1471     i = pInit2LcVarArea->shCounterInitCLUObj - 1;
        LDRSH    R0,[R8, #+20]
        SUBS     R0,R0,#+1
        MOVS     R6,R0
// 1472     pInit2LcVarArea->pCLUBase->shShemasOrdNumStng = static_cast<unsigned char>(
// 1473     arrSBitFldCRefInfo[i].bfInfo_BaseID);
        LDR.N    R0,??DataTable16
        ADDS     R0,R0,R6, LSL #+3
        LDR      R0,[R0, #+4]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDR      R1,[R8, #+12]
        STRH     R0,[R1, #+12]
// 1474     pInit2LcVarArea->shCounterInitCLUObj++;// sLV.shIdxLUOutDsc++;
        LDRH     R0,[R8, #+20]
        ADDS     R0,R0,#+1
        STRH     R0,[R8, #+20]
// 1475     CLUXor_8_1* locPCLUXor_8_1 = static_cast<CLUXor_8_1*>(pInit2LcVarArea->pCLUBase);
        LDR      R9,[R8, #+12]
// 1476     locPCLUXor_8_1->pOut = static_cast<void*>(locPCLUXor_8_1->arrOut);
        ADDS     R0,R9,#+32
        STR      R0,[R9, #+20]
// 1477     locPCLUXor_8_1->pIn  = static_cast<void*>(locPCLUXor_8_1->arrPchIn);
        ADDS     R0,R9,#+24
        STR      R0,[R9, #+0]
// 1478     CLUXor_8_1& locRef_CLUXor_8_1 = *(static_cast<CLUXor_8_1*>(pInit2LcVarArea->pCLUBase));
        LDR      R10,[R8, #+12]
// 1479     for(i = 0; i < locRef_CLUXor_8_1.chNumInput;i++)
        MOVS     R0,#+0
        MOVS     R6,R0
??SetupCLUXor_8_1StngParam_0:
        LDRB     R0,[R10, #+6]
        CMP      R6,R0
        BGE.N    ??SetupCLUXor_8_1StngParam_1
// 1480     locRef_CLUXor_8_1.arrPchIn[i] = &chGblGround;
        LDR.W    R0,??DataTable27_3
        ADDS     R1,R10,R6, LSL #+2
        STR      R0,[R1, #+24]
        ADDS     R6,R6,#+1
        B.N      ??SetupCLUXor_8_1StngParam_0
// 1481     locRef_CLUXor_8_1.LogicFunc(pInit2LcVarArea->pCLUBase);
??SetupCLUXor_8_1StngParam_1:
        LDR      R0,[R8, #+12]
        LDR      R1,[R10, #+16]
        BLX      R1
// 1482     j = pInit2LcVarArea->shIdxGlobalObjectMapPointers;
        LDRSH    R0,[R8, #+22]
        MOVS     R7,R0
// 1483     
// 1484     GlobalObjectMap.arPCLUXor_8_1[j] = 
// 1485       static_cast<CLUXor_8_1*>(pInit2LcVarArea->pCLUBase);
        LDR      R0,[R8, #+12]
        LDR.W    R1,??DataTable27_2
        ADDS     R1,R1,R7, LSL #+2
        STR      R0,[R1, #+360]
// 1486     pInit2LcVarArea->shIdxGlobalObjectMapPointers++;//sLV.shIdx++          
        LDRH     R0,[R8, #+22]
        ADDS     R0,R0,#+1
        STRH     R0,[R8, #+22]
// 1487 }
        POP      {R4-R10,PC}      ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable14:
        DC32     ar_n_Xor_Dsc

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1488 void Shematic::SetupCLUNot_1_1StngParam(void *pv){
_ZN8Shematic24SetupCLUNot_1_1StngParamEPv:
        PUSH     {R4-R10,LR}
        MOVS     R4,R0
        MOVS     R5,R1
// 1489     register long i,j;
// 1490     register Init2LcVarArea *pInit2LcVarArea = static_cast<Init2LcVarArea*>(pv);
        MOV      R8,R5
// 1491     i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
        LDR.W    R0,??DataTable27
        LDRSH    R0,[R0, #+0]
        MOVS     R6,R0
// 1492     pv = static_cast<void*>(&(pInit2LcVarArea->arrLUAreaListElem[i-1]));
        LDR      R0,[R8, #+8]
        ADDS     R0,R0,R6, LSL #+3
        SUBS     R0,R0,#+8
        MOVS     R5,R0
// 1493     //pInit2LcVarArea->pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
// 1494 	pInit2LcVarArea->pCLUBase = static_cast<CLUBase*>( 
// 1495                         (static_cast<LUAreaListElem*>(pv))->pvLU);
        LDR      R0,[R5, #+4]
        STR      R0,[R8, #+12]
// 1496     pInit2LcVarArea->pCLUBase->shShemasIdLUStng =  STNG_LU_NOT;
        MOVS     R0,#+14
        LDR      R1,[R8, #+12]
        STRH     R0,[R1, #+10]
// 1497     i = pInit2LcVarArea->shCounterInitCLUObj - 1;
        LDRSH    R0,[R8, #+20]
        SUBS     R0,R0,#+1
        MOVS     R6,R0
// 1498     pInit2LcVarArea->pCLUBase->shShemasOrdNumStng = static_cast<unsigned char>(
// 1499     arrSBitFldCRefInfo[i].bfInfo_BaseID);
        LDR.N    R0,??DataTable16
        ADDS     R0,R0,R6, LSL #+3
        LDR      R0,[R0, #+4]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDR      R1,[R8, #+12]
        STRH     R0,[R1, #+12]
// 1500     pInit2LcVarArea->shCounterInitCLUObj++;// sLV.shIdxLUOutDsc++;
        LDRH     R0,[R8, #+20]
        ADDS     R0,R0,#+1
        STRH     R0,[R8, #+20]
// 1501     CLUNot_1_1* locPCLUNot_1_1 = static_cast<CLUNot_1_1*>(pInit2LcVarArea->pCLUBase);
        LDR      R9,[R8, #+12]
// 1502     locPCLUNot_1_1->pOut = static_cast<void*>(locPCLUNot_1_1->arrOut);
        ADDS     R0,R9,#+28
        STR      R0,[R9, #+20]
// 1503     locPCLUNot_1_1->pIn  = static_cast<void*>(locPCLUNot_1_1->arrPchIn);
        ADDS     R0,R9,#+24
        STR      R0,[R9, #+0]
// 1504     CLUNot_1_1& locRef_CLUNot_1_1 = *(static_cast<CLUNot_1_1*>(pInit2LcVarArea->pCLUBase));
        LDR      R10,[R8, #+12]
// 1505     locRef_CLUNot_1_1.LogicFunc(pInit2LcVarArea->pCLUBase);
        LDR      R0,[R8, #+12]
        LDR      R1,[R10, #+16]
        BLX      R1
// 1506     for(i = 0; i < locRef_CLUNot_1_1.chNumInput;i++)
        MOVS     R0,#+0
        MOVS     R6,R0
??SetupCLUNot_1_1StngParam_0:
        LDRB     R0,[R10, #+6]
        CMP      R6,R0
        BGE.N    ??SetupCLUNot_1_1StngParam_1
// 1507     locRef_CLUNot_1_1.arrPchIn[i] = &chGblGround;
        LDR.W    R0,??DataTable27_3
        ADDS     R1,R10,R6, LSL #+2
        STR      R0,[R1, #+24]
        ADDS     R6,R6,#+1
        B.N      ??SetupCLUNot_1_1StngParam_0
// 1508     j = pInit2LcVarArea->shIdxGlobalObjectMapPointers;
??SetupCLUNot_1_1StngParam_1:
        LDRSH    R0,[R8, #+22]
        MOVS     R7,R0
// 1509     
// 1510     GlobalObjectMap.arPCLUNot_1_1[j] = 
// 1511       static_cast<CLUNot_1_1*>(pInit2LcVarArea->pCLUBase);
        LDR      R0,[R8, #+12]
        LDR.W    R1,??DataTable27_2
        ADDS     R1,R1,R7, LSL #+2
        STR      R0,[R1, #+120]
// 1512     pInit2LcVarArea->shIdxGlobalObjectMapPointers++;//sLV.shIdx++          
        LDRH     R0,[R8, #+22]
        ADDS     R0,R0,#+1
        STRH     R0,[R8, #+22]
// 1513 }
        POP      {R4-R10,PC}      ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable15:
        DC32     ar_n_Not_Dsc

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1514 void Shematic::SetupCLUMft_2_1StngParam(void *pv){
_ZN8Shematic24SetupCLUMft_2_1StngParamEPv:
        PUSH     {R3-R9,LR}
        MOVS     R4,R0
        MOVS     R5,R1
// 1515     register long i,j;
// 1516     register Init2LcVarArea *pInit2LcVarArea = static_cast<Init2LcVarArea*>(pv);
        MOV      R8,R5
// 1517     i = gblLUAreaAuxVar.shAmountPlacedLogicUnit;
        LDR.W    R0,??DataTable27
        LDRSH    R0,[R0, #+0]
        MOVS     R6,R0
// 1518     pv = static_cast<void*>(&(pInit2LcVarArea->arrLUAreaListElem[i-1]));
        LDR      R0,[R8, #+8]
        ADDS     R0,R0,R6, LSL #+3
        SUBS     R0,R0,#+8
        MOVS     R5,R0
// 1519     //pInit2LcVarArea->pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
// 1520     pInit2LcVarArea->pCLUBase = static_cast<CLUBase*> (
// 1521             (static_cast<LUAreaListElem*> (pv))->pvLU);
        LDR      R0,[R5, #+4]
        STR      R0,[R8, #+12]
// 1522     pInit2LcVarArea->pCLUBase->shShemasIdLUStng =  STNG_LU_MFT;
        MOVS     R0,#+15
        LDR      R1,[R8, #+12]
        STRH     R0,[R1, #+10]
// 1523     i = pInit2LcVarArea->shCounterInitCLUObj - 1;
        LDRSH    R0,[R8, #+20]
        SUBS     R0,R0,#+1
        MOVS     R6,R0
// 1524     pInit2LcVarArea->pCLUBase->shShemasOrdNumStng = static_cast<unsigned char>(
// 1525     arrSBitFldCRefInfo[i].bfInfo_BaseID);
        LDR.N    R0,??DataTable16
        ADDS     R0,R0,R6, LSL #+3
        LDR      R0,[R0, #+4]
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        LDR      R1,[R8, #+12]
        STRH     R0,[R1, #+12]
// 1526     pInit2LcVarArea->shCounterInitCLUObj++;// sLV.shIdxLUOutDsc++;
        LDRH     R0,[R8, #+20]
        ADDS     R0,R0,#+1
        STRH     R0,[R8, #+20]
// 1527     //CLUNot_1_1* locPCLUNot_1_1 = static_cast<CLUNot_1_1*>(pInit2LcVarArea->pCLUBase);
// 1528     //locPCLUNot_1_1->pOut = static_cast<void*>(locPCLUNot_1_1->arrOut);
// 1529     //locPCLUNot_1_1->pIn  = static_cast<void*>(locPCLUNot_1_1->arrPchIn);
// 1530     CMft& rCMft = *(static_cast<CMft*>(pInit2LcVarArea->pCLUBase));
        LDR      R9,[R8, #+12]
// 1531     for(i = 0; i < rCMft.chNumInput;i++)
        MOVS     R0,#+0
        MOVS     R6,R0
??SetupCLUMft_2_1StngParam_0:
        LDRB     R0,[R9, #+6]
        CMP      R6,R0
        BGE.N    ??SetupCLUMft_2_1StngParam_1
// 1532     rCMft.arrPchIn[i] = &chGblGround;
        LDR.W    R0,??DataTable27_3
        ADDS     R1,R9,R6, LSL #+2
        STR      R0,[R1, #+24]
        ADDS     R6,R6,#+1
        B.N      ??SetupCLUMft_2_1StngParam_0
// 1533     
// 1534     rCMft.UpdateCMft();
??SetupCLUMft_2_1StngParam_1:
        MOV      R0,R9
        BL       _ZN4CMft10UpdateCMftEv
// 1535     i = rCMft.LinkMftTimers();
        MOV      R0,R9
        BL       _ZN4CMft13LinkMftTimersEv
        MOVS     R6,R0
// 1536     if(i==3 ){
        CMP      R6,#+3
        BNE.N    ??SetupCLUMft_2_1StngParam_2
// 1537        rCMft.chTypeLogicFunction = LU_OP_MFT; //
        MOVS     R0,#+10
        STRB     R0,[R9, #+8]
// 1538        rCMft.LogicFunc = Mft_Op;  
        LDR.W    R0,??DataTable27_8
        STR      R0,[R9, #+16]
// 1539     }
// 1540     rCMft.LogicFunc(pInit2LcVarArea->pCLUBase);
??SetupCLUMft_2_1StngParam_2:
        LDR      R0,[R8, #+12]
        LDR      R1,[R9, #+16]
        BLX      R1
// 1541     //???
// 1542     j = pInit2LcVarArea->shIdxGlobalObjectMapPointers;
        LDRSH    R0,[R8, #+22]
        MOVS     R7,R0
// 1543     
// 1544     GlobalObjectMap.arCMft[j] = 
// 1545       static_cast<CMft*>(pInit2LcVarArea->pCLUBase);
        LDR      R0,[R8, #+12]
        LDR.W    R1,??DataTable27_2
        ADDS     R1,R1,R7, LSL #+2
        STR      R0,[R1, #+440]
// 1546     pInit2LcVarArea->shIdxGlobalObjectMapPointers++;//sLV.shIdx++          
        LDRH     R0,[R8, #+22]
        ADDS     R0,R0,#+1
        STRH     R0,[R8, #+22]
// 1547 }
        POP      {R0,R4-R9,PC}    ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable16:
        DC32     arrSBitFldCRefInfo
// 1548 
// 1549 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1550 void GetHIDLU(void*pv, long lIdxLUinStng) {
_Z8GetHIDLUPvl:
        PUSH     {R4-R6,LR}
        MOVS     R4,R0
        MOVS     R5,R1
// 1551     register long i;
// 1552     i = Shematic::GetTrueOrderNum();
        BL       _ZN8Shematic15GetTrueOrderNumEv
        MOVS     R6,R0
// 1553     *(static_cast<long*>(pv)) = i;
        STR      R6,[R4, #+0]
// 1554 	//Aux OP
// 1555 	LL_CryaCrya += lIdxLUinStng>>16;
        LDR.W    R0,??DataTable27_9
        LDRD     R2,R3,[R0, #+0]
        ASRS     R0,R5,#+16
        ASRS     R1,R0,#+31
        ADDS     R0,R2,R0
        ADCS     R1,R3,R1
        LDR.W    R2,??DataTable27_9
        STRD     R0,R1,[R2, #+0]
// 1556 }
        POP      {R4-R6,PC}       ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable17:
        DC32     preSetUP
// 1557 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1558 void ResetarNum(void) {
// 1559     for (long j = 0; j < 300; j++)
_Z10ResetarNumv:
        MOVS     R0,#+0
??ResetarNum_0:
        CMP      R0,#+300
        BGE.N    ??ResetarNum_1
// 1560         arNum[j] = 0;
        MOVS     R1,#+0
        LDR.W    R2,??DataTable27_10
        STR      R1,[R2, R0, LSL #+2]
        ADDS     R0,R0,#+1
        B.N      ??ResetarNum_0
// 1561 	shCounterCalls_GLB = 0;	
??ResetarNum_1:
        MOVS     R0,#+0
        LDR.W    R1,??DataTable27_11
        STRH     R0,[R1, #+0]
// 1562 }
        BX       LR               ;; return
// 1563 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1564 long  Shematic::EvalIdxibnarrSBitFldCRefInfo(long lLUStng) {
_ZN8Shematic28EvalIdxibnarrSBitFldCRefInfoEl:
        PUSH     {R4}
        MOVS     R2,R0
// 1565     register long j;
// 1566     switch (lLUStng) {
        MOVS     R3,R1
        CMP      R3,#+4
        BEQ.N    ??EvalIdxibnarrSBitFldCRefInfo_0
        CMP      R3,#+5
        BEQ.N    ??EvalIdxibnarrSBitFldCRefInfo_1
        CMP      R3,#+6
        BEQ.N    ??EvalIdxibnarrSBitFldCRefInfo_2
        CMP      R3,#+11
        BEQ.N    ??EvalIdxibnarrSBitFldCRefInfo_3
        CMP      R3,#+12
        BEQ.N    ??EvalIdxibnarrSBitFldCRefInfo_4
        CMP      R3,#+13
        BEQ.N    ??EvalIdxibnarrSBitFldCRefInfo_5
        CMP      R3,#+14
        BEQ.N    ??EvalIdxibnarrSBitFldCRefInfo_6
        CMP      R3,#+15
        BEQ.N    ??EvalIdxibnarrSBitFldCRefInfo_7
        B.N      ??EvalIdxibnarrSBitFldCRefInfo_8
// 1567         case STNG_LU_AND:
// 1568             j = preSetUP.n_input
// 1569              + preSetUP.n_output + preSetUP.n_led;
??EvalIdxibnarrSBitFldCRefInfo_0:
        LDR.N    R3,??DataTable22
        LDR      R3,[R3, #+4]
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+8]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+12]
        ADDS     R3,R4,R3
        MOVS     R0,R3
// 1570             break;
        B.N      ??EvalIdxibnarrSBitFldCRefInfo_9
// 1571 
// 1572         case STNG_LU_OR:
// 1573              j = preSetUP.n_input
// 1574              + preSetUP.n_output + preSetUP.n_led + shCLUAnd_8_1_AmtIn*preSetUP.n_and;
??EvalIdxibnarrSBitFldCRefInfo_1:
        LDR.N    R3,??DataTable22
        LDR      R3,[R3, #+4]
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+8]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+12]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+16]
        ADDS     R3,R3,R4, LSL #+3
        MOVS     R0,R3
// 1575             break;
        B.N      ??EvalIdxibnarrSBitFldCRefInfo_9
// 1576 
// 1577         case STNG_LU_XOR:
// 1578             j = preSetUP.n_input
// 1579              + preSetUP.n_output + preSetUP.n_led + shCLUAnd_8_1_AmtIn*preSetUP.n_and
// 1580              + shCLUOr_8_1_AmtIn*preSetUP.n_or ;
??EvalIdxibnarrSBitFldCRefInfo_2:
        LDR.N    R3,??DataTable22
        LDR      R3,[R3, #+4]
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+8]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+12]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+16]
        ADDS     R3,R3,R4, LSL #+3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+20]
        ADDS     R3,R3,R4, LSL #+3
        MOVS     R0,R3
// 1581             break;
        B.N      ??EvalIdxibnarrSBitFldCRefInfo_9
// 1582 
// 1583         case STNG_LU_INPUT:
// 1584             j = 0;
??EvalIdxibnarrSBitFldCRefInfo_3:
        MOVS     R3,#+0
        MOVS     R0,R3
// 1585             break;
        B.N      ??EvalIdxibnarrSBitFldCRefInfo_9
// 1586 
// 1587         case STNG_LU_OUTPUT:
// 1588             j = preSetUP.n_input;
??EvalIdxibnarrSBitFldCRefInfo_4:
        LDR.N    R3,??DataTable22
        LDR      R3,[R3, #+4]
        MOVS     R0,R3
// 1589             break;
        B.N      ??EvalIdxibnarrSBitFldCRefInfo_9
// 1590 
// 1591         case STNG_LU_LED:
// 1592             j = preSetUP.n_input
// 1593                 +preSetUP.n_output;
??EvalIdxibnarrSBitFldCRefInfo_5:
        LDR.N    R3,??DataTable22
        LDR      R3,[R3, #+4]
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+8]
        ADDS     R3,R4,R3
        MOVS     R0,R3
// 1594             break;
        B.N      ??EvalIdxibnarrSBitFldCRefInfo_9
// 1595 
// 1596         case STNG_LU_NOT:
// 1597             j = preSetUP.n_input
// 1598                     + preSetUP.n_output + preSetUP.n_led 
// 1599                     + shCLUAnd_8_1_AmtIn * preSetUP.n_and
// 1600                     + shCLUOr_8_1_AmtIn  * preSetUP.n_or 
// 1601                     + shCLUXor_2_1_AmtIn * preSetUP.n_xor;
??EvalIdxibnarrSBitFldCRefInfo_6:
        LDR.N    R3,??DataTable22
        LDR      R3,[R3, #+4]
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+8]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+12]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+16]
        ADDS     R3,R3,R4, LSL #+3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+20]
        ADDS     R3,R3,R4, LSL #+3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+24]
        ADDS     R3,R3,R4, LSL #+1
        MOVS     R0,R3
// 1602             break;
        B.N      ??EvalIdxibnarrSBitFldCRefInfo_9
// 1603         case STNG_LU_MFT:
// 1604             j = preSetUP.n_input
// 1605                     + preSetUP.n_output + preSetUP.n_led
// 1606                     + shCLUAnd_8_1_AmtIn * preSetUP.n_and
// 1607                     + shCLUOr_8_1_AmtIn  * preSetUP.n_or 
// 1608                     + shCLUXor_2_1_AmtIn * preSetUP.n_xor
// 1609                     + shCLUNot_1_1_AmtIn * preSetUP.n_not;
??EvalIdxibnarrSBitFldCRefInfo_7:
        LDR.N    R3,??DataTable22
        LDR      R3,[R3, #+4]
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+8]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+12]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+16]
        ADDS     R3,R3,R4, LSL #+3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+20]
        ADDS     R3,R3,R4, LSL #+3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+24]
        ADDS     R3,R3,R4, LSL #+1
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+28]
        ADDS     R3,R4,R3
        MOVS     R0,R3
// 1610             break;
        B.N      ??EvalIdxibnarrSBitFldCRefInfo_9
// 1611 
// 1612         default:
// 1613             j = -1;
??EvalIdxibnarrSBitFldCRefInfo_8:
        MOVS     R3,#-1
        MOVS     R0,R3
// 1614     }
// 1615       return j;       
??EvalIdxibnarrSBitFldCRefInfo_9:
        POP      {R4}
        BX       LR               ;; return
// 1616             
// 1617 }

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1618 long  Shematic::EvalIdxinarrLUAreaListElem(long lLUStng) {
_ZN8Shematic26EvalIdxinarrLUAreaListElemEl:
        PUSH     {R4}
        MOVS     R2,R0
// 1619     register long j;
// 1620     switch (lLUStng) {
        MOVS     R3,R1
        CMP      R3,#+4
        BEQ.N    ??EvalIdxinarrLUAreaListElem_0
        CMP      R3,#+5
        BEQ.N    ??EvalIdxinarrLUAreaListElem_1
        CMP      R3,#+6
        BEQ.N    ??EvalIdxinarrLUAreaListElem_2
        CMP      R3,#+11
        BEQ.N    ??EvalIdxinarrLUAreaListElem_3
        CMP      R3,#+12
        BEQ.N    ??EvalIdxinarrLUAreaListElem_4
        CMP      R3,#+13
        BEQ.N    ??EvalIdxinarrLUAreaListElem_5
        CMP      R3,#+14
        BEQ.N    ??EvalIdxinarrLUAreaListElem_6
        CMP      R3,#+15
        BEQ.N    ??EvalIdxinarrLUAreaListElem_7
        B.N      ??EvalIdxinarrLUAreaListElem_8
// 1621         case STNG_LU_AND:
// 1622             j = preSetUP.n_input
// 1623              + preSetUP.n_output + preSetUP.n_led;
??EvalIdxinarrLUAreaListElem_0:
        LDR.N    R3,??DataTable22
        LDR      R3,[R3, #+4]
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+8]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+12]
        ADDS     R3,R4,R3
        MOVS     R0,R3
// 1624             break;
        B.N      ??EvalIdxinarrLUAreaListElem_9
// 1625 
// 1626         case STNG_LU_OR:
// 1627              j = preSetUP.n_input
// 1628              + preSetUP.n_output + preSetUP.n_led + preSetUP.n_and;
??EvalIdxinarrLUAreaListElem_1:
        LDR.N    R3,??DataTable22
        LDR      R3,[R3, #+4]
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+8]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+12]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+16]
        ADDS     R3,R4,R3
        MOVS     R0,R3
// 1629             break;
        B.N      ??EvalIdxinarrLUAreaListElem_9
// 1630 
// 1631         case STNG_LU_XOR:
// 1632             j = preSetUP.n_input
// 1633              + preSetUP.n_output + preSetUP.n_led + preSetUP.n_and
// 1634              + preSetUP.n_or ;
??EvalIdxinarrLUAreaListElem_2:
        LDR.N    R3,??DataTable22
        LDR      R3,[R3, #+4]
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+8]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+12]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+16]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+20]
        ADDS     R3,R4,R3
        MOVS     R0,R3
// 1635             break;
        B.N      ??EvalIdxinarrLUAreaListElem_9
// 1636 
// 1637         case STNG_LU_INPUT:
// 1638             j = 0;
??EvalIdxinarrLUAreaListElem_3:
        MOVS     R3,#+0
        MOVS     R0,R3
// 1639             break;
        B.N      ??EvalIdxinarrLUAreaListElem_9
// 1640 
// 1641         case STNG_LU_OUTPUT:
// 1642             j = preSetUP.n_input;
??EvalIdxinarrLUAreaListElem_4:
        LDR.N    R3,??DataTable22
        LDR      R3,[R3, #+4]
        MOVS     R0,R3
// 1643             break;
        B.N      ??EvalIdxinarrLUAreaListElem_9
// 1644 
// 1645         case STNG_LU_LED:
// 1646             j = preSetUP.n_input
// 1647                 +preSetUP.n_output;
??EvalIdxinarrLUAreaListElem_5:
        LDR.N    R3,??DataTable22
        LDR      R3,[R3, #+4]
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+8]
        ADDS     R3,R4,R3
        MOVS     R0,R3
// 1648             break;
        B.N      ??EvalIdxinarrLUAreaListElem_9
// 1649 
// 1650         case STNG_LU_NOT:
// 1651                j = preSetUP.n_input
// 1652              + preSetUP.n_output + preSetUP.n_led + preSetUP.n_and
// 1653              + preSetUP.n_or + preSetUP.n_xor ;
??EvalIdxinarrLUAreaListElem_6:
        LDR.N    R3,??DataTable22
        LDR      R3,[R3, #+4]
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+8]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+12]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+16]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+20]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+24]
        ADDS     R3,R4,R3
        MOVS     R0,R3
// 1654             break;
        B.N      ??EvalIdxinarrLUAreaListElem_9
// 1655         case STNG_LU_MFT:
// 1656                j = preSetUP.n_input
// 1657              + preSetUP.n_output + preSetUP.n_led + preSetUP.n_and
// 1658              + preSetUP.n_or + preSetUP.n_xor + preSetUP.n_not;
??EvalIdxinarrLUAreaListElem_7:
        LDR.N    R3,??DataTable22
        LDR      R3,[R3, #+4]
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+8]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+12]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+16]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+20]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+24]
        ADDS     R3,R4,R3
        LDR.N    R4,??DataTable22
        LDR      R4,[R4, #+28]
        ADDS     R3,R4,R3
        MOVS     R0,R3
// 1659             break;
        B.N      ??EvalIdxinarrLUAreaListElem_9
// 1660 
// 1661         default:
// 1662             j = -1;
??EvalIdxinarrLUAreaListElem_8:
        MOVS     R3,#-1
        MOVS     R0,R3
// 1663     }
// 1664       return j;       
??EvalIdxinarrLUAreaListElem_9:
        POP      {R4}
        BX       LR               ;; return
// 1665             
// 1666 }

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1667 long  Shematic::EvalAmtIn_arrLUAreaListElem(long lLUStng) {
_ZN8Shematic27EvalAmtIn_arrLUAreaListElemEl:
        MOVS     R2,R0
// 1668     register long j;
// 1669     switch (lLUStng) {
        MOVS     R3,R1
        CMP      R3,#+4
        BEQ.N    ??EvalAmtIn_arrLUAreaListElem_0
        CMP      R3,#+5
        BEQ.N    ??EvalAmtIn_arrLUAreaListElem_1
        CMP      R3,#+6
        BEQ.N    ??EvalAmtIn_arrLUAreaListElem_2
        CMP      R3,#+11
        BEQ.N    ??EvalAmtIn_arrLUAreaListElem_3
        CMP      R3,#+12
        BEQ.N    ??EvalAmtIn_arrLUAreaListElem_4
        CMP      R3,#+13
        BEQ.N    ??EvalAmtIn_arrLUAreaListElem_5
        CMP      R3,#+14
        BEQ.N    ??EvalAmtIn_arrLUAreaListElem_6
        CMP      R3,#+15
        BEQ.N    ??EvalAmtIn_arrLUAreaListElem_7
        B.N      ??EvalAmtIn_arrLUAreaListElem_8
// 1670         case STNG_LU_AND:
// 1671             j = preSetUP.n_and;
??EvalAmtIn_arrLUAreaListElem_0:
        LDR.N    R3,??DataTable22
        LDR      R3,[R3, #+16]
        MOVS     R0,R3
// 1672             break;
        B.N      ??EvalAmtIn_arrLUAreaListElem_9
// 1673 
// 1674         case STNG_LU_OR:
// 1675              j = preSetUP.n_or;
??EvalAmtIn_arrLUAreaListElem_1:
        LDR.N    R3,??DataTable22
        LDR      R3,[R3, #+20]
        MOVS     R0,R3
// 1676             break;
        B.N      ??EvalAmtIn_arrLUAreaListElem_9
// 1677 
// 1678         case STNG_LU_XOR:
// 1679             j = preSetUP.n_xor;
??EvalAmtIn_arrLUAreaListElem_2:
        LDR.N    R3,??DataTable22
        LDR      R3,[R3, #+24]
        MOVS     R0,R3
// 1680             break;
        B.N      ??EvalAmtIn_arrLUAreaListElem_9
// 1681 
// 1682         case STNG_LU_INPUT:
// 1683             j = preSetUP.n_input;
??EvalAmtIn_arrLUAreaListElem_3:
        LDR.N    R3,??DataTable22
        LDR      R3,[R3, #+4]
        MOVS     R0,R3
// 1684             break;
        B.N      ??EvalAmtIn_arrLUAreaListElem_9
// 1685 
// 1686         case STNG_LU_OUTPUT:
// 1687             j = preSetUP.n_output;
??EvalAmtIn_arrLUAreaListElem_4:
        LDR.N    R3,??DataTable22
        LDR      R3,[R3, #+8]
        MOVS     R0,R3
// 1688             break;
        B.N      ??EvalAmtIn_arrLUAreaListElem_9
// 1689 
// 1690         case STNG_LU_LED:
// 1691             j = preSetUP.n_led;
??EvalAmtIn_arrLUAreaListElem_5:
        LDR.N    R3,??DataTable22
        LDR      R3,[R3, #+12]
        MOVS     R0,R3
// 1692             break;
        B.N      ??EvalAmtIn_arrLUAreaListElem_9
// 1693 
// 1694         case STNG_LU_NOT:
// 1695                j = preSetUP.n_not;
??EvalAmtIn_arrLUAreaListElem_6:
        LDR.N    R3,??DataTable22
        LDR      R3,[R3, #+28]
        MOVS     R0,R3
// 1696             break;
        B.N      ??EvalAmtIn_arrLUAreaListElem_9
// 1697         case STNG_LU_MFT:
// 1698                j = preSetUP.n_timers;
??EvalAmtIn_arrLUAreaListElem_7:
        LDR.N    R3,??DataTable22
        LDR      R3,[R3, #+32]
        MOVS     R0,R3
// 1699             break;
        B.N      ??EvalAmtIn_arrLUAreaListElem_9
// 1700 
// 1701         default:
// 1702             j = -1;
??EvalAmtIn_arrLUAreaListElem_8:
        MOVS     R3,#-1
        MOVS     R0,R3
// 1703     }
// 1704       return j;       
??EvalAmtIn_arrLUAreaListElem_9:
        BX       LR               ;; return
// 1705             
// 1706 }
// 1707 
// 1708 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1709 long  Shematic::FillSBitFld_LUInInfo(void *pvIn,void *pvOut){
_ZN8Shematic20FillSBitFld_LUInInfoEPvS0_:
        PUSH     {R3-R9,LR}
        MOVS     R4,R0
        MOVS     R5,R1
        MOVS     R6,R2
// 1710     //Now use Index in ordered CrCRefInfo
// 1711 register long i,j;
// 1712 volatile CLUBase* plcCLUBase;
// 1713 //i =  
// 1714 
// 1715 plcCLUBase = (static_cast<LUCRefExchParam*>( pvIn))->pCLUBase;
        LDR      R0,[R5, #+4]
        MOV      R9,R0
// 1716         
// 1717 j = plcCLUBase->shShemasIdLUStng;
        LDRSH    R0,[R9, #+10]
        MOV      R8,R0
// 1718 i = EvalIdxibnarrSBitFldCRefInfo(j);
        MOV      R1,R8
        MOVS     R0,R4
        BL       _ZN8Shematic28EvalIdxibnarrSBitFldCRefInfoEl
        MOVS     R7,R0
// 1719 j = (static_cast<LUCRefExchParam*>( pvIn))->shLU_ObjScanIndex;
        LDRSH    R0,[R5, #+0]
        MOV      R8,R0
// 1720 j *= plcCLUBase->chNumInput;
        LDRB     R0,[R9, #+6]
        MUL      R8,R0,R8
// 1721 i += j;
        ADDS     R7,R8,R7
// 1722 i += (static_cast<LUCRefExchParam*>( pvIn))->chLU_OrdNumIn;
        LDRB     R0,[R5, #+2]
        ADDS     R7,R0,R7
// 1723 *(static_cast<SBitFld_LUInInfo*>(pvOut) ) = arrSBitFldCRefInfo[i].sBitLUInputInfo;  
        LDR.W    R0,??DataTable27_12
        LDR      R0,[R0, R7, LSL #+3]
        STR      R0,[R6, #+0]
// 1724     return 0;
        MOVS     R0,#+0
        POP      {R1,R4-R9,PC}    ;; return
// 1725 //Alternative Variant?
// 1726     //Use ((CLUBase*)plcCLUBase)->shShemasIdLUStng && shShemasIdLUStng
// 1727     //to Find Record
// 1728     //then Use ((LUCRefExchParam*) pvIn)->chLU_OrdNumIn to fix Input
// 1729 }

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable22:
        DC32     preSetUP

        SECTION `.text`:CODE:NOROOT(2)
        THUMB
// 1730 void Shematic::SetupCircutLinks(void *pv) {
_ZN8Shematic16SetupCircutLinksEPv:
        PUSH     {R4-R9,LR}
        SUB      SP,SP,#+52
        MOVS     R4,R0
        MOVS     R5,R1
// 1731     register long i,j;
// 1732     
// 1733 //	short shAmtPlacedLU;
// 1734 //	short shAmtLUDscElem;//SBitFldCRefInfo Elem
// 1735 	
// 1736 struct {
// 1737 	short shAmtLU, shIdx;
// 1738         short shCounterScanedObj,shCounterFindObj;
// 1739         short shAmtLookObj;
// 1740         long lBaseOrdNumStng;
// 1741         SBitFldCRefInfo *pSBitFldCRefInfo;
// 1742         LUCrossRefDsc lcLUCrossRefData;
// 1743         CLUBase  *pCLURef;//*pCLUBase,
// 1744 } sLV;
// 1745 SBitFld_LUInInfo locSBitFld;
// 1746 LUCRefExchParam lcLUCRefExchParam;
// 1747 Init2LcVarArea& rsLV = *(static_cast<Init2LcVarArea*>(pv));
        MOV      R8,R5
// 1748     i = j = 0;
        MOVS     R0,#+0
        MOVS     R7,R0
        MOVS     R6,R7
// 1749 
// 1750     sLV.shIdx = sLV.shAmtLU = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+0]
        LDRH     R0,[SP, #+0]
        STRH     R0,[SP, #+2]
// 1751 //    rsLV = *((Init2LcVarArea*) pv);
// 1752     sLV.pSBitFldCRefInfo = &arrSBitFldCRefInfo[0]; //Table Links
        LDR.W    R0,??DataTable27_12
        STR      R0,[SP, #+16]
// 1753     rsLV.arrLUAreaListElem = &gLUAreaMem.headLUAreaList;
        LDR.N    R0,??SetupCircutLinks_0
        B.N      ??SetupCircutLinks_1
        Nop      
        DATA
??SetupCircutLinks_0:
        DC32     gLUAreaMem
        THUMB
??SetupCircutLinks_1:
        STR      R0,[R8, #+8]
// 1754 	
// 1755 
// 1756     if (preSetUP.n_output != 0) {
        LDR.W    R0,??DataTable27_13
        LDR      R0,[R0, #+8]
        CMP      R0,#+0
        BEQ.W    ??SetupCircutLinks_2
// 1757         sLV.shCounterScanedObj = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+4]
// 1758         sLV.shAmtLU = preSetUP.n_output;
        LDR.W    R0,??DataTable27_13
        LDR      R0,[R0, #+8]
        STRH     R0,[SP, #+0]
// 1759         j = 0; //Idx in OutPut for Test
        MOVS     R0,#+0
        MOVS     R7,R0
// 1760         sLV.shIdx += preSetUP.n_input;
        LDRH     R0,[SP, #+2]
        LDR.W    R1,??DataTable27_13
        LDR      R1,[R1, #+4]
        ADDS     R0,R1,R0
        STRH     R0,[SP, #+2]
// 1761         i = sLV.shIdx; //Offset Output
        LDRSH    R0,[SP, #+2]
        MOVS     R6,R0
// 1762         do {
// 1763             //Type Obj == STNG_LU_OUTPUT order num == sLV.shCounterScanedObj+sLV.shIdx
// 1764             i = sLV.shCounterScanedObj + sLV.shIdx;
??SetupCircutLinks_3:
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+2]
        ADDS     R0,R1,R0
        MOVS     R6,R0
// 1765             pv = static_cast<void*>(&rsLV.arrLUAreaListElem[i]);
        LDR      R0,[R8, #+8]
        ADDS     R0,R0,R6, LSL #+3
        MOVS     R5,R0
// 1766             //rsLV.pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
// 1767             rsLV.pCLUBase = static_cast<CLUBase*> (
// 1768                     (static_cast<LUAreaListElem*> (pv))->pvLU);
        LDR      R0,[R5, #+4]
        STR      R0,[R8, #+12]
// 1769             
// 1770             //Take info 2 Possible Variants
// 1771             //1-st STNG_LU_OUTPUT And shShemasOrdNumStng
// 1772             //2-nd use Index in ordered CrCRefInfo
// 1773             for (long ik = 0; ik < rsLV.pCLUBase->chNumInput; ik++) {
        MOVS     R9,#+0
??SetupCircutLinks_4:
        LDR      R0,[R8, #+12]
        LDRB     R0,[R0, #+6]
        CMP      R9,R0
        BGE.W    ??SetupCircutLinks_5
// 1774                 lcLUCRefExchParam.shLU_ObjScanIndex = sLV.shCounterScanedObj;
        LDRH     R0,[SP, #+4]
        STRH     R0,[SP, #+40]
// 1775                 lcLUCRefExchParam.chLU_OrdNumIn = ik;// + 1; in function use as Idx
        MOV      R0,R9
        STRB     R0,[SP, #+42]
// 1776                 lcLUCRefExchParam.pCLUBase = rsLV.pCLUBase;
        LDR      R0,[R8, #+12]
        STR      R0,[SP, #+44]
// 1777                 FillSBitFld_LUInInfo( static_cast<void*>(&lcLUCRefExchParam), 
// 1778 				static_cast<void*>(&locSBitFld) );
        ADD      R2,SP,#+36
        ADD      R1,SP,#+40
        MOVS     R0,R4
        BL       _ZN8Shematic20FillSBitFld_LUInInfoEPvS0_
// 1779                 //Have OutPut Param               
// 1780                 sLV.lcLUCrossRefData.shRefIdLUStng   = locSBitFld.bfInfo_IdLUStng;
        LDR      R0,[SP, #+36]
        LSRS     R0,R0,#+24
        STRH     R0,[SP, #+24]
// 1781                 sLV.lcLUCrossRefData.shRefOrdNumStng = locSBitFld.bfInfo_OrdNumStng;
        LDR      R0,[SP, #+36]
        LSRS     R0,R0,#+16
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        STRH     R0,[SP, #+26]
// 1782                 sLV.lcLUCrossRefData.chRefOrdNumOut  = locSBitFld.bfInfo_OrdNumOut;
        LDR      R0,[SP, #+36]
        STRB     R0,[SP, #+28]
// 1783                  //Find Obj
// 1784                 j = EvalIdxinarrLUAreaListElem(sLV.lcLUCrossRefData.shRefIdLUStng);
        LDRSH    R1,[SP, #+24]
        MOVS     R0,R4
        BL       _ZN8Shematic26EvalIdxinarrLUAreaListElemEl
        MOVS     R7,R0
// 1785                 if(j!=(-1)){
        CMN      R7,#+1
        BEQ.N    ??SetupCircutLinks_6
// 1786                     sLV.shCounterFindObj = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+6]
// 1787                     sLV.shAmtLookObj = EvalAmtIn_arrLUAreaListElem(sLV.lcLUCrossRefData.shRefIdLUStng);
        LDRSH    R1,[SP, #+24]
        MOVS     R0,R4
        BL       _ZN8Shematic27EvalAmtIn_arrLUAreaListElemEl
        STRH     R0,[SP, #+8]
// 1788                     if(sLV.shAmtLookObj == (-1))
        LDRSH    R0,[SP, #+8]
        CMN      R0,#+1
        BNE.N    ??SetupCircutLinks_7
// 1789                         sLV.shAmtLookObj = gblLUAreaAuxVar.shAmountPlacedLogicUnit-j;//Test Only
        LDR.W    R0,??DataTable27
        LDRH     R0,[R0, #+0]
        SUBS     R0,R0,R7
        STRH     R0,[SP, #+8]
// 1790                     //i = j+sLV.shCounterFindObj;
// 1791                     rsLV.chVal = 0;rsLV.pCh = static_cast<char*>(0);
??SetupCircutLinks_7:
        MOVS     R0,#+0
        STRB     R0,[R8, #+48]
        MOVS     R0,#+0
        STR      R0,[R8, #+0]
// 1792                     while ((sLV.shCounterFindObj)<sLV.shAmtLookObj && rsLV.chVal!=1) {
??SetupCircutLinks_8:
        LDRSH    R0,[SP, #+6]
        LDRSH    R1,[SP, #+8]
        CMP      R0,R1
        BGE.N    ??SetupCircutLinks_9
        LDRB     R0,[R8, #+48]
        CMP      R0,#+1
        BEQ.N    ??SetupCircutLinks_9
// 1793                         i = j+sLV.shCounterFindObj;
        LDRSH    R0,[SP, #+6]
        ADDS     R0,R0,R7
        MOVS     R6,R0
// 1794                         pv = static_cast<void*>(&rsLV.arrLUAreaListElem[i]);
        LDR      R0,[R8, #+8]
        ADDS     R0,R0,R6, LSL #+3
        MOVS     R5,R0
// 1795                         //sLV.pCLURef = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
// 1796                         sLV.pCLURef = static_cast<CLUBase*> (
// 1797                                 (static_cast<LUAreaListElem*> (pv))->pvLU);
        LDR      R0,[R5, #+4]
        STR      R0,[SP, #+32]
// 1798                         if ((sLV.pCLURef->shShemasIdLUStng == sLV.lcLUCrossRefData.shRefIdLUStng) &&
// 1799                                 (sLV.pCLURef->shShemasOrdNumStng == sLV.lcLUCrossRefData.shRefOrdNumStng)
// 1800                             ){//Set UP Logic
        LDR      R0,[SP, #+32]
        LDRSH    R0,[R0, #+10]
        LDRSH    R1,[SP, #+24]
        CMP      R0,R1
        BNE.N    ??SetupCircutLinks_10
        LDR      R0,[SP, #+32]
        LDRSH    R0,[R0, #+12]
        LDRSH    R1,[SP, #+26]
        CMP      R0,R1
        BNE.N    ??SetupCircutLinks_10
// 1801                             rsLV.pCh = static_cast<char*>(sLV.pCLURef->pOut);
        LDR      R0,[SP, #+32]
        LDR      R0,[R0, #+20]
        STR      R0,[R8, #+0]
// 1802                             rsLV.pCh += sLV.lcLUCrossRefData.chRefOrdNumOut -1;//As Idx
        LDR      R0,[R8, #+0]
        LDRB     R1,[SP, #+28]
        ADDS     R0,R1,R0
        SUBS     R0,R0,#+1
        STR      R0,[R8, #+0]
// 1803                             rsLV.chVal = 1;
        MOVS     R0,#+1
        STRB     R0,[R8, #+48]
// 1804                             break;
        B.N      ??SetupCircutLinks_9
// 1805                         }
// 1806                     sLV.shCounterFindObj++;
??SetupCircutLinks_10:
        LDRH     R0,[SP, #+6]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+6]
        B.N      ??SetupCircutLinks_8
// 1807                     }
// 1808                     if (rsLV.pCh) {
??SetupCircutLinks_9:
        LDR      R0,[R8, #+0]
        CMP      R0,#+0
        BEQ.N    ??SetupCircutLinks_11
// 1809                         rsLV.arrPchIn = static_cast<char**>(rsLV.pCLUBase->pIn);
        LDR      R0,[R8, #+12]
        LDR      R0,[R0, #+0]
        STR      R0,[R8, #+4]
// 1810                         rsLV.arrPchIn[ik] = rsLV.pCh;
        LDR      R0,[R8, #+0]
        LDR      R1,[R8, #+4]
        STR      R0,[R1, R9, LSL #+2]
// 1811                        
// 1812                     }
// 1813                     if(rsLV.chVal != 1)
??SetupCircutLinks_11:
        LDRB     R0,[R8, #+48]
        CMP      R0,#+1
        BEQ.N    ??SetupCircutLinks_6
// 1814                         rsLV.chErrCount++;//Is need?
        LDRB     R0,[R8, #+49]
        ADDS     R0,R0,#+1
        STRB     R0,[R8, #+49]
// 1815                 }
// 1816             }
??SetupCircutLinks_6:
        ADDS     R9,R9,#+1
        B.N      ??SetupCircutLinks_4
// 1817         } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
??SetupCircutLinks_5:
        LDRH     R0,[SP, #+4]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+4]
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+0]
        CMP      R0,R1
        BLT.W    ??SetupCircutLinks_3
// 1818     }
// 1819     if (preSetUP.n_led != 0) {
??SetupCircutLinks_2:
        LDR.N    R0,??DataTable27_13
        LDR      R0,[R0, #+12]
        CMP      R0,#+0
        BEQ.N    ??SetupCircutLinks_12
// 1820         sLV.shCounterScanedObj = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+4]
// 1821         sLV.shAmtLU = preSetUP.n_led;
        LDR.N    R0,??DataTable27_13
        LDR      R0,[R0, #+12]
        STRH     R0,[SP, #+0]
// 1822         j = 0; //Idx in OutPut for Test
        MOVS     R0,#+0
        MOVS     R7,R0
// 1823         sLV.shIdx += preSetUP.n_output;
        LDRH     R0,[SP, #+2]
        LDR.N    R1,??DataTable27_13
        LDR      R1,[R1, #+8]
        ADDS     R0,R1,R0
        STRH     R0,[SP, #+2]
// 1824         rsLV.shIdx = sLV.shIdx; rsLV.pV = static_cast<void*>(&sLV.shCounterScanedObj);
        LDRH     R0,[SP, #+2]
        STRH     R0,[R8, #+42]
        ADD      R0,SP,#+4
        STR      R0,[R8, #+24]
// 1825         do{
// 1826             SetupCLUInternalRef(static_cast<void*>(&rsLV));
??SetupCircutLinks_13:
        MOV      R1,R8
        MOVS     R0,R4
        BL       _ZN8Shematic19SetupCLUInternalRefEPv
// 1827         
// 1828         }while (++sLV.shCounterScanedObj < sLV.shAmtLU); 
        LDRH     R0,[SP, #+4]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+4]
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+0]
        CMP      R0,R1
        BLT.N    ??SetupCircutLinks_13
// 1829     }
// 1830     if (preSetUP.n_and != 0) {
??SetupCircutLinks_12:
        LDR.N    R0,??DataTable27_13
        LDR      R0,[R0, #+16]
        CMP      R0,#+0
        BEQ.N    ??SetupCircutLinks_14
// 1831         sLV.shCounterScanedObj = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+4]
// 1832         sLV.shAmtLU = preSetUP.n_and;
        LDR.N    R0,??DataTable27_13
        LDR      R0,[R0, #+16]
        STRH     R0,[SP, #+0]
// 1833         j = 0; //Idx in OutPut for Test
        MOVS     R0,#+0
        MOVS     R7,R0
// 1834         sLV.shIdx += preSetUP.n_led;
        LDRH     R0,[SP, #+2]
        LDR.N    R1,??DataTable27_13
        LDR      R1,[R1, #+12]
        ADDS     R0,R1,R0
        STRH     R0,[SP, #+2]
// 1835         rsLV.shIdx = sLV.shIdx; rsLV.pV = static_cast<void*>(&sLV.shCounterScanedObj);
        LDRH     R0,[SP, #+2]
        STRH     R0,[R8, #+42]
        ADD      R0,SP,#+4
        STR      R0,[R8, #+24]
// 1836         do {
// 1837             SetupCLUInternalRef(static_cast<void*>(&rsLV));
??SetupCircutLinks_15:
        MOV      R1,R8
        MOVS     R0,R4
        BL       _ZN8Shematic19SetupCLUInternalRefEPv
// 1838         } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
        LDRH     R0,[SP, #+4]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+4]
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+0]
        CMP      R0,R1
        BLT.N    ??SetupCircutLinks_15
// 1839     }
// 1840     if (preSetUP.n_or != 0) {
??SetupCircutLinks_14:
        LDR.N    R0,??DataTable27_13
        LDR      R0,[R0, #+20]
        CMP      R0,#+0
        BEQ.N    ??SetupCircutLinks_16
// 1841         sLV.shCounterScanedObj = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+4]
// 1842         sLV.shAmtLU = preSetUP.n_or;
        LDR.N    R0,??DataTable27_13
        LDR      R0,[R0, #+20]
        STRH     R0,[SP, #+0]
// 1843         j = 0;
        MOVS     R0,#+0
        MOVS     R7,R0
// 1844         sLV.shIdx += preSetUP.n_and;
        LDRH     R0,[SP, #+2]
        LDR.N    R1,??DataTable27_13
        LDR      R1,[R1, #+16]
        ADDS     R0,R1,R0
        STRH     R0,[SP, #+2]
// 1845         rsLV.shIdx = sLV.shIdx; rsLV.pV = static_cast<void*>(&sLV.shCounterScanedObj);
        LDRH     R0,[SP, #+2]
        STRH     R0,[R8, #+42]
        ADD      R0,SP,#+4
        STR      R0,[R8, #+24]
// 1846         do {
// 1847             SetupCLUInternalRef(static_cast<void*>(&rsLV));
??SetupCircutLinks_17:
        MOV      R1,R8
        MOVS     R0,R4
        BL       _ZN8Shematic19SetupCLUInternalRefEPv
// 1848         } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
        LDRH     R0,[SP, #+4]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+4]
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+0]
        CMP      R0,R1
        BLT.N    ??SetupCircutLinks_17
// 1849     }
// 1850     if (preSetUP.n_xor != 0) {
??SetupCircutLinks_16:
        LDR.N    R0,??DataTable27_13
        LDR      R0,[R0, #+24]
        CMP      R0,#+0
        BEQ.N    ??SetupCircutLinks_18
// 1851 	sLV.shCounterScanedObj = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+4]
// 1852         sLV.shAmtLU = preSetUP.n_xor;
        LDR.N    R0,??DataTable27_13
        LDR      R0,[R0, #+24]
        STRH     R0,[SP, #+0]
// 1853         j = 0; //Idx in OutPut for Test
        MOVS     R0,#+0
        MOVS     R7,R0
// 1854         sLV.shIdx += preSetUP.n_or;
        LDRH     R0,[SP, #+2]
        LDR.N    R1,??DataTable27_13
        LDR      R1,[R1, #+20]
        ADDS     R0,R1,R0
        STRH     R0,[SP, #+2]
// 1855         rsLV.shIdx = sLV.shIdx; rsLV.pV = static_cast<void*>(&sLV.shCounterScanedObj);
        LDRH     R0,[SP, #+2]
        STRH     R0,[R8, #+42]
        ADD      R0,SP,#+4
        STR      R0,[R8, #+24]
// 1856         do {
// 1857             SetupCLUInternalRef(static_cast<void*>(&rsLV));
??SetupCircutLinks_19:
        MOV      R1,R8
        MOVS     R0,R4
        BL       _ZN8Shematic19SetupCLUInternalRefEPv
// 1858         } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
        LDRH     R0,[SP, #+4]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+4]
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+0]
        CMP      R0,R1
        BLT.N    ??SetupCircutLinks_19
// 1859     }
// 1860     if (preSetUP.n_not != 0) {
??SetupCircutLinks_18:
        LDR.N    R0,??DataTable27_13
        LDR      R0,[R0, #+28]
        CMP      R0,#+0
        BEQ.N    ??SetupCircutLinks_20
// 1861 	sLV.shCounterScanedObj = 0;
        MOVS     R0,#+0
        STRH     R0,[SP, #+4]
// 1862         sLV.shAmtLU = preSetUP.n_not;
        LDR.N    R0,??DataTable27_13
        LDR      R0,[R0, #+28]
        STRH     R0,[SP, #+0]
// 1863         j = 0; //Idx in OutPut for Test
        MOVS     R0,#+0
        MOVS     R7,R0
// 1864         sLV.shIdx += preSetUP.n_xor;
        LDRH     R0,[SP, #+2]
        LDR.N    R1,??DataTable27_13
        LDR      R1,[R1, #+24]
        ADDS     R0,R1,R0
        STRH     R0,[SP, #+2]
// 1865         rsLV.shIdx = sLV.shIdx; rsLV.pV = static_cast<void*>(&sLV.shCounterScanedObj);
        LDRH     R0,[SP, #+2]
        STRH     R0,[R8, #+42]
        ADD      R0,SP,#+4
        STR      R0,[R8, #+24]
// 1866         do {
// 1867             SetupCLUInternalRef(static_cast<void*>(&rsLV));
??SetupCircutLinks_21:
        MOV      R1,R8
        MOVS     R0,R4
        BL       _ZN8Shematic19SetupCLUInternalRefEPv
// 1868         } while (++sLV.shCounterScanedObj < sLV.shAmtLU);
        LDRH     R0,[SP, #+4]
        ADDS     R0,R0,#+1
        STRH     R0,[SP, #+4]
        LDRSH    R0,[SP, #+4]
        LDRSH    R1,[SP, #+0]
        CMP      R0,R1
        BLT.N    ??SetupCircutLinks_21
// 1869     }
// 1870 	
// 1871 }
??SetupCircutLinks_20:
        ADD      SP,SP,#+52
        POP      {R4-R9,PC}       ;; return
// 1872 	
// 1873 //	while (shAmtLUDscElem 
// 1874 //	&& sLV.chBreakScanLUDscLoop == 0) {
// 1875 //		//Get Reference on Link Data
// 1876 //		//sLV.shIdxFldCRefInfo =0;?
// 1877 //		//
// 1878 //		while(sLV.shIdxLU < shAmtPlacedLU
// 1879 //		&& sLV.chBreakScanPlacedLULoop == 0){
// 1880 //			i = sLV.shIdxLU;
// 1881 //			pv = (void*) &rsLV.arrLUAreaListElem[i];
// 1882 //			rsLV.pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
// 1883 //			
// 1884 //			j = sLV.shIdxFldCRefInfo;
// 1885 //			if (rsLV.pCLUBase->shShemasIdLUStng == ar_n_output_CRDsc[j].shBaseIdLUStng &&
// 1886 //                    rsLV.pCLUBase->shShemasOrdNumStng == ar_n_output_CRDsc[j].shBaseOrdNumStng) {
// 1887 //						
// 1888 //						
// 1889 //			}
// 1890 //		}
// 1891 //	
// 1892 //	}
// 1893 	

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1894 void Shematic::SetupLULinks(void *pv) {
// 1895 //	register long i,j;
// 1896 	//First Param Index in CrrefArray
// 1897 	//Second Param Id & Type LU
// 1898 	pv = static_cast<void*>(&LL_CryaCrya);
_ZN8Shematic12SetupLULinksEPv:
        LDR.N    R2,??DataTable27_9
        MOVS     R1,R2
// 1899 	*(static_cast<short*>(pv)) = 1000;
        MOV      R2,#+1000
        STRH     R2,[R1, #+0]
// 1900 }
        BX       LR               ;; return
// 1901 
// 1902 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1903 void Shematic::SetupCLUInternalRef(void *pv){
_ZN8Shematic19SetupCLUInternalRefEPv:
        PUSH     {R4-R11,LR}
        SUB      SP,SP,#+20
        MOVS     R4,R0
        MOVS     R5,R1
// 1904     register long i,j;
// 1905 //   register Init2LcVarArea *pInit2LcVarArea = (Init2LcVarArea *)pv;
// 1906 	SBitFld_LUInInfo locSBitFld;
// 1907     LUCRefExchParam lcLUCRefExchParam;
// 1908     register Init2LcVarArea& rsLV = *(static_cast<Init2LcVarArea*>(pv));
        MOVS     R7,R5
// 1909     volatile short& shCounterScanedObj = *(static_cast<short*>(rsLV.pV));
        LDR      R0,[R7, #+24]
        STR      R0,[SP, #+4]
// 1910     
// 1911 
// 1912     i = shCounterScanedObj + rsLV.shIdx;
        LDR      R0,[SP, #+4]
        LDRSH    R0,[R0, #+0]
        LDRSH    R1,[R7, #+42]
        ADDS     R0,R1,R0
        MOVS     R6,R0
// 1913     pv = static_cast<void*>(&rsLV.arrLUAreaListElem[i]);
        LDR      R0,[R7, #+8]
        ADDS     R0,R0,R6, LSL #+3
        MOVS     R5,R0
// 1914     //rsLV.pCLUBase = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;static_cast<CLUBase*>( 
// 1915     rsLV.pCLUBase = static_cast<CLUBase*>((static_cast<LUAreaListElem*>(pv))->pvLU);
        LDR      R0,[R5, #+4]
        STR      R0,[R7, #+12]
// 1916     for (long ik = 0; ik < rsLV.pCLUBase->chNumInput; ik++) {
        MOVS     R8,#+0
??SetupCLUInternalRef_0:
        LDR      R0,[R7, #+12]
        LDRB     R0,[R0, #+6]
        CMP      R8,R0
        BGE.N    ??SetupCLUInternalRef_1
// 1917         lcLUCRefExchParam.shLU_ObjScanIndex = shCounterScanedObj;
        LDR      R0,[SP, #+4]
        LDRH     R0,[R0, #+0]
        STRH     R0,[SP, #+8]
// 1918         lcLUCRefExchParam.chLU_OrdNumIn = ik;// + 1; in function use as Idx
        MOV      R0,R8
        STRB     R0,[SP, #+10]
// 1919         lcLUCRefExchParam.pCLUBase = rsLV.pCLUBase;
        LDR      R0,[R7, #+12]
        STR      R0,[SP, #+12]
// 1920         FillSBitFld_LUInInfo(static_cast<void*>(&lcLUCRefExchParam), static_cast<void*>(&locSBitFld));
        MOV      R2,SP
        ADD      R1,SP,#+8
        MOVS     R0,R4
        BL       _ZN8Shematic20FillSBitFld_LUInInfoEPvS0_
// 1921         //Have OutPut Param               
// 1922         //-lcLUCRefExchParam.shRefIdLUStng   = locSBitFld.bfInfo_IdLUStng;
// 1923         //-lcLUCRefExchParam.shRefOrdNumStng = locSBitFld.bfInfo_OrdNumStng;
// 1924         //-lcLUCRefExchParam.chRefOrdNumOut  = locSBitFld.bfInfo_OrdNumOut;
// 1925          //Find Obj
// 1926         j = EvalIdxinarrLUAreaListElem(static_cast<long>(locSBitFld.bfInfo_IdLUStng));
        LDR      R0,[SP, #+0]
        LSRS     R1,R0,#+24
        MOVS     R0,R4
        BL       _ZN8Shematic26EvalIdxinarrLUAreaListElemEl
        MOV      R9,R0
// 1927         if(j!=(-1)){
        CMN      R9,#+1
        BEQ.N    ??SetupCLUInternalRef_2
// 1928              short shCounterFindObj = 0;
        MOVS     R10,#+0
// 1929              short shAmtLookObj = 0;
        MOVS     R11,#+0
// 1930             
// 1931             shAmtLookObj = static_cast<short>(EvalAmtIn_arrLUAreaListElem(static_cast<long>(locSBitFld.bfInfo_IdLUStng)));
        LDR      R0,[SP, #+0]
        LSRS     R1,R0,#+24
        MOVS     R0,R4
        BL       _ZN8Shematic27EvalAmtIn_arrLUAreaListElemEl
        MOV      R11,R0
// 1932             if(shAmtLookObj == (-1))
        SXTH     R11,R11          ;; SignExt  R11,R11,#+16,#+16
        CMN      R11,#+1
        BNE.N    ??SetupCLUInternalRef_3
// 1933                 shAmtLookObj = gblLUAreaAuxVar.shAmountPlacedLogicUnit-j;
        LDR.N    R0,??DataTable27
        LDRH     R0,[R0, #+0]
        SUBS     R0,R0,R9
        MOV      R11,R0
// 1934             
// 1935             rsLV.chVal = 0;rsLV.pCh = static_cast<char*>(0);
??SetupCLUInternalRef_3:
        MOVS     R0,#+0
        STRB     R0,[R7, #+48]
        MOVS     R0,#+0
        STR      R0,[R7, #+0]
// 1936             while ((shCounterFindObj) < shAmtLookObj && rsLV.chVal != 1) {
??SetupCLUInternalRef_4:
        SXTH     R10,R10          ;; SignExt  R10,R10,#+16,#+16
        SXTH     R11,R11          ;; SignExt  R11,R11,#+16,#+16
        CMP      R10,R11
        BGE.N    ??SetupCLUInternalRef_5
        LDRB     R0,[R7, #+48]
        CMP      R0,#+1
        BEQ.N    ??SetupCLUInternalRef_5
// 1937                 i = j + shCounterFindObj;
        SXTH     R10,R10          ;; SignExt  R10,R10,#+16,#+16
        ADDS     R6,R10,R9
// 1938                 pv = static_cast<void*>(&rsLV.arrLUAreaListElem[i]);
        LDR      R0,[R7, #+8]
        ADDS     R0,R0,R6, LSL #+3
        MOVS     R5,R0
// 1939                 //rsLV.pCLURef = (CLUBase*) ((LUAreaListElem*) pv)->pvLU;
// 1940                 rsLV.pCLURef = static_cast<CLUBase*>((static_cast<LUAreaListElem*>(pv))->pvLU);
        LDR      R0,[R5, #+4]
        STR      R0,[R7, #+16]
// 1941                 if ((rsLV.pCLURef->shShemasIdLUStng == static_cast<short>(locSBitFld.bfInfo_IdLUStng)) &&
// 1942                         (rsLV.pCLURef->shShemasOrdNumStng == static_cast<short>(locSBitFld.bfInfo_OrdNumStng))
// 1943                         ) {//Set UP Logic
        LDR      R0,[R7, #+16]
        LDRSH    R0,[R0, #+10]
        LDR      R1,[SP, #+0]
        CMP      R0,R1, LSR #+24
        BNE.N    ??SetupCLUInternalRef_6
        LDR      R0,[R7, #+16]
        LDRH     R0,[R0, #+12]
        LDR      R1,[SP, #+0]
        LSRS     R1,R1,#+16
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        SXTH     R1,R1            ;; SignExt  R1,R1,#+16,#+16
        CMP      R0,R1
        BNE.N    ??SetupCLUInternalRef_6
// 1944                     rsLV.pCh = static_cast<char*>(rsLV.pCLURef->pOut);
        LDR      R0,[R7, #+16]
        LDR      R0,[R0, #+20]
        STR      R0,[R7, #+0]
// 1945                     rsLV.pCh += static_cast<unsigned char>(locSBitFld.bfInfo_OrdNumOut - 1); //As Idx
        LDR      R0,[R7, #+0]
        LDR      R1,[SP, #+0]
        UXTH     R1,R1            ;; ZeroExt  R1,R1,#+16,#+16
        SUBS     R1,R1,#+1
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        ADDS     R0,R1,R0
        STR      R0,[R7, #+0]
// 1946                     rsLV.chVal = 1;
        MOVS     R0,#+1
        STRB     R0,[R7, #+48]
// 1947                     break;
        B.N      ??SetupCLUInternalRef_5
// 1948                 }
// 1949                 shCounterFindObj++;
??SetupCLUInternalRef_6:
        ADDS     R10,R10,#+1
        B.N      ??SetupCLUInternalRef_4
// 1950             }
// 1951             if (rsLV.pCh) {
??SetupCLUInternalRef_5:
        LDR      R0,[R7, #+0]
        CMP      R0,#+0
        BEQ.N    ??SetupCLUInternalRef_7
// 1952                 rsLV.arrPchIn = static_cast<char**>(rsLV.pCLUBase->pIn);
        LDR      R0,[R7, #+12]
        LDR      R0,[R0, #+0]
        STR      R0,[R7, #+4]
// 1953                 rsLV.arrPchIn[ik] = rsLV.pCh;
        LDR      R0,[R7, #+0]
        LDR      R1,[R7, #+4]
        STR      R0,[R1, R8, LSL #+2]
// 1954             }
// 1955             if(rsLV.chVal != 1)
??SetupCLUInternalRef_7:
        LDRB     R0,[R7, #+48]
        CMP      R0,#+1
        BEQ.N    ??SetupCLUInternalRef_2
// 1956                 rsLV.chErrCount++;//Is need?
        LDRB     R0,[R7, #+49]
        ADDS     R0,R0,#+1
        STRB     R0,[R7, #+49]
// 1957         }
// 1958     }
??SetupCLUInternalRef_2:
        ADDS     R8,R8,#+1
        B.N      ??SetupCLUInternalRef_0
// 1959 }
??SetupCLUInternalRef_1:
        ADD      SP,SP,#+20
        POP      {R4-R11,PC}      ;; return
// 1960 //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""
// 1961 //``````````````````````````````````````````````````````````````````````````````````
// 1962 //==================================================================================
// 1963 //--- 			 Interface function for CPP Schematic     -----------
// 1964 //==================================================================================
// 1965 //..................................................................................
// 1966 //""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1967 long InitSchematic(void){
InitSchematic:
        PUSH     {R7,LR}
// 1968 sh.Init();
        LDR.N    R0,??DataTable27_14
        BL       _ZN8Shematic4InitEv
// 1969 return 1;
        MOVS     R0,#+1
        POP      {R1,PC}          ;; return
// 1970 }
// 1971 

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
// 1972 void DoCalcWrp(void){
DoCalcWrp:
        PUSH     {R7,LR}
// 1973 sh.DoCalc();
        LDR.N    R0,??DataTable27_14
        BL       _ZN8Shematic6DoCalcEv
// 1974 }
        POP      {R0,PC}          ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27:
        DC32     gblLUAreaAuxVar

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_1:
        DC32     _Z10READ_DI_OpPv

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_2:
        DC32     GlobalObjectMap

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_3:
        DC32     chGblGround

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_4:
        DC32     _Z10SET_OUT_OpPv

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_5:
        DC32     _Z10SET_LED_OpPv

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_6:
        DC32     chGblVcc

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_7:
        DC32     _Z10AND_Op_8_1Pv

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_8:
        DC32     _Z6Mft_OpPv

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_9:
        DC32     LL_CryaCrya

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_10:
        DC32     arNum

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_11:
        DC32     shCounterCalls_GLB

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_12:
        DC32     arrSBitFldCRefInfo

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_13:
        DC32     preSetUP

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable27_14:
        DC32     sh

        SECTION `.init_array`:CODE:ROOT(2)
        SECTION_TYPE SHT_INIT_ARRAY, 0
        DATA
        DC32    RELOC_ARM_TARGET1 __sti__routine

        SECTION `.iar_vfe_header`:DATA:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
// 1975 
// 1976 
// 1977 
// 1978 
// 1979 
// 
// 19 599 bytes in section .bss
//    333 bytes in section .data
//      4 bytes in section .init_array
//  1 560 bytes in section .rodata
//  9 842 bytes in section .text
// 16 672 bytes in section NonZeroIniVars_RAM1
//  1 200 bytes in section ZeroInivars_RAM1
//    520 bytes in section variables_RAM1
// 
//  9 846 bytes of CODE  memory
//  1 560 bytes of CONST memory
// 38 324 bytes of DATA  memory
//
//Errors: none
//Warnings: none
