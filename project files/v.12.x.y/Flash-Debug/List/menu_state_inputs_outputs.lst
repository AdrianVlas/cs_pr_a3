###############################################################################
#
# IAR ANSI C/C++ Compiler V7.50.2.10312/W32 for ARM       24/Mar/2017  12:54:58
# Copyright 1999-2015 IAR Systems AB.
#
#    Cpu mode     =  thumb
#    Endian       =  little
#    Source file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\menu_state_inputs_outputs.c
#    Command line =  
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working
#        files\src\menu_state_inputs_outputs.c" -D USE_STDPERIPH_DRIVER -D
#        STM32F2XX -D USE_USB_OTG_FS -D KEYBOARD_VER_1 -D SYSTEM_VIEWER_ENABLE
#        -lc "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List" --remarks -o
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj" --no_cse --no_unroll --no_inline
#        --no_code_motion --no_tbaa --no_clustering --no_scheduling --debug
#        --endian=little --cpu=Cortex-M3 -e --enable_multibytes --fpu=None
#        --dlib_config G:\PRG\IAR7_50_2\arm\INC\c\DLib_Config_Full.h -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\working files\usb\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\CMSIS\Device\ST\STM32F2xx\Include\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32F2xx_StdPeriph_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_OTG_Driver\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Core\inc\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\Libraries\STM32_USB_Device_Library\Class\cdc\inc\"
#        -I "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\Config\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\OS\" -I
#        "G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\..\..\SystemView\SEGGER\" -On --use_c++_inline
#        --require_prototypes -I G:\PRG\IAR7_50_2\arm\CMSIS\Include\ -D
#        ARM_MATH_CM3
#    List file    =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\List\menu_state_inputs_outputs.lst
#    Object file  =  
#        G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\project
#        files\v.12.x.y\Flash-Debug\Obj\menu_state_inputs_outputs.o
#
###############################################################################

G:\emb_pj\CS_Demo\demo3\cs_pr_a\Device-2.12.x.y\working files\src\menu_state_inputs_outputs.c
      1          #include "header.h"
      2          
      3          #define ROWS_ONE_PART   2
      4          
      5          /*****************************************************/
      6          //Функція визначення, скільки розрядів є у числі
      7          /*****************************************************/
      8          unsigned int max_number_digit_in_number(int max_item)
      9          {
     10            unsigned int number_digit = 1;
     11            while (max_item  >= 10)
     12            {
     13              number_digit++;
     14              max_item /= 10;
     15            }
     16            
     17            return number_digit;
     18          }
     19          /*****************************************************/
     20          
     21          
     22          /*****************************************************/
     23          /*
     24          Функція переміщення по меню (без винятків і додаткових алгоритмів)
     25          
     26          Вхідні параметри
     27          (1 << BIT_REWRITE) - перемалювати меню
     28          (1 << BIT_KEY_DOWN) - рухатися вниз
     29          (1 << BIT_KEY_UP) - рухатися вверх
     30          */
     31          /*****************************************************/
     32          void move_into_ekran_input_or_output(unsigned int action, int max_row_tmp)
     33          {
     34            int max_row = DIV_TO_HIGHER(max_row_tmp, (MAX_COL_LCD/(max_number_digit_in_number(max_row_tmp) + 1))*(MAX_ROW_LCD/ROWS_ONE_PART));
     35            if (action & ((1 << BIT_REWRITE) | (1 << BIT_KEY_DOWN)))
     36            {
     37              if (action & (1 << BIT_KEY_DOWN)) current_state_menu2.index_position++;
     38              if(current_state_menu2.index_position >= max_row) current_state_menu2.index_position = 0;
     39            }
     40            else if (action & (1 << BIT_KEY_UP))
     41            {
     42              if(--current_state_menu2.index_position < 0) current_state_menu2.index_position = max_row - 1;
     43            }
     44          }
     45          /*****************************************************/
     46          
     47          /*****************************************************/
     48          //Формуємо екран відображення заголовків станів входів-виходів
     49          /*****************************************************/
     50          void make_ekran_list_inputs_outputs(void)
     51          {
     52            const uint8_t name_string[MAX_NAMBER_LANGUAGE][MAX_ROW_INPUT_OUTPUT_M2][MAX_COL_LCD + 1] = 
     53            {
     54              {
     55                " Сост.входов    ",
     56                " Сост.выходов   "
     57              },
     58              {
     59                " Стан входів    ",
     60                " Стан виходів   "
     61              },
     62              {
     63                " Inputs  state  ",
     64                " Outputs state  "
     65              },
     66              {
     67                " Кіріс жаfдайы  ",
     68                " Шыfыс жаfдайы  "
     69              }
     70            };
     71            int index_language = index_language_in_array(settings_fix_prt.language);
     72            
     73            unsigned int position_temp = current_state_menu2.index_position;
     74            unsigned int index_in_ekran = (position_temp >> POWER_MAX_ROW_LCD) << POWER_MAX_ROW_LCD;
     75            
     76            //Копіюємо  рядки у робочий екран
     77            for (size_t i = 0; i < MAX_ROW_LCD; i++)
     78            {
     79              //Наступні рядки треба перевірити, чи їх требе відображати у текучій коффігурації
     80              for (size_t j = 0; j < MAX_COL_LCD; j++) 
     81              {
     82                working_ekran[i][j] =  (index_in_ekran < MAX_ROW_INPUT_OUTPUT_M2) ? name_string[index_language][index_in_ekran][j] : ' ';
     83              }
     84              index_in_ekran++;
     85            }
     86          
     87            //Курсор по горизонталі відображається на першій позиції
     88            current_state_menu2.position_cursor_x = 0;
     89            //Відображення курору по вертикалі
     90            current_state_menu2.position_cursor_y = position_temp & (MAX_ROW_LCD - 1);
     91            //Курсор видимий
     92            current_state_menu2.cursor_on = 1;
     93            //Курсор не мигає
     94            current_state_menu2.cursor_blinking_on = 0;
     95            //Обновити повністю весь екран
     96            current_state_menu2.current_action = ACTION_WITH_CARRENT_EKRANE_FULL_UPDATE;
     97          }
     98          /*****************************************************/
     99          
    100          /*******************************************************/
    101          //Формуємо екрвн станів входів або виходів
    102          /*******************************************************/
    103          void make_ekran_state_inputs_or_outputs(void)
    104          {
    105            unsigned int max_number_digit = max_number_digit_in_number(*current_state_menu2.p_max_row); 
    106            unsigned int number_inputs_or_outputs_in_row = MAX_COL_LCD/(max_number_digit + 1);
    107            
    108            unsigned int in_out = current_state_menu2.index_position*number_inputs_or_outputs_in_row*(MAX_ROW_LCD/ROWS_ONE_PART) + 1;
    109            unsigned int row = 0;
    110            while (row < MAX_ROW_LCD)
    111            {
    112              uint8_t name_string[ROWS_ONE_PART][MAX_COL_LCD + 1] = 
    113              {
    114                "                ",
    115                "                "
    116              };
    117            
    118              for (size_t i = 0; i < number_inputs_or_outputs_in_row; i++)
    119              {
    120                unsigned int value = in_out + i;
    121                for (size_t j = 0; j < max_number_digit; j++)
    122                {
    123                  unsigned int digit = value % 10;
    124                  value /= 10;
    125                
    126                  name_string[0][i*(max_number_digit + 1) + (max_number_digit + 1 - 1) - j] = digit + 0x30;
    127                  if (value == 0) break;
    128                }
    129              
    130                int _n = in_out + i - 1;
    131                if (current_state_menu2.current_level == INPUTS_MENU2_LEVEL)
    132                {
    133                  __LN_INPUT *arr = (__LN_INPUT*)(spca_of_p_prt[ID_FB_INPUT - _ID_FB_FIRST_VAR]);
    134                  value = arr[_n].active_state[INPUT_OUT >> 3] & (1 << (INPUT_OUT & ((1 << 3) - 1)));
    135                }
    136                else
    137                {
    138                  __LN_OUTPUT *arr = (__LN_OUTPUT*)(spca_of_p_prt[ID_FB_OUTPUT - _ID_FB_FIRST_VAR]);
    139                  value = arr[_n].active_state[OUTPUT_OUT >> 3] & (1 << (OUTPUT_OUT & ((1 << 3) - 1)));
    140                }
    141                name_string[1][i*(max_number_digit + 1) + (max_number_digit + 1 - 1)] = (value != 0) +  + 0x30;
    142                if ((_n + 1) >= *current_state_menu2.p_max_row ) break;
    143              }
    144            
    145              //Копіюємо  рядки у робочий екран
    146              for (size_t i = 0; i < ROWS_ONE_PART; i++)
    147              {
    148                //Наступні рядки треба перевірити, чи їх требе відображати
    149                for (size_t j = 0; j < MAX_COL_LCD; j++)
    150                {
    151                  working_ekran[row + i][j] = name_string[i][j];
    152                }
    153              }
    154              
    155              in_out += number_inputs_or_outputs_in_row*(MAX_ROW_LCD/ROWS_ONE_PART);
    156              row += ROWS_ONE_PART;
    157            }
    158          
    159            //Відображення курору по вертикалі
    160            current_state_menu2.position_cursor_x = 0;
    161            //Відображення курору по вертикалі
    162            current_state_menu2.position_cursor_y = 0;
    163            //Курсор невидимий
    164            current_state_menu2.cursor_on = 0;
    165            //Курсор не мигає
    166            current_state_menu2.cursor_blinking_on = 0;
    167            //Обновити повністю весь екран
    168            current_state_menu2.current_action = ACTION_WITH_CARRENT_EKRANE_FULL_UPDATE;
    169          }
    170          /*****************************************************/
    171          
    172          /*****************************************************/
    173          //
    174          /*****************************************************/
    175          /*****************************************************/
    176          
    177          #undef ROWS_ONE_PART  

   Maximum stack usage in bytes:

   .cstack Function
   ------- --------
     152   make_ekran_list_inputs_outputs
       152   -> __aeabi_memcpy4
       152   -> index_language_in_array
      64   make_ekran_state_inputs_or_outputs
        64   -> __aeabi_memcpy4
        64   -> max_number_digit_in_number
       0   max_number_digit_in_number
      16   move_into_ekran_input_or_output
        16   -> max_number_digit_in_number


   Section sizes:

   Bytes  Function/Label
   -----  --------------
       4  ??DataTable2
       4  ??DataTable2_1
       4  ??DataTable2_2
       4  ??DataTable2_3
       4  ??DataTable2_4
       4  ??DataTable2_5
       4  ??DataTable2_6
     136  ?_0
      36  ?_1
     124  make_ekran_list_inputs_outputs
     300  make_ekran_state_inputs_or_outputs
      20  max_number_digit_in_number
     134  move_into_ekran_input_or_output

 
 172 bytes in section .rodata
 606 bytes in section .text
 
 606 bytes of CODE  memory
 172 bytes of CONST memory

Errors: none
Warnings: none
